/*
 Navicat Premium Data Transfer

 Source Server         : 140.143.225.238(腾讯云北京)
 Source Server Type    : MySQL
 Source Server Version : 50721
 Source Host           : 140.143.225.238
 Source Database       : qiqinote

 Target Server Type    : MySQL
 Target Server Version : 50721
 File Encoding         : utf-8

 Date: 04/02/2018 15:42:31 PM
*/

SET NAMES utf8;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
--  Table structure for `env`
-- ----------------------------
DROP TABLE IF EXISTS `env`;
CREATE TABLE `env` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `k` varchar(64) DEFAULT NULL COMMENT 'key',
  `v` varchar(200) DEFAULT NULL COMMENT 'value',
  `create_datetime` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Table structure for `find_pwd_question`
-- ----------------------------
DROP TABLE IF EXISTS `find_pwd_question`;
CREATE TABLE `find_pwd_question` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户id',
  `question` varchar(64) DEFAULT NULL COMMENT '问题',
  `answer` varchar(64) DEFAULT NULL COMMENT '答案',
  `create_datetime` datetime DEFAULT NULL COMMENT '创建时间',
  `is_del` int(2) DEFAULT '0' COMMENT '是否删除. 0否 1是. 默认0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Table structure for `note`
-- ----------------------------
DROP TABLE IF EXISTS `note`;
CREATE TABLE `note` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `id_link` varchar(64) NOT NULL,
  `parent_id` bigint(20) DEFAULT '-1' COMMENT '父ID',
  `path` varchar(255) DEFAULT NULL COMMENT '目录树路径, 如: -1_父父id_父id',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户id',
  `type` int(2) DEFAULT NULL COMMENT '笔记类型. 1普通笔记, 2Markdown',
  `note_num` int(11) DEFAULT NULL COMMENT '笔记数量. 只当是目录时有值',
  `note_content_num` int(11) DEFAULT NULL COMMENT '笔记内容段数量',
  `secret` int(2) DEFAULT NULL COMMENT '私密状态. 0公开访问, 1密码访问, 2私密访问, 3链接访问',
  `password` varchar(64) DEFAULT NULL COMMENT '密码, 笔记为私密时有值',
  `title` varchar(255) DEFAULT NULL COMMENT '笔记标题',
  `keyword` varchar(127) DEFAULT NULL COMMENT '关键词，多个以空隔分隔',
  `sequence` int(11) DEFAULT NULL COMMENT '序号',
  `description` varchar(255) DEFAULT NULL COMMENT '描述',
  `view_num` bigint(20) DEFAULT '0' COMMENT '浏览数',
  `digest` varchar(255) DEFAULT NULL COMMENT '摘要',
  `author` varchar(64) DEFAULT NULL COMMENT '作者',
  `origin_url` varchar(500) DEFAULT NULL COMMENT '文章来源',
  `status` int(2) DEFAULT '2' COMMENT '文章状态. -1待审核，0不通过，1通过，2全部通过（比如：主页）',
  `status_description` varchar(500) DEFAULT NULL COMMENT '审核理由',
  `create_datetime` datetime DEFAULT NULL COMMENT '创建时间',
  `update_datetime` datetime DEFAULT NULL COMMENT '更新时间',
  `is_del` int(2) DEFAULT '0' COMMENT '是否删除. 0否 1是. 默认0',
  PRIMARY KEY (`id`),
  KEY `索引1` (`user_id`),
  KEY `索引2` (`parent_id`),
  KEY `id_link` (`id_link`)
) ENGINE=InnoDB AUTO_INCREMENT=261 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `note`
-- ----------------------------
BEGIN;
INSERT INTO `note` VALUES ('1', 'wqI=', '-1', '-1', '1', '2', '6', '0', '2', null, '专属个人', null, '0', null, '88', null, null, null, '1', null, '2017-05-20 19:07:13', '2017-05-20 19:07:30', '0'), ('2', 'wqE=', '1', '-1_1', '1', '2', '0', '1', '2', '', '个人简历', '简历', '0', null, '68', null, null, null, '1', null, '2017-05-20 19:07:33', '2017-09-22 11:33:49', '0'), ('3', 'wqA=', '-1', '-1', '1', '2', '14', '0', '0', null, '软件服务', null, '0', null, '204', null, null, null, '1', null, '2017-05-20 19:45:15', '2017-05-20 19:59:31', '0'), ('4', 'wqc=', '144', '-1_3_144', '1', '2', '1', '0', '0', null, 'ActiveMQ', null, '0', null, '103', null, null, null, '1', null, '2017-05-20 19:45:47', '2017-07-11 12:04:04', '0'), ('5', 'wqY=', '4', '-1_3_144_4', '1', '2', '0', '1', '0', '', 'centos-ActiveMQ集群配置', 'centos activemq 集群', '0', null, '3', null, null, null, '1', null, '2017-05-20 19:46:06', '2017-06-14 18:10:24', '0'), ('6', 'wqU=', '7', '-1_3_7', '1', '2', '0', '1', '0', '', 'centos-elasticsearch集群配置', 'centos elasticsearch es 集群', '0', null, '4', null, null, null, '1', null, '2017-05-20 19:50:04', '2017-07-10 10:16:19', '0'), ('7', 'wqQ=', '3', '-1_3', '1', '2', '2', '0', '0', null, 'ElasticSearch', null, '0', null, '92', null, null, null, '1', null, '2017-05-20 19:51:09', '2017-05-20 19:51:18', '0'), ('8', 'wqs=', '3', '-1_3', '1', '2', '1', '0', '0', null, 'ImageMagicK', null, '0', null, '62', null, null, null, '1', null, '2017-05-20 19:52:03', '2017-05-20 19:52:14', '0'), ('9', 'wqo=', '8', '-1_3_8', '1', '2', '0', '1', '0', '', 'centos-ImageMagick安装与调试', 'centos imageMagick 安装', '0', null, '3', null, null, null, '1', null, '2017-05-20 19:52:31', '2017-07-10 10:19:18', '0'), ('10', 'wqLCvA==', '3', '-1_3', '1', '2', '3', '0', '0', null, '数据库', null, '0', null, '20', null, null, null, '1', null, '2017-05-20 19:53:22', '2017-05-20 19:53:57', '0'), ('11', 'wqLCvQ==', '10', '-1_3_10', '1', '2', '1', '0', '0', null, 'MongoDB', null, '0', null, '109', null, null, null, '1', null, '2017-05-20 19:54:03', '2017-05-20 19:54:13', '0'), ('12', 'wqLCvg==', '11', '-1_3_10_11', '1', '2', '0', '1', '0', '', 'centos-mongodb集群（副本集）配置', 'centos mongodb 集群', '0', null, '2', null, null, null, '1', null, '2017-05-20 19:54:20', '2017-06-14 17:50:58', '0'), ('13', 'wqLCvw==', '10', '-1_3_10', '1', '2', '3', '0', '0', null, 'MySQL', null, '0', null, '322', null, null, null, '1', null, '2017-05-20 19:55:20', '2017-05-20 19:55:26', '0'), ('14', 'wqLCuA==', '13', '-1_3_10_13', '1', '2', '0', '1', '0', '', 'centos-mysql主从配置', 'centos mysql 主从', '0', null, '1', null, null, null, '1', null, '2017-05-20 19:55:44', '2017-07-10 10:22:16', '0'), ('15', 'wqLCuQ==', '3', '-1_3', '1', '2', '1', '0', '0', null, '缓存', null, '0', null, '12', null, null, null, '1', null, '2017-05-20 19:59:40', '2017-05-20 19:59:47', '0'), ('16', 'wqLCug==', '17', '-1_3_15_17', '1', '2', '0', '1', '0', '', 'centos-redis-sentinel实现HA', 'centos redis sentinel HA', '0', null, '2', null, null, null, '1', null, '2017-05-20 19:59:51', '2017-05-22 11:18:13', '0'), ('17', 'wqLCuw==', '15', '-1_3_15', '1', '2', '4', '0', '0', null, 'Redis', null, '0', null, '343', null, null, null, '1', null, '2017-05-20 20:01:00', '2017-05-20 20:01:10', '0'), ('18', 'wqLCtA==', '17', '-1_3_15_17', '1', '2', '0', '1', '0', '', 'centos-redis主从配置', 'centos redis 主从', '0', null, '7', null, null, null, '1', null, '2017-05-20 20:01:25', '2017-06-14 18:09:26', '0'), ('19', 'wqLCtQ==', '3', '-1_3', '1', '2', '1', '0', '0', null, 'Zabbix', null, '0', null, '102', null, null, null, '1', null, '2017-05-20 20:02:01', '2017-05-20 20:02:32', '0'), ('20', 'wqHCvA==', '19', '-1_3_19', '1', '2', '0', '1', '0', '', 'centos-zabbix安装部署', 'centos zabbix 安装 部署', '0', null, '1', null, null, null, '1', null, '2017-05-20 20:02:05', '2017-06-03 16:40:26', '0'), ('21', 'wqHCvQ==', '110', '-1_3_110', '1', '2', '1', '0', '0', null, 'zookeeper', null, '0', null, '197', null, null, null, '1', null, '2017-05-20 20:02:59', '2017-07-11 12:04:33', '0'), ('22', 'wqHCvg==', '21', '-1_3_110_21', '1', '2', '0', '1', '0', '', 'centos-zookeeper集群配置', 'centos zookeeper 集群', '0', null, '36', null, null, null, '1', null, '2017-05-20 20:03:02', '2017-06-26 11:14:36', '0'), ('23', 'wqHCvw==', '7', '-1_3_7', '1', '2', '0', '1', '0', null, 'centos-elasticsearch5.x插件head安装', 'centos es elasticsearch5 head', '0', null, '4', null, null, null, '1', null, '2017-05-20 20:04:27', '2017-06-14 17:38:18', '0'), ('24', 'wqHCuA==', '-1', '-1', '1', '2', '3', '0', '0', null, '系统', null, '0', null, '32', null, null, null, '1', null, '2017-05-20 20:13:25', '2017-05-20 20:13:43', '0'), ('25', 'wqHCuQ==', '24', '-1_24', '1', '2', '1', '0', '0', null, 'CentOS', null, '0', null, '310', null, null, null, '1', null, '2017-05-20 20:13:27', '2017-05-20 20:13:38', '0'), ('26', 'wqHCug==', '25', '-1_24_25', '1', '2', '0', '1', '0', null, 'centos-更改163yum源', 'centos yum 163 源', '0', null, '11', null, null, null, '1', null, '2017-05-20 20:13:46', '2017-06-13 18:32:02', '0'), ('27', 'wqHCuw==', '3', '-1_3', '1', '2', '1', '0', '0', null, 'GlusterFS', null, '0', null, '282', null, null, null, '1', null, '2017-05-20 20:14:48', '2017-05-20 20:15:34', '0'), ('28', 'wqHCtA==', '27', '-1_3_27', '1', '2', '0', '1', '0', null, 'centos-glusterfs集群', 'centos gluster 集群', '0', null, '5', null, null, null, '1', null, '2017-05-20 20:14:53', '2017-06-14 18:00:49', '0'), ('29', 'wqHCtQ==', '-1', '-1', '1', '2', '6', '0', '0', null, '开发语言', null, '0', null, '69', null, null, null, '1', null, '2017-05-21 21:23:06', '2017-05-22 18:27:11', '0'), ('30', 'wqDCvA==', '29', '-1_29', '1', '2', '2', '0', '0', null, 'JavaScript', null, '0', null, '14', null, null, null, '1', null, '2017-05-21 21:23:21', '2017-05-21 21:23:29', '0'), ('31', 'wqDCvQ==', '30', '-1_29_30', '1', '2', '1', '0', '0', null, 'jQuery', null, '0', null, '228', null, null, null, '1', null, '2017-05-21 21:23:33', '2017-05-21 21:23:44', '0'), ('32', 'wqDCvg==', '31', '-1_29_30_31', '1', '2', '0', '1', '0', null, 'jquery-回车登录', 'js jquery 回车', '0', null, '4', null, null, null, '1', null, '2017-05-21 21:23:53', '2017-05-22 11:15:16', '0'), ('33', 'wqDCvw==', '30', '-1_29_30', '1', '2', '2', '0', '0', null, 'js工具函数', null, '0', null, '330', null, null, null, '1', null, '2017-05-21 21:38:31', '2017-05-21 21:38:43', '0'), ('34', 'wqDCuA==', '33', '-1_29_30_33', '1', '2', '0', '1', '0', null, 'js数字转中文', 'js 数字 中文', '0', null, '2', null, null, null, '1', null, '2017-05-21 21:38:50', '2017-05-22 14:04:17', '0'), ('35', 'wqDCuQ==', '3', '-1_3', '1', '2', '3', '0', '0', null, '开发工具', null, '0', null, '31', null, null, null, '1', null, '2017-05-21 21:44:12', '2017-06-06 14:31:28', '0'), ('36', 'wqDCug==', '29', '-1_29', '1', '2', '5', '0', '0', null, 'Java', null, '0', null, '48', null, null, null, '1', null, '2017-05-21 21:47:15', '2017-05-21 21:47:27', '0'), ('37', 'wqDCuw==', '36', '-1_29_36', '1', '2', '6', '0', '0', null, 'Java工具类', null, '0', null, '242', null, null, null, '1', null, '2017-05-21 21:47:31', '2017-08-04 13:24:12', '0'), ('38', 'wqDCtA==', '37', '-1_29_36_37', '1', '2', '0', '1', '0', null, 'java生成图片验证码', 'java 图片 验证码', '0', null, '2', null, null, null, '1', null, '2017-05-21 21:48:11', '2017-05-22 11:14:33', '0'), ('40', 'wqfCvA==', '41', '-1_29_41', '1', '2', '0', '1', '0', null, 'Markdown常用操作', 'markdown 操作', '0', null, '23', null, null, null, '1', null, '2017-05-21 22:24:42', '2017-06-14 15:53:48', '0'), ('41', 'wqfCvQ==', '29', '-1_29', '1', '2', '1', '0', '0', null, 'Markdown', null, '0', null, '346', null, null, null, '1', null, '2017-05-21 22:31:53', '2017-05-21 22:32:00', '0'), ('42', 'wqfCvg==', '37', '-1_29_36_37', '1', '2', '0', '1', '0', null, 'java分页', 'java 分页', '0', null, '1', null, null, null, '1', null, '2017-05-22 11:11:40', '2017-05-22 11:13:55', '0'), ('43', 'wqfCvw==', '29', '-1_29', '1', '2', '1', '0', '0', null, 'golang', null, '0', null, '69', null, null, null, '1', null, '2017-05-22 11:20:02', '2017-05-22 11:20:12', '0'), ('44', 'wqfCuA==', '43', '-1_29_43', '1', '2', '0', '1', '0', null, 'mac安装golang开发环境', 'mac golang 开发环境 安装', '0', null, '1', null, null, null, '1', null, '2017-05-22 11:20:19', '2017-06-16 14:35:56', '0'), ('45', 'wqfCuQ==', '33', '-1_29_30_33', '1', '2', '0', '1', '0', null, 'js数字转义可读字符串', 'js 数字 转义 可读 字符串', '0', null, '5', null, null, null, '1', null, '2017-05-22 13:51:36', '2017-05-22 14:04:23', '0'), ('46', 'wqfCug==', '37', '-1_29_36_37', '1', '2', '0', '1', '0', null, 'java获取异常的全部信息', 'java 异常 全部 信息', '0', null, '1', null, null, null, '1', null, '2017-05-22 14:04:47', '2017-08-02 13:56:18', '0'), ('47', 'wqfCuw==', '36', '-1_29_36', '1', '2', '1', '0', '0', null, 'Java异常或错误', null, '0', null, '102', null, null, null, '1', null, '2017-05-22 15:12:27', '2017-08-04 13:24:18', '0'), ('48', 'wqfCtA==', '47', '-1_29_36_47', '1', '2', '0', '1', '0', null, 'java web乱码', 'java web 乱码', '0', null, '1', null, null, null, '1', null, '2017-05-22 15:12:39', '2017-05-22 15:17:23', '0'), ('49', 'wqfCtQ==', '35', '-1_3_35', '1', '2', '2', '0', '0', null, 'Eclipse', null, '0', null, '157', null, null, null, '1', null, '2017-05-22 15:18:56', '2017-05-22 15:19:02', '0'), ('50', 'wqbCvA==', '49', '-1_3_35_49', '1', '2', '0', '1', '0', null, 'ubuntu下修改eclipse提示框颜色', 'ubuntu eclipse 提示框 颜色', '0', null, '1', null, null, null, '1', null, '2017-05-22 15:19:09', '2017-05-22 15:26:59', '0'), ('51', 'wqbCvQ==', '49', '-1_3_35_49', '1', '2', '0', '1', '0', null, 'eclipse内存溢出', 'eclipse 内存 溢出', '0', null, '3', null, null, null, '1', null, '2017-05-22 15:28:34', '2017-05-22 15:33:08', '0'), ('52', 'wqbCvg==', '144', '-1_3_144', '1', '2', '3', '0', '0', null, 'RabbitMQ', null, '0', null, '202', null, null, null, '1', null, '2017-05-22 15:40:23', '2017-07-11 12:04:00', '0'), ('53', 'wqbCvw==', '52', '-1_3_144_52', '1', '2', '0', '1', '0', null, 'RabbitMQ 安装与配置', 'rabbitmq 安装 配置', '0', null, '3', null, null, null, '1', null, '2017-05-22 15:40:43', '2017-06-14 17:36:05', '0'), ('54', 'wqbCuA==', '52', '-1_3_144_52', '1', '2', '0', '1', '0', null, 'centos-RabbitMQ集群配置', 'centos rabbitmq 集群', '0', null, '2', null, null, null, '1', null, '2017-05-22 16:01:41', '2017-05-22 16:26:21', '0'), ('55', 'wqbCuQ==', '52', '-1_3_144_52', '1', '2', '0', '1', '0', null, 'spring mvc连接RabbitMQ', 'spring 连接 rabbitmq', '0', null, '2', null, null, null, '1', null, '2017-05-22 16:46:47', '2017-05-22 17:04:52', '0'), ('56', 'wqbCug==', '17', '-1_3_15_17', '1', '2', '0', '1', '0', null, 'centos-redis集群配置（单服务器）', 'centos redis 集群', '0', null, '4', null, null, null, '1', null, '2017-05-22 17:06:42', '2017-05-22 17:27:26', '0'), ('57', 'wqbCuw==', '110', '-1_3_110', '1', '2', '2', '0', '0', null, 'Hadoop', null, '0', null, '387', null, null, null, '1', null, '2017-05-22 18:08:45', '2017-06-09 13:20:31', '0'), ('58', 'wqbCtA==', '57', '-1_3_110_57', '1', '2', '0', '1', '0', null, 'centos-Hadoop1.2.1集群搭建', 'centos hadoop 集群 ', '0', null, '8', null, null, null, '1', null, '2017-05-22 18:09:00', '2017-06-12 10:09:58', '0'), ('59', 'wqbCtQ==', '3', '-1_3', '1', '2', '2', '0', '0', null, 'Tomcat', null, '0', null, '170', null, null, null, '1', null, '2017-05-22 18:22:40', '2017-05-22 18:22:49', '0'), ('60', 'wqXCvA==', '59', '-1_3_59', '1', '2', '0', '1', '0', null, 'tomcat GET请求数据乱码', 'tomcat get 乱码', '0', null, '1', null, null, null, '1', null, '2017-05-22 18:22:54', '2017-05-22 18:26:26', '0'), ('61', 'wqXCvQ==', '37', '-1_29_36_37', '1', '2', '0', '1', '0', null, 'java操作ImageMagick工具类', 'java imageMagicK 工具类', '0', null, '2', null, null, null, '1', null, '2017-05-22 18:27:34', '2017-06-23 10:04:06', '0'), ('62', 'wqXCvg==', '13', '-1_3_10_13', '1', '2', '0', '1', '0', null, 'mac下更新mysql密码', 'mac mysql 更新密码', '0', null, '3', null, null, null, '1', null, '2017-05-22 19:04:01', '2017-05-22 19:05:54', '0'), ('63', 'wqXCvw==', '13', '-1_3_10_13', '1', '2', '0', '1', '0', null, 'mysql添加访问用户', 'mysql 外网 访问 用户', '0', null, '2', null, null, null, '1', null, '2017-05-22 19:05:57', '2017-06-28 11:30:09', '0'), ('64', 'wqXCuA==', '-1', '-1', '1018', '2', '9', '1', '2', null, 'css3', 'css3', '0', null, '7', null, null, null, '1', null, '2017-05-23 19:20:58', '2017-05-24 15:03:50', '0'), ('65', 'wqXCuQ==', '64', '-1_64', '1018', '2', '0', '0', '2', null, '背景-background', 'css3-background', '0', null, '0', null, null, null, '1', null, '2017-05-23 19:26:48', '2017-05-23 19:33:43', '0'), ('66', 'wqXCug==', '-1', '-1', '1018', '2', '1', '0', '0', null, 'html5', null, '0', null, '7', null, null, null, '1', null, '2017-05-23 19:26:52', '2017-05-23 19:27:00', '0'), ('67', 'wqXCuw==', '66', '-1_66', '1018', '2', '0', '1', '0', null, 'html5——sessionStorage不能跨标签页解决方案', 'html5，sessionStorage', '0', null, '5', null, null, null, '1', null, '2017-05-23 19:26:54', '2017-06-15 15:00:53', '0'), ('68', 'wqXCtA==', '-1', '-1', '1018', '2', '3', '1', '2', null, 'reactJs', 'reactJs', '0', null, '1', null, null, null, '1', null, '2017-05-23 19:27:03', '2017-05-24 15:09:26', '0'), ('69', 'wqXCtQ==', '68', '-1_68', '1018', '2', '0', '1', '0', null, 'React+Redux 同构应用开发', 'React+Redux 同构应用开发', '0', null, '3', null, null, null, '1', null, '2017-05-23 19:27:05', '2017-06-15 15:07:09', '0'), ('76', 'wqTCug==', '-1', '-1', '1004', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 09:38:04', '2017-05-24 09:38:04', '0'), ('77', 'wqTCuw==', '-1', '-1', '1018', '2', '1', '1', '0', null, 'jquery插件', 'jquery插件', '0', null, '246', null, null, null, '1', null, '2017-05-24 09:54:12', '2017-05-24 19:00:23', '0'), ('78', 'wqTCtA==', '77', '-1_77', '1018', '2', '0', '1', '0', null, 'jQuery插件版日历签到', 'jQuery插件版日历签到', '0', null, '33', null, null, null, '1', null, '2017-05-24 09:56:19', '2017-05-24 18:56:46', '0'), ('79', 'wqTCtQ==', '-1', '-1', '1005', '2', '1', '1', '2', null, 'mongodb', '', '0', null, '222', null, null, null, '1', null, '2017-05-24 10:21:45', '2017-05-25 16:31:32', '0'), ('80', 'wqvCvA==', '79', '-1_79', '1005', '2', '0', '1', '0', null, 'Replica Set副本集配置', 'mongodb  replica set', '0', null, '21', null, null, null, '1', null, '2017-05-24 10:41:45', '2017-06-23 19:01:33', '0'), ('81', 'wqvCvQ==', '64', '-1_64', '1018', '2', '0', '0', '2', null, 'css3选择器', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 15:03:57', '2017-05-24 15:04:11', '0'), ('82', 'wqvCvg==', '64', '-1_64', '1018', '2', '0', '0', '2', null, '盒模型', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 15:04:22', '2017-05-24 15:04:43', '0'), ('84', 'wqvCuA==', '64', '-1_64', '1018', '2', '0', '0', '2', null, '边框-border', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 15:04:49', '2017-05-24 15:05:01', '0'), ('85', 'wqvCuQ==', '64', '-1_64', '1018', '2', '0', '0', '2', null, '2D/3D转换', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 15:05:05', '2017-05-24 15:05:40', '0'), ('86', 'wqvCug==', '64', '-1_64', '1018', '2', '0', '0', '2', null, '动画', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 15:05:20', '2017-05-24 15:05:29', '0'), ('87', 'wqvCuw==', '64', '-1_64', '1018', '2', '0', '0', '2', null, '文字特效', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 15:05:51', '2017-05-24 15:06:00', '0'), ('88', 'wqvCtA==', '64', '-1_64', '1018', '2', '0', '0', '2', null, '多列布局', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 15:06:03', '2017-05-24 15:06:12', '0'), ('89', 'wqvCtQ==', '64', '-1_64', '1018', '2', '0', '0', '2', null, '用户界面', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 15:06:15', '2017-05-24 15:06:21', '0'), ('92', 'wqrCvg==', '-1', '-1', '1006', '2', '1', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 16:16:11', '2017-05-24 16:16:11', '0'), ('93', 'wqrCvw==', '92', '-1_92', '1006', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-05-24 16:16:27', '2017-05-24 16:16:27', '0'), ('94', 'wqrCuA==', '24', '-1_24', '1', '2', '1', '0', '0', null, 'Mac', null, '0', null, '8', null, null, null, '1', null, '2017-05-25 11:26:20', '2017-05-26 18:49:25', '0'), ('95', 'wqrCuQ==', '-1', '-1', '1', '2', '2', '0', '2', null, '公司', null, '0', null, '3', null, null, null, '1', null, '2017-06-01 18:34:21', '2017-06-01 18:34:39', '0'), ('96', 'wqrCug==', '95', '-1_95', '1', '2', '7', '0', '2', null, '北京联动在线通讯科技有限公司', null, '0', null, '35', null, null, null, '1', null, '2017-06-01 18:35:03', '2017-06-01 18:45:50', '0'), ('97', 'wqrCuw==', '96', '-1_95_96', '1', '2', '0', '1', '2', null, '时装配置信息', '', '0', null, '0', null, null, null, '1', null, '2017-06-01 18:35:44', '2017-09-06 10:10:33', '0'), ('98', 'wqrCtA==', '96', '-1_95_96', '1', '2', '0', '1', '2', null, '爱上配置信息', '', '0', null, '0', null, null, null, '1', null, '2017-06-01 18:40:46', '2017-06-02 16:35:32', '0'), ('99', 'wqrCtQ==', '-1', '-1', '520', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-06-02 23:23:54', '2017-06-02 23:23:54', '0'), ('100', 'wqLCvAE=', '96', '-1_95_96', '1', '2', '0', '1', '2', null, '爱上监听配置信息', '', '0', null, '0', null, null, null, '1', null, '2017-06-03 12:10:19', '2017-09-06 10:31:09', '0'), ('101', 'wqLCvAA=', '-1', '-1', '1019', '2', '0', '0', '0', null, '11111', '', '0', null, '0', null, null, null, '1', null, '2017-06-03 16:48:31', '2017-06-03 17:02:02', '0'), ('102', 'wqLCvAM=', '-1', '-1', '1020', '2', '2', '1', '0', null, 'php对文件访问的保护机制', 'php,保护机制', '0', null, '10', null, null, null, '1', null, '2017-06-06 10:58:38', '2017-06-08 14:47:56', '0'), ('103', 'wqLCvAI=', '117', '-1_117', '1', '2', '0', '0', '2', null, 'Maven', null, '0', null, '53', null, null, null, '1', null, '2017-06-06 14:31:31', '2017-07-11 12:02:33', '0'), ('104', 'wqLCvAU=', '142', '-1_3_142', '1', '2', '0', '1', '0', null, 'maven编译打包优化', 'maven 编译 打包 优化', '0', null, '2', null, null, null, '1', null, '2017-06-06 14:31:48', '2017-10-16 16:04:57', '0'), ('105', 'wqLCvAQ=', '116', '-1_102_116', '1020', '2', '0', '1', '1', '32323', 'ngrok服务器搭建步骤', '', '0', null, '0', null, null, null, '1', null, '2017-06-06 21:26:50', '2017-06-20 22:37:33', '0'), ('106', 'wqLCvAc=', '36', '-1_29_36', '1', '2', '6', '0', '0', null, 'Java基础', null, '0', null, '99', null, null, null, '1', null, '2017-06-08 10:47:40', '2017-08-04 13:23:45', '0'), ('107', 'wqLCvAY=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, '数组、链表', '数组 链表', '0', null, '3', null, null, null, '1', null, '2017-06-08 10:47:51', '2017-08-04 13:23:33', '0'), ('108', 'wqLCvAk=', '197', '-1_29_36_106_197', '1', '2', '0', '1', '0', null, 'SpringBean作用域', 'spring bean 作用域', '0', null, '1', null, null, null, '1', null, '2017-06-08 13:55:45', '2017-08-04 13:24:54', '0'), ('109', 'wqLCvAg=', '196', '-1_29_36_106_196', '1', '2', '0', '1', '0', null, '数据库：事务ACID、事务隔离级别与事务传播行为', '数据库 事务 特性 acid 隔离级别 传播', '0', null, '6', null, null, null, '1', null, '2017-06-08 14:44:56', '2017-08-04 13:24:39', '0'), ('110', 'wqLCvQE=', '3', '-1_3', '1', '2', '7', '0', '0', null, '大数据', null, '0', null, '68', null, null, null, '1', null, '2017-06-08 16:32:33', '2017-06-09 13:20:23', '0'), ('111', 'wqLCvQA=', '-1', '-1', '1021', '2', '0', '1', '0', null, '酷狗音乐用户服务协议', '', '0', null, '10', null, null, null, '1', null, '2017-06-09 09:48:47', '2017-09-11 14:44:21', '0'), ('112', 'wqLCvQM=', '57', '-1_3_110_57', '1', '2', '0', '1', '0', null, 'centos-Hadoop2.7.3完全分布式搭建（HA）', 'centos hadoop 2.x 2.7.3 集群 完全 分布式', '0', null, '315', null, null, null, '1', null, '2017-06-09 13:48:01', '2017-07-13 09:31:36', '0'), ('113', 'wqLCvQI=', '110', '-1_3_110', '1', '2', '3', '0', '0', null, 'Spark', null, '0', null, '56', null, null, null, '1', null, '2017-06-13 10:02:20', '2017-06-13 10:02:29', '0'), ('114', 'wqLCvQU=', '113', '-1_3_110_113', '1', '2', '0', '1', '0', null, 'RDD五大特性', 'RDD 弹性分布式数据集 五大特性', '0', null, '9', null, null, null, '1', null, '2017-06-13 10:17:39', '2017-06-27 09:44:04', '0'), ('115', 'wqLCvQQ=', '-1', '-1', '1020', '2', '0', '1', '0', null, '酷狗音乐用户服务协议', '', '0', null, '24', null, null, null, '1', null, '2017-06-15 11:33:06', '2017-06-15 11:34:17', '0'), ('116', 'wqLCvQc=', '102', '-1_102', '1020', '2', '1', '1', '0', null, 'QQ音乐服务许可协议', '', '0', null, '4', null, null, null, '1', null, '2017-06-15 11:34:26', '2017-06-20 22:37:28', '0'), ('117', 'wqLCvQY=', '-1', '-1', '1', '2', '2', '0', '2', null, '虚拟机环境配置', null, '0', null, '1', null, null, null, '1', null, '2017-06-15 14:13:42', '2017-06-26 10:57:21', '0'), ('118', 'wqLCvQk=', '-1', '-1', '1018', '2', '0', '1', '0', null, '常遇到的浏览器兼容性问题', '前端  浏览器兼容性', '0', null, '3', null, null, null, '1', null, '2017-06-15 15:09:52', '2017-06-15 15:17:49', '0'), ('119', 'wqLCvQg=', '68', '-1_68', '1018', '2', '0', '1', '0', null, 'reactjs的一些知识点', 'reactjs', '0', null, '1', null, null, null, '1', null, '2017-06-16 10:15:12', '2017-06-16 10:35:51', '0'), ('120', 'wqLCvgE=', '68', '-1_68', '1018', '2', '0', '1', '0', null, 'reactjs的使用', 'reactjs的使用', '0', null, '4', null, null, null, '1', null, '2017-06-16 10:50:22', '2017-06-16 11:02:52', '0'), ('121', 'wqLCvgA=', '-1', '-1', '1022', '2', '0', '1', '0', null, 'git 常用操作', '', '0', null, '6', null, null, null, '1', null, '2017-06-16 14:53:54', '2017-06-16 15:20:25', '0'), ('122', 'wqLCvgM=', '-1', '-1', '110', '2', '0', '1', '0', '', '浏览器多标签共享sessionstorage', '', '0', null, '5', null, null, null, '1', null, '2017-06-16 15:31:41', '2017-06-26 15:12:06', '0'), ('123', 'wqLCvgI=', '113', '-1_3_110_113', '1', '2', '0', '1', '0', null, 'mac配置Intellij IDEA的Spark运行环境', 'mac idea spark', '0', null, '1', null, null, null, '1', null, '2017-06-19 11:40:22', '2017-06-23 16:11:14', '0'), ('124', 'wqLCvgU=', '1', '-1_1', '1', '2', '0', '1', '2', null, '备案信息', '', '0', null, '0', null, null, null, '1', null, '2017-06-19 17:52:32', '2017-06-19 18:05:08', '0'), ('125', 'wqLCvgQ=', '96', '-1_95_96', '1', '2', '0', '1', '2', null, '加班记录', '', '0', null, '0', null, null, null, '1', null, '2017-06-19 17:53:53', '2017-07-25 16:54:26', '0'), ('126', 'wqLCvgc=', '1', '-1_1', '1', '2', '0', '1', '2', null, '信息', '', '0', null, '0', null, null, null, '1', null, '2017-06-20 13:50:37', '2018-01-25 10:38:30', '0'), ('127', 'wqLCvgY=', '102', '-1_102', '1020', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-06-20 22:37:04', '2017-07-03 09:41:01', '0'), ('128', 'wqLCvgk=', '1', '-1_1', '1', '2', '0', '1', '2', null, '奇奇笔记', '', '0', null, '0', null, null, null, '1', null, '2017-06-23 11:02:37', '2017-12-01 11:33:59', '0'), ('129', 'wqLCvgg=', '96', '-1_95_96', '1', '2', '0', '1', '2', null, 'Hadoop配置', '', '0', null, '0', null, null, null, '1', null, '2017-06-23 16:43:23', '2017-06-23 16:52:50', '0'), ('130', 'wqLCvwE=', '3', '-1_3', '1', '2', '0', '1', '0', null, 'rsync的基本使用', 'rsync', '0', null, '4', null, null, null, '1', null, '2017-06-23 17:05:39', '2017-06-27 13:49:34', '0'), ('131', 'wqLCvwA=', '117', '-1_117', '1', '2', '0', '1', '2', null, '信息', '', '0', null, '1', null, null, null, '1', null, '2017-06-26 10:56:42', '2017-07-06 18:30:18', '0'), ('132', 'wqLCvwM=', '-1', '-1', '110', '2', '0', '1', '0', '', 'AMD异步模块中使用JQuery及Jquery插件的方法', '', '0', null, '3', null, null, null, '1', null, '2017-06-26 14:59:06', '2017-06-26 15:33:08', '0'), ('133', 'wqLCvwI=', '-1', '-1', '110', '2', '0', '1', '0', null, '编写高效的jQuery 插件', '', '0', null, '1', null, null, null, '1', null, '2017-06-26 15:02:51', '2017-06-26 15:11:52', '0'), ('134', 'wqLCvwU=', '113', '-1_3_110_113', '1', '2', '0', '1', '0', null, 'DAG优化', 'spark DAG dag 宽依赖 窄依赖', '0', null, '1', null, null, null, '1', null, '2017-06-27 12:20:39', '2017-06-27 12:41:56', '0'), ('135', 'wqLCvwQ=', '110', '-1_3_110', '1', '2', '0', '1', '0', null, 'centos-Kafka-0.11.0.0集群配置', 'centos kafka 集群', '0', null, '0', null, null, null, '1', null, '2017-06-27 13:30:52', '2017-07-06 18:31:50', '0'), ('136', 'wqLCvwc=', '110', '-1_3_110', '1', '2', '0', '1', '0', null, 'centos-Flume1.7.0', 'centos flume 1.7.0 kafka', '0', null, '1', null, null, null, '1', null, '2017-06-27 15:17:51', '2017-07-06 18:34:06', '0'), ('137', 'wqLCvwY=', '29', '-1_29', '1', '2', '1', '0', '0', null, 'Kotlin', '', '0', null, '2', null, null, null, '1', null, '2017-06-30 15:09:48', '2017-07-12 09:51:35', '0'), ('139', 'wqLCvwg=', '17', '-1_3_15_17', '1', '2', '0', '1', '0', null, 'Jedis常用操作', 'Jedis, 操作', '0', null, '1', null, null, null, '1', null, '2017-07-06 10:54:25', '2017-07-07 10:00:26', '0'), ('140', 'wqLCuAE=', '110', '-1_3_110', '1', '2', '0', '1', '0', null, 'centos-基于Hadoop的HBase1.2.6完全分布式搭建（HA）', 'hbase, 搭建, HA', '0', null, '3', null, null, null, '1', null, '2017-07-06 15:55:22', '2017-07-10 16:09:30', '0'), ('141', 'wqLCuAA=', '-1', '-1', '1018', '2', '0', '1', '0', null, '微信内置浏览器的JsAPI', '微信内置浏览器的JsAPI', '0', null, '2', null, null, null, '1', null, '2017-07-06 17:23:31', '2017-07-06 17:24:16', '0'), ('142', 'wqLCuAM=', '3', '-1_3', '1', '2', '2', '0', '0', null, 'Maven', null, '0', null, '7', null, null, null, '1', null, '2017-07-11 10:21:48', '2017-07-11 10:21:58', '0'), ('143', 'wqLCuAI=', '142', '-1_3_142', '1', '2', '0', '1', '0', null, 'settings.xml', '', '0', null, '0', null, null, null, '1', null, '2017-07-11 10:22:03', '2017-07-11 10:22:47', '0'), ('144', 'wqLCuAU=', '3', '-1_3', '1', '2', '2', '0', '0', null, '消息列队', null, '0', null, '4', null, null, null, '1', null, '2017-07-11 12:03:42', '2017-07-11 12:03:56', '0'), ('145', 'wqLCuAQ=', '137', '-1_29_137', '1', '2', '0', '1', '0', null, 'Kotlin基础语法', 'kotlin, 基础, 语法', '0', null, '1', null, null, null, '1', null, '2017-07-12 09:51:23', '2017-07-12 15:05:35', '0'), ('146', 'wqLCuAc=', '-1', '-1', '1000', '2', '0', '1', '0', null, '新笔记', null, '0', null, '1', null, null, null, '1', null, '2017-07-12 14:24:31', '2017-07-12 14:44:41', '0'), ('147', 'wqLCuAY=', '-1', '-1', '1000', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-07-12 14:29:41', '2017-07-12 14:29:41', '0'), ('148', 'wqLCuAk=', '149', '-1_29_36_149', '1', '2', '0', '1', '0', null, 'JAVA常用算法题', 'java, 算法题', '0', null, '1', null, null, null, '1', null, '2017-07-25 14:22:01', '2017-07-25 16:36:27', '0'), ('149', 'wqLCuAg=', '36', '-1_29_36', '1', '2', '1', '0', '0', null, '常用算法题', null, '0', null, '2', null, null, null, '1', null, '2017-07-25 14:22:39', '2017-07-25 14:25:55', '0'), ('150', 'wqLCuQE=', '-1', '-1', '1', '2', '3', '0', '0', null, '工具', null, '0', null, '9', null, null, null, '1', null, '2017-07-25 17:07:50', '2017-07-25 17:07:55', '0'), ('151', 'wqLCuQA=', '150', '-1_150', '1', '2', '0', '1', '0', null, 'Lantern（蓝灯）下载地址', 'lantern, 蓝灯, 下载地址', '0', null, '1', null, null, null, '1', null, '2017-07-25 17:07:59', '2017-07-25 17:08:53', '0'), ('152', 'wqLCuQM=', '24', '-1_24', '1', '2', '1', '0', '0', null, 'Linux', null, '0', null, '9', null, null, null, '1', null, '2017-07-27 10:04:46', '2017-07-27 10:04:53', '0'), ('153', 'wqLCuQI=', '152', '-1_24_152', '1', '2', '0', '1', '0', null, 'linux常用命令', '', '0', null, '1', null, null, null, '1', null, '2017-07-27 10:04:56', '2017-09-22 11:19:38', '0'), ('154', 'wqLCuQU=', '-1', '-1', '1005', '2', '3', '0', '0', null, 'linux c 王者归来笔记', '', '0', null, '3', null, null, null, '1', null, '2017-07-27 16:23:05', '2017-07-27 17:39:11', '0'), ('155', 'wqLCuQQ=', '154', '-1_154', '1005', '2', '0', '1', '0', null, 'linux C 控制结构', '短路计算  循环结构 switch语句  控制结构优化', '0', null, '10', null, null, null, '1', null, '2017-07-27 16:39:06', '2017-07-31 11:58:28', '0'), ('156', 'wqLCuQc=', '154', '-1_154', '1005', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-07-27 17:12:01', '2017-07-27 17:12:01', '0'), ('157', 'wqLCuQY=', '154', '-1_154', '1005', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-07-27 18:01:15', '2017-07-27 18:01:15', '0'), ('158', 'wqLCuQk=', '96', '-1_95_96', '1', '2', '0', '1', '2', null, 'Ins功能讨论(技术部)', '', '0', null, '0', null, null, null, '1', null, '2017-07-31 10:08:22', '2017-07-31 10:09:33', '0'), ('159', 'wqLCuQg=', '37', '-1_29_36_37', '1', '2', '0', '1', '0', null, 'java对称加密解密 - AESUtil', 'aes AES 对称', '0', null, '0', null, null, null, '1', null, '2017-08-03 10:38:12', '2017-08-03 10:47:25', '0'), ('160', 'wqLCugE=', '37', '-1_29_36_37', '1', '2', '0', '1', '0', null, 'java非对称加密解密 - RSAUtil', 'RSA 非对称', '0', null, '0', null, null, null, '1', null, '2017-08-03 10:43:43', '2017-08-03 10:51:24', '0'), ('161', 'wqLCugA=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, 'NIO', '', '0', null, '1', null, null, null, '1', null, '2017-08-04 11:22:25', '2017-08-04 11:24:06', '0'), ('162', 'wqLCugM=', '106', '-1_29_36_106', '1', '2', '13', '0', '0', null, 'JavaConcurrent', null, '0', null, '3', null, null, null, '1', null, '2017-08-04 11:23:46', '2017-08-04 13:23:57', '0'), ('163', 'wqLCugI=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, 'Java并发基础知识', 'Java 并发 基础知识', '0', null, '1', null, null, null, '1', null, '2017-08-04 11:24:29', '2017-08-04 11:36:55', '0'), ('164', 'wqLCugU=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, 'synchronized', 'synchronized', '0', null, '0', null, null, null, '1', null, '2017-08-04 11:36:59', '2017-08-04 11:37:19', '0'), ('165', 'wqLCugQ=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, 'Thread和Runnable实现多线程的区别', '', '0', null, '1', null, null, null, '1', null, '2017-08-04 11:39:14', '2017-08-04 11:39:56', '0'), ('166', 'wqLCugc=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, '使用wait/notify/notifyAll实现线程间通信', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 11:44:18', '2017-08-04 11:44:37', '0'), ('167', 'wqLCugY=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, '可重入内置锁', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 11:46:25', '2017-08-04 11:47:12', '0'), ('168', 'wqLCugk=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, '多线程环境中安全使用集合API', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 11:49:45', '2017-08-04 11:49:56', '0'), ('169', 'wqLCugg=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, '守护线程与阻塞线程的四种情况', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 11:51:53', '2017-08-04 11:52:12', '0'), ('170', 'wqLCuwE=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, '并发编程中实现内存可见的两种方法比较：加锁和volatile变量', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 11:52:32', '2017-08-04 11:53:27', '0'), ('171', 'wqLCuwA=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, '死锁', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 11:52:58', '2017-08-04 11:53:16', '0'), ('172', 'wqLCuwM=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, '生产者和消费者问题', '', '0', null, '1', null, null, null, '1', null, '2017-08-04 11:53:37', '2017-08-04 11:53:55', '0'), ('173', 'wqLCuwI=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, '线程中断', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 11:55:01', '2017-08-04 11:55:13', '0'), ('174', 'wqLCuwU=', '106', '-1_29_36_106', '1', '2', '17', '0', '0', null, 'JavaSE', '', '0', null, '7', null, null, null, '1', null, '2017-08-04 11:55:49', '2017-08-04 13:23:50', '0'), ('175', 'wqLCuwQ=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'ArrarList源码剖析', '', '0', null, '2', null, null, null, '1', null, '2017-08-04 11:56:07', '2017-08-04 12:02:11', '0'), ('176', 'wqLCuwc=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'Collection', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 11:59:25', '2017-08-04 11:59:49', '0'), ('177', 'wqLCuwY=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'HashMap源码剖析', '', '0', null, '2', null, null, null, '1', null, '2017-08-04 12:00:16', '2017-08-04 12:00:39', '0'), ('178', 'wqLCuwk=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'HashMap的hashcode的作用', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 12:00:59', '2017-08-04 12:01:12', '0'), ('179', 'wqLCuwg=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'Hashtable源码剖析', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 12:01:28', '2017-08-04 12:01:50', '0'), ('180', 'wqLCtAE=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'Java中的内存泄漏', '', '0', null, '1', null, null, null, '1', null, '2017-08-04 12:02:22', '2017-08-04 12:03:49', '0'), ('181', 'wqLCtAA=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'Java基础知识', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 12:05:44', '2017-08-04 12:06:11', '0'), ('182', 'wqLCtAM=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'LinkedHashMap源码剖析', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:13:56', '2017-08-04 13:14:18', '0'), ('183', 'wqLCtAI=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'LinkedList源码剖析', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:14:37', '2017-08-04 13:15:04', '0'), ('184', 'wqLCtAU=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'List', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:15:26', '2017-08-04 13:15:42', '0'), ('185', 'wqLCtAQ=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'Queue', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:15:50', '2017-08-04 13:16:02', '0'), ('186', 'wqLCtAc=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'Set', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:16:58', '2017-08-04 13:17:08', '0'), ('187', 'wqLCtAY=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'String源码分析', '', '0', null, '1', null, null, null, '1', null, '2017-08-04 13:17:20', '2017-08-04 13:17:39', '0'), ('188', 'wqLCtAk=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, 'Vector源码剖析', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:17:47', '2017-08-04 13:18:12', '0'), ('189', 'wqLCtAg=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, '从源码分析HashMap', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:18:42', '2017-08-04 13:19:19', '0'), ('190', 'wqLCtQE=', '174', '-1_29_36_106_174', '1', '2', '0', '1', '0', null, '反射机制', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:19:46', '2017-08-04 13:19:56', '0'), ('191', 'wqLCtQA=', '106', '-1_29_36_106', '1', '2', '5', '0', '0', null, 'JVM', null, '0', null, '8', null, null, null, '1', null, '2017-08-04 13:20:27', '2017-08-04 13:20:41', '0'), ('192', 'wqLCtQM=', '191', '-1_29_36_106_191', '1', '2', '0', '1', '0', null, 'Java内存区域与内存溢出', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:20:43', '2017-08-04 13:21:06', '0'), ('193', 'wqLCtQI=', '191', '-1_29_36_106_191', '1', '2', '0', '1', '0', null, 'JVM', '', '0', null, '1', null, null, null, '1', null, '2017-08-04 13:21:26', '2017-08-04 13:21:42', '0'), ('194', 'wqLCtQU=', '191', '-1_29_36_106_191', '1', '2', '0', '1', '0', null, 'JVM类加载机制', '', '0', null, '1', null, null, null, '1', null, '2017-08-04 13:22:16', '2017-08-04 13:22:32', '0'), ('195', 'wqLCtQQ=', '191', '-1_29_36_106_191', '1', '2', '0', '1', '0', null, '垃圾回收算法', '', '0', null, '0', null, null, null, '1', null, '2017-08-04 13:22:41', '2017-08-04 13:22:53', '0'), ('196', 'wqLCtQc=', '106', '-1_29_36_106', '1', '2', '1', '0', '0', null, '数据库', null, '0', null, '4', null, null, null, '1', null, '2017-08-04 13:24:30', '2017-08-04 13:24:37', '0'), ('197', 'wqLCtQY=', '106', '-1_29_36_106', '1', '2', '1', '0', '0', null, 'Spring', null, '0', null, '2', null, null, null, '1', null, '2017-08-04 13:24:42', '2017-08-04 13:24:47', '0'), ('198', 'wqLCtQk=', '106', '-1_29_36_106', '1', '2', '4', '0', '0', null, '排序', null, '0', null, '4', null, null, null, '1', null, '2017-08-04 13:24:59', '2017-08-04 13:25:06', '0'), ('199', 'wqLCtQg=', '198', '-1_29_36_106_198', '1', '2', '0', '1', '0', null, '冒泡排序', '', '0', null, '1', null, null, null, '1', null, '2017-08-04 13:25:09', '2017-08-22 14:11:34', '0'), ('200', 'wqHCvAE=', '198', '-1_29_36_106_198', '1', '2', '0', '1', '0', null, '归并排序', '', '0', null, '2', null, null, null, '1', null, '2017-08-04 13:25:35', '2017-08-04 13:28:39', '0'), ('201', 'wqHCvAA=', '198', '-1_29_36_106_198', '1', '2', '0', '1', '0', null, '快速排序', '', '0', null, '2', null, null, null, '1', null, '2017-08-04 13:26:01', '2017-08-04 13:28:30', '0'), ('202', 'wqHCvAM=', '198', '-1_29_36_106_198', '1', '2', '0', '1', '0', null, '选择排序', '', '0', null, '2', null, null, null, '1', null, '2017-08-04 13:26:26', '2017-08-22 14:10:20', '0'), ('203', 'wqHCvAI=', '94', '-1_24_94', '1', '2', '0', '1', '0', null, 'mac文本编码转换', 'mac 文本 转码', '0', null, '0', null, null, null, '1', null, '2017-08-11 17:40:00', '2017-08-14 10:20:19', '0'), ('204', 'wqHCvAU=', '162', '-1_29_36_106_162', '1', '2', '0', '1', '0', null, 'java 模拟死锁', 'java 死锁', '0', null, '0', null, null, null, '1', null, '2017-08-22 11:51:24', '2017-08-22 19:12:02', '0'), ('205', 'wqHCvAQ=', '110', '-1_3_110', '1', '2', '0', '1', '0', null, 'HBase详解', 'HBase', '0', null, '0', null, null, null, '1', null, '2017-08-23 16:54:21', '2017-08-23 16:55:16', '0'), ('206', 'wqHCvAc=', '191', '-1_29_36_106_191', '1', '2', '0', '1', '0', null, 'JVM的工作原理，层次结构以及GC工作原理', 'JVM 工作原理 层次结构 GC', '0', null, '8', null, null, null, '1', null, '2017-08-25 11:11:05', '2017-08-25 12:03:58', '0'), ('207', 'wqHCvAY=', '-1', '-1', '1023', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-09-04 17:44:19', '2017-09-04 17:44:19', '0'), ('208', 'wqHCvAk=', '-1', '-1', '1', '2', '1', '0', '2', null, '自考', null, '0', null, '0', null, null, null, '1', null, '2017-09-05 13:35:56', '2017-09-05 13:36:12', '0'), ('209', 'wqHCvAg=', '208', '-1_208', '1', '2', '0', '1', '2', null, '中国近代史纲要(03708)', null, '0', null, '0', null, null, null, '1', null, '2017-09-05 13:36:14', '2017-09-11 13:23:06', '0'), ('210', 'wqHCvQE=', '96', '-1_95_96', '1', '2', '0', '1', '2', null, '爱上备份系统', null, '0', null, '0', null, null, null, '1', null, '2017-09-06 10:10:48', '2017-09-06 10:59:57', '0'), ('211', 'wqHCvQA=', '95', '-1_95', '1', '2', '7', '0', '2', null, '北京诸葛云游科技有限公司', null, '0', null, '0', null, null, null, '1', null, '2017-09-14 09:53:13', '2017-09-14 09:53:32', '0'), ('212', 'wqHCvQM=', '211', '-1_95_211', '1', '2', '0', '1', '2', null, '信息', '', '0', null, '0', null, null, null, '1', null, '2017-09-14 09:53:37', '2017-10-31 18:02:06', '0'), ('213', 'wqHCvQI=', '1', '-1_1', '1', '2', '0', '1', '1', '123', '面试题', '', '0', null, '0', null, null, null, '1', null, '2017-09-15 09:54:29', '2017-09-15 10:45:07', '0'), ('214', 'wqHCvQU=', '211', '-1_95_211', '1', '2', '0', '1', '2', null, '项目', '', '0', null, '0', null, null, null, '1', null, '2017-09-15 12:00:33', '2017-10-31 09:51:44', '0'), ('215', 'wqHCvQQ=', '211', '-1_95_211', '1', '2', '0', '1', '2', null, 'settings.xml', '', '0', null, '0', null, null, null, '1', null, '2017-09-15 12:03:47', '2017-09-15 12:04:03', '0'), ('216', 'wqHCvQc=', '3', '-1_3', '1', '2', '0', '1', '0', null, 'docker常用命令', '', '0', null, '0', null, null, null, '1', null, '2017-09-15 18:18:51', '2018-01-12 11:34:34', '0'), ('217', 'wqHCvQY=', '1', '-1_1', '1', '2', '0', '1', '2', null, '借钱记录', '', '0', null, '0', null, null, null, '1', null, '2017-09-18 14:07:28', '2017-09-22 11:33:25', '0'), ('218', 'wqHCvQk=', '3', '-1_3', '1', '2', '0', '1', '0', null, '常用压力测试工具', '', '0', null, '0', null, null, null, '1', null, '2017-09-18 15:03:36', '2017-09-18 15:05:01', '0'), ('220', 'wqHCvgE=', '211', '-1_95_211', '1', '2', '0', '0', '2', null, '常见错误', null, '0', null, '1', null, null, null, '1', null, '2017-09-22 16:01:04', '2018-02-07 11:36:01', '0'), ('221', 'wqHCvgA=', '253', '-1_95_211_253', '1', '2', '2', '0', '2', null, '东易日盛', null, '0', null, '0', null, null, null, '1', null, '2017-09-22 16:01:20', '2018-02-07 11:35:54', '0'), ('223', 'wqHCvgI=', '-1', '-1', '1018', '2', '3', '0', '0', null, '前端面试题', '', '0', null, '1', null, null, null, '1', null, '2017-09-27 10:40:36', '2017-09-27 10:41:09', '0'), ('224', 'wqHCvgU=', '223', '-1_223', '1018', '2', '0', '1', '2', null, '面试题1', '', '0', null, '0', null, null, null, '1', null, '2017-09-27 10:40:56', '2017-09-27 11:03:26', '0'), ('225', 'wqHCvgQ=', '223', '-1_223', '1018', '2', '0', '1', '2', null, '面试题2', '', '0', null, '0', null, null, null, '1', null, '2017-09-27 10:49:45', '2017-09-27 11:03:20', '0'), ('226', 'wqHCvgc=', '223', '-1_223', '1018', '2', '0', '1', '2', null, '面试题3', '', '0', null, '0', null, null, null, '1', null, '2017-09-27 10:56:00', '2017-09-27 11:03:31', '0'), ('228', 'wqHCvgk=', '211', '-1_95_211', '1', '2', '2', '0', '2', null, '文档', null, '0', null, '0', null, null, null, '1', null, '2017-10-25 11:05:19', '2017-10-25 11:05:26', '0'), ('229', 'wqHCvgg=', '221', '-1_95_211_253_221', '1', '2', '0', '1', '2', '', 'SEM（东易日盛）', '', '0', null, '1', null, null, null, '1', null, '2017-10-25 11:05:29', '2018-02-07 11:40:33', '0'), ('230', 'wqHCvwE=', '59', '-1_3_59', '1', '2', '0', '1', '0', null, 'tomcat压缩传输数据', '', '0', null, '0', null, null, null, '1', null, '2017-10-25 15:18:02', '2017-10-25 15:21:52', '0'), ('231', 'wqHCvwA=', '221', '-1_95_211_253_221', '1', '2', '0', '1', '2', null, '东易日盛相关帐号', '', '0', null, '0', null, null, null, '1', null, '2017-10-31 09:50:45', '2018-02-07 11:35:22', '0'), ('232', 'wqHCvwM=', '35', '-1_3_35', '1', '2', '0', '1', '0', null, 'iTerm2主题配置与常用技巧', '', '0', null, '11', null, null, null, '1', null, '2017-11-03 15:51:35', '2018-01-23 12:24:59', '0'), ('233', 'wqHCvwI=', '-1', '-1', '1024', '2', '1', '1', '2', '', '新笔记', '', '0', null, '0', null, null, null, '1', null, '2017-11-28 14:55:26', '2017-12-01 14:37:37', '0'), ('234', 'wqHCvwU=', '233', '-1_233', '1024', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2017-11-28 17:16:46', '2017-11-28 17:16:46', '0'), ('235', 'wqHCvwQ=', '150', '-1_150', '1', '2', '0', '1', '0', null, 'Sublime Text3（mac）', '', '0', null, '0', null, null, null, '1', null, '2017-11-30 11:51:51', '2017-11-30 11:56:33', '0'), ('236', 'wqHCvwc=', '10', '-1_3_10', '1', '2', '1', '0', '0', null, 'Impala', null, '0', null, '0', null, null, null, '1', null, '2017-12-18 11:03:52', '2017-12-18 11:04:01', '0'), ('237', 'wqHCvwY=', '236', '-1_3_10_236', '1', '2', '0', '1', '0', null, '常用sql', '', '0', null, '0', null, null, null, '1', null, '2017-12-18 11:04:05', '2018-02-01 16:07:14', '0'), ('240', 'wqHCuAE=', '211', '-1', '1', '2', '1', '0', '3', '', '接口', null, '0', null, '0', null, null, null, '1', null, '2017-12-26 17:16:38', '2018-04-02 10:46:43', '0'), ('241', 'wqHCuAA=', '254', '-1', '1', '2', '0', '1', '3', '', '0112-SaaS-微信订阅看板-后台接口列表', '', '0', null, '0', null, null, null, '1', null, '2017-12-26 17:17:37', '2018-04-02 10:46:56', '0'), ('242', 'wqHCuAM=', '35', '-1_3_35', '1', '2', '1', '0', '0', null, 'IDEA', null, '0', null, '0', null, null, null, '1', null, '2017-12-28 14:19:40', '2017-12-28 14:19:46', '0'), ('243', 'wqHCuAI=', '242', '-1_3_35_242', '1', '2', '0', '1', '0', null, '乱码', '', '0', null, '0', null, null, null, '1', null, '2017-12-28 14:19:51', '2017-12-28 14:20:53', '0'), ('244', 'wqHCuAU=', '253', '-1_95_211_253', '1', '2', '0', '1', '2', null, '新增表', '', '0', null, '0', null, null, null, '1', null, '2018-01-15 18:06:18', '2018-02-05 15:09:34', '0'), ('245', 'wqHCuAQ=', '150', '-1_150', '1', '2', '0', '0', '0', null, '新笔记', null, '0', null, '0', null, null, null, '1', null, '2018-01-17 20:56:28', '2018-01-17 20:56:28', '0'), ('246', 'wqHCuAc=', '247', '-1_29_36_247', '1', '2', '0', '1', '0', null, 'Kotlin + SpringBoot + JPA(Hibernate) + Repository自定义方法', '', '0', null, '0', null, null, null, '1', null, '2018-01-23 14:55:38', '2018-01-23 17:53:27', '0'), ('247', 'wqHCuAY=', '36', '-1_29_36', '1', '2', '1', '0', '0', null, 'Spring', null, '0', null, '0', null, null, null, '1', null, '2018-01-23 14:56:29', '2018-01-23 14:56:41', '0'), ('248', 'wqHCuAk=', '29', '-1_29', '1', '2', '1', '0', '0', null, '前端', null, '0', null, '0', null, null, null, '1', null, '2018-01-26 16:11:42', '2018-01-26 16:11:49', '0'), ('249', 'wqHCuAg=', '248', '-1_29_248', '1', '2', '0', '1', '0', null, 'mac + node.js + vue 搭建', '', '0', null, '0', null, null, null, '1', null, '2018-01-26 16:11:52', '2018-01-26 16:18:34', '0'), ('250', 'wqHCuQE=', '254', '-1', '1', '2', '0', '1', '3', '', '0129-SaaS-年终盘点-后台接口列表', '', '0', null, '0', null, null, null, '1', null, '2018-01-29 17:03:10', '2018-04-02 10:46:54', '0'), ('251', 'wqHCuQA=', '228', '-1_95_211_228', '1', '2', '0', '1', '2', null, '测试服务器发布脚本', '', '0', null, '0', null, null, null, '1', null, '2018-01-29 17:32:03', '2018-01-29 17:36:56', '0'), ('252', 'wqHCuQM=', '254', '-1', '1', '2', '0', '1', '3', '', '0131-SaaS-事件分组与事件星标-后台接口列表及相关', '', '0', null, '0', null, null, null, '1', null, '2018-01-31 15:39:07', '2018-04-02 10:46:52', '0'), ('253', 'wqHCuQI=', '211', '-1_95_211', '1', '2', '3', '0', '2', null, 'SEM', null, '0', null, '0', null, null, null, '1', null, '2018-01-31 15:48:43', '2018-01-31 15:48:51', '0'), ('254', 'wqHCuQU=', '240', '-1', '1', '2', '5', '0', '3', '', '2018', null, '0', null, '0', null, null, null, '1', null, '2018-01-31 16:11:27', '2018-04-02 10:46:46', '0'), ('255', 'wqHCuQQ=', '228', '-1_95_211_228', '1', '2', '2', '0', '2', null, '智能触达', null, '0', null, '0', null, null, null, '1', null, '2018-02-22 18:57:17', '2018-03-08 20:50:27', '0'), ('256', 'wqHCuQc=', '255', '-1_95_211_228_255', '1', '2', '0', '1', '2', null, '智能触达项目设计', '', '0', null, '0', null, null, null, '1', null, '2018-02-22 18:57:29', '2018-02-22 18:58:00', '0'), ('257', 'wqHCuQY=', '255', '-1_95_211_228_255', '1', '2', '0', '1', '2', null, '智能触达活动组件标准化草案', '', '0', null, '0', null, null, null, '1', null, '2018-02-22 18:58:23', '2018-02-22 18:58:37', '0'), ('258', 'wqHCuQk=', '253', '-1_95_211_253', '1', '2', '0', '1', '2', null, 'sem定时任务部署文档', '', '0', null, '0', null, null, null, '1', null, '2018-03-05 17:58:08', '2018-03-05 18:58:41', '0'), ('259', 'wqHCuQg=', '254', '-1', '1', '2', '0', '1', '3', '', '0315-智能触达-渠道配置-后台接口列表', '', '0', null, '0', null, null, null, '1', null, '2018-03-15 10:37:48', '2018-04-02 10:46:48', '0'), ('260', 'wqHCugE=', '254', '-1', '1', '2', '0', '1', '0', null, '0330-智能触达-前后端接口标准及响应code列表', '', '0', null, '0', null, null, null, '1', null, '2018-04-02 12:15:34', '2018-04-02 12:26:08', '0');
COMMIT;

-- ----------------------------
--  Table structure for `note_detail`
-- ----------------------------
DROP TABLE IF EXISTS `note_detail`;
CREATE TABLE `note_detail` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户id',
  `note_id` bigint(20) DEFAULT NULL COMMENT '笔记id',
  `content` mediumtext COMMENT '笔记内容',
  `type` int(2) DEFAULT '1' COMMENT '类型. 1普通笔记, 2Markdown',
  `sequence` int(11) DEFAULT NULL COMMENT '序号',
  `create_datetime` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `索引` (`note_id`)
) ENGINE=InnoDB AUTO_INCREMENT=165 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `note_detail`
-- ----------------------------
BEGIN;
INSERT INTO `note_detail` VALUES ('1', '1', '2', '【目录】\n\n[TOC]\n\nps: 简历更新于2017-06-01\n\n## 邹凡奇的个人简历\n\n### 基本信息\n\n|姓名|性别|出生年月|婚配|户籍||手机号|邮箱号|微信|\n|:-:|:-:|\n|邹凡奇|男|1993年1月|未婚|江西宜春||13552145052|vankizou@163.com|13552145052|\n\n|工作年限|工作性质|期望职业|期望行业|期望月薪|期望地区|目前状况|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|4年+|全职|JAVA大数据或相关|数据提供方、网络游戏、计算机软件等|面议|北京、深圳|待离职|\n> 本人希望能从事大数据或相关工作，也一直在利用空闲时间很努力的看相关资料。\n\n### 自我评价\n> 工作中我是一个严谨、细心且富有耐心的人。我虽然不是处女座，却有处女座的处事方式。对待代码哪怕一个缩进我都会严格要求自己。我有以下优点：\n>> - 随和：在公司人缘很不错，上通老大下识各部门同事\n>> - 细心：公司里的各类文档，绝大部分都是出自于本人\n>> - 严谨：代码坚持模块化，重用率高，bug出错率低\n>> - 接纳新技术强：公司半数以上技术都是本人负责研究部署，以及代码封装工作\n\n### 工作时间轴\n|时间|地点|描述|\n|:-|\n|13/05 - 14/01|北京金智飞科技有限公司|外派到中建一局做中建内部财务预算报销相关软件开发|\n|14/04 - 15/09|东方宇阳信息科技（北京）有限公司|主要是给中粮做物流台帐相关项目|\n|15/11 - 至今|北京联动在线通讯科技有限公司|主营自媒体项目|\n\n### 专业技能\n|||\n|-:|\n|用过的java web框架|spring、spring mvc、mybatis、hibernate、structs2等|\n|用过的前端框架|jquery、bootstrap等|\n|用过的中间件|tomcat、nginx|\n|用过的linux版本|redhat、ubuntu、debian、centos|\n|用过的IDE|webstrom、HBuilder、eclipse、myeclipse、intellij idea|\n|用过的数据库|sql server、oracle、postgreSQL、[mysql](http://www.qiqinote.com/note/14.html)、[mongodb](http://www.qiqinote.com/note/12.html)|\n|用过的消息推送|[rabbitmq](http://www.qiqinote.com/note/54.html)、[activemq](http://www.qiqinote.com/note/5.html)|\n|用过的缓存与搜索服务|[redis](http://www.qiqinote.com/note/18.html)、[elasticsearch](http://www.qiqinote.com/note/6.html)|\n|用过的图片处理服务|[ImageMagick](http://www.qiqinote.com/note/9.html)|\n|用过的分布式文件系统|[GlusterFS](http://www.qiqinote.com/note/28.html)|\n|熟悉相关大数据技术|[Hadoop](http://www.qiqinote.com/note/112.html)、Hive、[HBase](http://www.qiqinote.com/note/140.html)、Spark、[Flume](http://www.qiqinote.com/note/136.html)、[Kafka](http://www.qiqinote.com/note/135.html)|\n||其他等等...|\n\n### 项目经验\n#### *时装网*\n> 项目简介\n>> \n```\n	时装网服务于法国时装L\'OFFICIEL，定期更新最新时装杂志内容。主要是为用户提供一个获取最新时装信息的展示平台。包括用户：PC、安卓、IOS\n	项目之前有一个早期版本，因维护成本问题，所以对其进行重构。重构包括：后端架构变动，后端所有接口全部重写，PC版页面重新设计，Android+ios部分业务变更。\n```\n>\n> 基本信息\n>> \n|开发周期|人员分配|维护时间|PC访问链接|\n|:-:\n|16.3 - 16.10|后台1人+前端3人+安卓1人+IOS1人|16年9月-至今|<a href=\"http://www.lofficiel.cn\" target=\"_blank\">http://www.lofficiel.cn</a>|\n>>\n||\n|:\n|开发环境|mac os 或 windows\n|部署环境|centos7 + jdk1.7 + tomcat7 + nginx1.10\n|开发工具|IDEA 或 eclipse + git + maven\n|软件技术|mysql5.6 主从 + mongodb3.2.9 集群 + redis3.2.4 主从 + activemq5.14 集群 + elasticsearch2.4.0 集群 + ImageMagick7 等...\n|程序框架|springmvc4.1.2 + mybatis3.2.4 + mybatis自动生成Mapper\n>\n> 主要业务\n>> - 用户默认拥有观看各版块信息的权限，由于文章质量要求很高，所以默认用户并没有编辑权限\n>> - 编辑人员分配编辑权限，可操作其它版块信息，如：街拍，文章等\n>> - 网站设置一定数量的广告位，可对广告位设置时间，下架，上架等操作\n>> - 网站所有图片根据不同版块按需加载不同质量的图片\n>> - 网站提供全局搜索功能\n>> - 其它有评论模块、对话模块、个人中心、空间动态等业务需求\n>\n> 工作描述\n>> \n```\n	本人担任项目组长，负责整个后端以及与前端组和移动组业务对接工作。\n```\n>> 主要工作内容有：\n>>> - 与设计、产品对接业务需求\n>>> - 与项目经理服务器架构、后台技术选型和表结构设计\n>>> - 负责整个项目所有模块接口实现\n>>> - 负责整个项目所有服务器部署，各集群的搭建、调试、文档编写等\n>>> - 负责项目上线，后期维护等工作\n>>> - 项目经历过一次与其它项目的合并，合并之前表大概有50余张；合并后表超过120张（含部分日志表）\n>>> - 重构主要工作都在PC与后台。IOS与安卓涉及到修改的地方相对较少\n\n#### *爱上微杂志*\n> 项目简介\n>> \n```\n	项目主要给用户提供一个杂志发布平台，是适用于各个行业、不同职业、不同年龄人群的一个杂志分享平台。主营安卓与IOS手机APP，但也提供PC操作。\n	项目涉及多方面，包括：直播、商城、微杂志、话题、私信、微拍等。\n```\n>\n> 基本信息\n>> \n|开发周期|人员分配|PC访问链接|\n|:-:\n|15.12 - 至今|后端4人+安卓4人+IOS3人+前端3人|<a href=\"http://www.love.tv\" target=\"_blank\">http://www.love.tv</a>|\n>>\n||\n|:\n|开发环境|mac os 或 windows\n|部署环境|centos7 + jdk1.7 + tomcat7 + nginx1.10\n|开发工具|IDEA 或 eclipse + git + maven\n|软件技术|LVS 主从 + keepalived 主从 + mysql5.6 主从 + mongodb3.2.9 集群 + redis3.2.4 主从 + activemq5.14 集群 + elasticsearch5.3.2 集群 等...\n|后端框架|springmvc4.1.2 + mybatis3.2.4 + mybatis自动生成Mapper\n|前端框架|nodejs + angularJS + koa\n>\n> 主要业务\n>> - 项目成立最初主营业务是直播，同一时间嵌入的业务还有私信以及与资金相关的微信、支付宝业务的对接\n>> - 因为公司最早做过几个和电商相关的项目，所以中间添加了商场业务\n>> - 后期主线业务变更为微杂志，先后推出业务：微杂志、话题、私信改版、微拍等\n>\n> 工作描述\n>> \n```\n本人负责后端，但公司多项目并行开发，所以中期调至时装项目组。但前期准备工作与时装网结束后，都先后参与到该项目的整体实现。主要工作内容有：\n```\n>>> - 参与前期业务需求讨论\n>>> - 参与各业务的表结构构建\n>>> - 参与项目技术选型与搭建\n>>> - 负责撰写各类技术文档\n>>> - 负责私信业务版块及代码实现\n>>> - 负责搜索业务及代码实现\n>>> - 参与其它业务部分接口代码实现\n>>> - 负责监控系统的实现，如zabbix监控、短信监控、数据库异常监控、资金异常监控、页面异常监控 等...\n>>> - 负责整个系统数据备份工作\n>>> - 负责外网、内网备份系统的搭建\n\n#### *奇奇笔记*\n> 项目简介\n>> \n```\n	该项目是本人利用空闲时间编写的一个笔记网站。\n	主要是记录笔记，全网采用Markdown格式。支持密码访问，私密笔记，导出笔记等功能。\n```\n>\n> 后期方向\n>> \n```\n	该网站主线是记录笔记，后面将陆续推出评论模块、留言互动模块、共享问答模块、在线工具等。\n```\n>\n> 基本信息\n>> \n|开发周期|人员分配|PC访问链接|\n|:-:\n|17.4 - 至今|1人|<a href=\"http://www.zoufanqi.com\" target=\"_blank\">http://www.zoufanqi.com</a> 或 <a href=\"http://www.qiqinote.com\" target=\"_blank\">http://www.qiqinote.com</a>|\n>>\n||\n|:\n|开发环境|mac os\n|部署环境|centos7 + jdk1.7 + tomcat7 + nginx1.10\n|开发工具|IDEA + git + maven + ImageMagick\n|软件技术|mysql5.6 + redis3.9 等...\n|框架技术|springmvc4.1.2 + mybatis3.2.4 + mybatis自动生成Mapper\n\n### 教育经历\n> 2010/09 - 2013/06 - 江西信息应用职业学院 | 软件开发 | 大专', '2', '0', '2017-06-15 14:32:11'), ('2', '1', '5', '## centos-ActiveMQ集群配置\n\n[TOC]\n\nps: 撰写文档时间为：2016-10-24，以下涉及到的版本可适时斟酌。\n\n#### 序\n> 软硬件配置：\n>> 1. 系统版本：CentOS Linux release 7.1.1503 (Core)\n>> 2. java版本：1.7.0_79\n>> 3. activemq版本：5.14.1(需jdk1.7及以上)\n>> 4. 主从配置服务器设置\n```xml\n10.10.10.1(主)\n10.10.10.2(从)\n10.10.10.3(从)\n```\n>> 4. zookeeper集群，**本集群配置依赖zookeeper集群**. 具体配置请参数zookeeper集群配置\n\n#### 1. 安装activemq\n```shell\n# wget https://mirrors.tuna.tsinghua.edu.cn/apache//activemq/5.14.1/apache-activemq-5.14.1-bin.tar.gz\n# tar -zxvf apache-activemq-5.14.1-bin.tar.gz\n# mv apache-activemq-5.14.1 /usr/local/\n```\n官网安装链接：http://activemq.apache.org/getting-started.html\n\n#### 2. 配置\n> 1. 修改activemq.xml配置文件\n```xml\n# vi /usr/local/apache-activemq-5.14.1/conf/activemq.xml\n```\n>> 修改 \"默认配置\" 为 \"修改后的配置\"\n>>> 默认配置\n```xml\n<persistenceAdapter>\n	<kahaDB directory=\"${activemq.data}/kahadb\"/>\n</persistenceAdapter>\n```\n>>> 修改后的配置\n```xml\n<persistenceAdapter>\n    <replicatedLevelDB\n      directory=\"/data/activemq/leveldb\"\n      replicas=\"3\"\n      bind=\"tcp://0.0.0.0:0\"\n      zkAddress=\"10.10.10.1:2181,10.10.10.2:2181,10.10.10.3:2181\"\n      hostname=\"10.10.10.1\"\n      sync=\"local_disk\"\n      zkPath=\"/data/activemq/leveldb-stores\"\n      />\n</persistenceAdapter>\n```\n>>>> ps:\n>>>> 1. `persistenceAdapter`的父节点`broker`中属性`brokerName`值集群中的服务器配置必须一致\n>>>> 2. 本文档集群配置的ActiveMQ持久化方式为`LevelDB`\n>>>>> ActiveMQ持久化方式有：`AMQ`, `KahaDB(默认)`, `JDBC`, `LevelDB`\n>>>> 3. 属性详解：\n>>>>> \n```\ndirectory: 数据文件的存储目录\nreplicas: 节点数量，最少存活节点数 (replicas / 2) + 1\nzkAddress: zookeeper集群，2181端口号对应zoo.cfg配置文件中的clientPort\nhostname: 本机IP\n```\n>>>>\n>>>> 官方LevelDB配置链接：http://activemq.apache.org/replicated-leveldb-store.html\n>\n> 2. 修改监控用户密码（可以不做）\n>> \n```\n# vi /usr/local/apache-activemq-5.14.1/conf/jetty-realm.properties\n```\n>> 默认配置\n```xml\n# username: password [,rolename ...]\nadmin: admin, admin\nuser: user, user\n```\n>> 冒号后面的为密码，改成自己的密码即可！\n>\n> 3. 启动\n>> \n```\n# bin/activemq start\n```\n\n#### 附\n> 浏览器查看消息信息\n>> http://10.10.10.1:8161/\n>>> `10.10.10.1`为主节点IP\n>>> `8161`端口号在`jetty.xml`中的`jettyPort`配置.', '2', '0', '2017-06-15 14:32:14'), ('3', '1', '6', '## centos-elasticsearch集群配置\n\n[TOC]\n\nps: 撰写文档时间为：2016-10-24，以下涉及到的版本可适时斟酌。\n\n#### 序\n> 软硬件配置：\n>> 1. 系统版本：CentOS Linux release 7.1.1503 (Core)\n>> 2. java版本：1.7.0_79\n>> 3. elasticsearch版本：2.4.0（需jdk1.7版本及以上）\n>> 4. 集群服务器\n```xml\n10.10.10.1\n10.10.10.2\n10.10.10.3\n```\n\n#### 1. 安装es\n> 1. 官网下载最新版: https://www.elastic.co/downloads/elasticsearch\n>> \\# wget https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/tar/elasticsearch/2.4.0/elasticsearch-2.4.0.tar.gz\n\\# tar -zxvf elasticsearch-2.4.0.tar.gz\n\\# mv elasticsearch-2.4.0 /usr/local/\n>\n> 2. 安装head(一款H5的数据查看客户端)\n>> \\# /use/local/elasticsearch/bin/plugin install mobz/elasticsearch-head\n完成后在浏览器输入(需先启动)：http://IP地址:9200/_plugin/head/\n>>> ps: 若http.port端口号改了，上面的端口得对应\n>\n> 3. 安装ik(中文分词)\n>> a. 登录ik的github\n>>> https://github.com/medcl/elasticsearch-analysis-ik\n>>\n>> b. 找到安装es的对应ik版本并下载zip包\n>>> ps: ik版本与es版本一定要对应，否则会无效\n>>\n>> c. 解压zip，用mvn打包（找个有maven环境的电脑打包即可）\n>>> \\# mvn install -DskipTests\n>>\n>> d. 将刚生成的\"target/realease/elasticsearch-analysis-ik-1.10.0.zip\" 文件拷到服务器中。存放的目录为：es安装目录/plugin/\n>> e. 创建目录存放zip文件中的内容\n>>> \\# mkdir /usr/local/elasticsearch-2.4.0/plugin/ik\n>>> 将ik的zip包解压，将里面的内容拷到ik目录\n>>\n>> f. 编辑elasticsearch.yml文件\n>>> \\# vi /usr/local/elasticsearch-2.4.0/config/elasticsearch.yml\n>>> 在最后面添加\n>>>> index.analysis.analyzer.ik.type: \"ik\"\n>>\n>> 启动，不报错，成功安装\n\n#### 2. 配置集群\n> 1. 创建es用户\n>> \\# adduser elasticsearch\n>>> ps: es不允许root启动，所以创建elasticsearch用户\n>\n> 2. 创建es存储目录和日志目录，并从属elasticsearch用户下\n>> \\# mkdir -p /data/elasticsearch/data\n\\# mkdir -p /data/elasticsearch/logs\n\\# chown -R elasticsearch:elasticsearch /data/elasticsearch\n\\# chown -R elasticsearch:elasticsearch /usr/local/elasticsearch-2.4.0/\n>\n> 3. 编辑es配置文件，修改以下配置\n>> \\# vi /usr/local/elasticsearch-2.4.0/conf/elasticsearch.yml\n```properties\ncluster.name: lofficiel-cluster		# 各节点必须一致\nnode.name: \"node-164\"				# 各节点必须唯一\npath.data: /data/elasticsearch/data	# 数据目录\npath.logs: /data/elasticsearch/logs	# 日志目录\nnetwork.host: 10.10.10.1		# 对应该节点IP\nhttp.port: 9222 				# 设置对外服务的http端口号，默认9200\ntransport.tcp.port: 9333 		# 设置节点之间交互的端口号，默认9300\ntransport.tcp.compress: true 	#设置是否压缩tcp上交互传输的数据，默认false\ndiscovery.zen.ping.unicast.hosts: [\"10.10.10.11\", \"10.10.10.2\", \"10.10.10.3\"]\n```\n>> ps: 冒号后面必须要接一个空格，否则报错！\n>\n> 4. 启动测试(依次每个节点启动)\n>> \\# su - elasticsearch\n>> \\# /usr/local/elasticsearch-2.4.0/bin/elasticsearch\n>>\n>> 启动成功后，可以看到打印信息，没有错误，可以看到master,slave等信息。或登录head查看节点\n>>\n>> 后台启动用\n>>> \\# /usr/local/elasticsearch-2.4.0/bin/elasticsearch -d', '2', '0', '2017-06-15 14:32:17'), ('4', '1', '9', '## centos-ImageMagick安装与调试\n\n[TOC]\n\nps: 撰写文档时间为：2016-10-24，以下涉及到的版本可适时斟酌。\n\n#### 序\n> 软硬件配置：\n>> 1. 系统版本：CentOS Linux release 7.1.1503 (Core)\n>> 2. ImageMagick版本：7.0.3-4 Q16 x86_64\n>\n> 项目涉及到的操作\n>> 1. 缩放图片，支持类型：jpg, jpeg, png, gif\n>> 2. 裁剪图片，支持类型：jpg, jpeg, png, gif\n\n#### 安装方法一\n\n\n#### 安装方法二\n> 1. 添加依赖\n>> \n```\n# yum install gtk2 OpenEXR-libs gdk-pixbuf2 ghostscript ghostscript-fonts ilmbase libwmf libwmf-lite urw-fonts xorg-x11-font-utils glib2\n```\n>>\n```\n# yum install libjpeg libjpeg-devel libpng libpng-devel giflib giflib-devel gd-devel\n```\n>\n> 2. git下载源码包：http://git.imagemagick.org/repos/ImageMagick\n> 3. 解压源码包，进入解压文件夹，执行命令\n>> \n```\n./configure --prefix=/usr/local/ImageMagick7.0.3-4 --enable-shared --enable-static --without-perl\n```\n>>\n>> \n```\n# make && make install\n```\n>\n> 4. 添加环境变量\n>> 1. `# vi /etc/profile`\n>> 2. profile文件中添加\n>>> \n```\nIMAGEMAGICK=/usr/local/ImageMagick7.0.3-4/bin\nPATH=$PATH:$IMAGEMAGICK\nexport IMAGEMAGICK\nexport PATH\n```\n>> 3. `# source /etc/profile`\n\n#### 测试\n##### 查看版本\n```\n# convert -version\n```\n##### 测试图片\n> 1. 添加需要操作的图片类型到服务器\n> 2. 缩放图片，执行命令\n>> `# convert -resize 100x100 jpg.jpg jpg_2.jpg`\n>>> 100x100：需要缩放的尺寸\n>>> jpg.jpg：原图\n>>> jpg_2.jpg：缩放后的图片\n>\n> 3. 裁剪图片，执行命令\n>> `# convert jpg.jpg -crop 100x100+10+10 jpg_3.jpg`\n>>> 100x100+10+10：两个10为x轴原点的坐标，100x100为裁剪尺寸\n>>> jpg.jpg：原图\n>>> jpg_3.jpg：裁剪后的图片', '2', '0', '2017-06-15 14:32:20'), ('5', '1', '12', '## centos-mongodb集群（副本集）配置\n\n[TOC]\n\nps: 撰写文档时间为：2016-10-24，以下涉及到的版本可适时斟酌。\n\n#### 序\n> 软件硬件配置\n>> 1. 系统版本：CentOS Linux release 7.1.1503 (Core)\n>> 2. mongodb版本：3.2.9\n>> 3. 集群服务器设置\n>>> 1.1.1.1(仲裁者)\n>>> 1.1.1.2(优先级：1)\n>>> 1.1.1.3(优先级：2)\n\n#### 1. 安装mongodb(yum安装)\n> 1. 在yum repo文件夹下新建mongodb版本配置文件（3.2版本配置）\n>> \n```\n# vi /etc/yum.repos.d/mongodb-org-3.2.repo\n```\n> 2. 添加文件内容\n>> \n```\n[mongodb-org-3.2]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.2/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-3.2.asc\n```\n> 3. 安装mongodb\n>> \n```\n# yum install -y mongodb-org\n```\n> 4. 设置开机启动(如果是配置集群则不能设置)\n>> \n```\n# chkconfig mongod on\n```\n>\n>> ps: yum详细安装步骤请参考：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\n>\n> 安装完毕！\n> 文件目录\n>> 配置文件：/etc/mongod.conf\n>> 数据文件：/var/lib/mongo\n>> 日志文件：/var/log/mongodb\n>\n> mongodb服务\n>> 启动\n>>> \n```\n# service mongod start\n```\n>>\n>> 停止\n>>> \n```\n# service mongod stop\n```\n>>\n>> 重启\n>>> \n```\n# service mongod restart\n```\n>\n> 测试是否成功\n>> 启动mongodb服务\n>>> \n```\n# service mongod start\n```\n>>\n>> 连接mongodb\n>>> \n```\n# mongo\n```\n\n#### 2. 开始搭建副本集\n> 1. 分别在每台机器上建立副本集文件夹\n>> \n```shell\n# mkdir -p /data/mongodb/replset		# 存放整个mongodb文件\n# mkdir -p /data/mongodb/replset/data	# 存放mongodb数据文件\n# mkdir -p /data/mongodb/replset/log	# 存放mongodb数据文件\n```\n>\n> 2. 分别在每台机器上启动mongod\n> ps: 需先确定所有mongod服务关闭, 用: ps -ef | grep mongod 检测\n>> \n```\n# sudo mongod --replSet replset --fork --dbpath=/data/mongodb/replset/data --logpath=/data/mongodb/replset/log/mongo.log --logappend\n```\n>>> ps: 可配置成shell脚本，方便日后启动\n>>>> \n```\n#!/bin/sh\nsudo mongod --directoryperdb --replSet replset --fork --dbpath=/data/mongodb/replset/data --logpath=/data/mongodb/replset/log/mongo.log --logappend\n```\n>\n> 3. 随便登录哪台机器\n> ps: 修改配置需登录主服务器\n>> a. 进入mongo\n>>> \n```\n# mongo\n```\n>>\n>> b. 执行配置\n>>> \n```\nmongo$ config={_id:\"replset\",members:[\n{_id:0,host:\"1.1.1.1:27017\",priority:1},\n{_id:2,host:\"1.1.1.2:27017\",priority:2},\n{_id:1,host:\"1.1.1.3:27017\", arbiterOnly: true}]}\n```\n>>>> `replset`需与`2.2`节的启动mongod时的`--replSet`参数值对应\n>>>> arbiterOnly: 该服务器只用作选举，不作数据备份等操作。一个集群需要至少一个选举，否则主服务器挂了后就不会选举出新的主服务器\n>>\n>> c. 初始化配置\n>>> \n```\nmongo$ rs.initiate(config);\n```\n>>>> ps: `rs.help();` --> 查看rs所有函数\n>>\n>> d. 查看配置信息\n>>> \n```\nmongo$ rs.status();\n```\n>>>> ps: `rs.help();` --> 查看更多\n>\n> 完成配置！', '2', '0', '2017-06-15 14:32:23'), ('6', '1', '14', '## centos-mysql主从配置\n\n[TOC]\n\nps: 撰写文档时间为：2016-10-24，以下涉及到的版本可适时斟酌。\n\n#### 序：\n> 软硬件配置：\n>> 1. 系统版本：CentOS Linux release 7.1.1503 (Core)\n>> 2. mysql版本：5.6.33 MySQL Community Server (GPL)\n>> 3. 主从配置服务器设置\n>>> 1.1.1.1(主)\n>>> 1.1.1.2(从)\n>>> 1.1.1.3(从)\n>\n> 主从利处\n>> 利用MySQL的主从配置，可以实现读写分离，减轻主数据库的访问压力，提升网站性能\n>\n> 主从描述\n>> 从服务器的IO线程从主服务器获取二进制日志，并在本地保存为中继日志，然后通过SQL线程来在从上执行中继日志中的内容，从而使从库和主库保持一致。主从同步的详细过程如下：\n>>> 1. 主服务器验证连接。\n2. 主服务器为从服务器开启一个线程。\n3. 从服务器将主服务器日志的偏移位告诉主服务器。\n4. 主服务器检查该值是否小于当前二进制日志偏移位。\n5. 如果小于，则通知从服务器来取数据。\n6. 从服务器持续从主服务器取数据，直至取完，这时，从服务器线程进入睡眠，主服务器线程同时进入睡眠。\n7. 当主服务器有更新时，主服务器线程被激活，并将二进制日志推送给从服务器，并通知从服务器线程进入工作状态。\n8. 从服务器SQL线程执行二进制日志，随后进入睡眠状态。\n\n#### 1. 安装mysql(yum安装)\n> 1. 安装mysql的yum支持资源配置\n>> $ rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\n> 2. 查看yum资源中是否包涵mysql\n>> \n```\n# yum repolist all | grep mysql\n```\n>> \n```\n# yum repolist enabled | grep mysql\n```\n> 3. 安装mysql\n>> \n```\n# yum install mysql-community-server\n```\n> 4. 开机自动启动\n>> \n```\n$ /usr/bin/systemctl enable mysqld\n```\n> 5. 启动mysql服务\n>> \n```\n# /usr/bin/systemctl start mysqld\n```\n>> 或\n>> \n```\n# service mysql start\n```\n> 6. 设置密码\n>> \n```\n# /usr/bin/mysql_secure_installation\n```\n\n#### 2. 配置主服务器\n> 1. 主服务器新建一个用户赋予“REPLICATION SLAVE”的权限\n>> a. 设置一个复制使用的帐户，并授予权限\n>>> \n```\nmysql> GRANT REPLICATION SLAVE ON \\*.* TO \'repl\'@\'1.1.1.%\' IDENTIFIED BY \'123\';\n```\n>>>> 中间有做对该帐户信息的更新操作不起作用时刷新命令：\n>>>>> \n```\nmysql> flush privileges;\n```\n>>\n>> ps1: repl(用户)，1.1.1.%(从服务器)，123(密码)\n>> ps2: \"REPLICATION SLAVE\"的权限，它是服务器管理中的复制权限，有这个权限slave才能从master服务器上复制binlog日志。所以我们需要创建一个数据库用户，并给他赋予replication权限\n> 2. 修改my.cnf配置\n>> a. 打开编辑my.cnf文件\n>>> \n```\n# vi /etc/my.cnf\n```\n>>>> 可能文件路径会不一样，用命令：find / -name my.cnf 查找一下\n>>\n>> b. 在\"[mysqld] -> # log_bin\" 下加上配置：\n```\nserver-id=164\nlog-bin=master-bin\nlog-bin-index=master-bin.index\n```\n>>> ps: 164可以随便写，只要唯一即可\n\n>>\n>> c. 重启mysql服务\n>>> \n```\n# service mysql restart\n```\n> 3. 导出数据库\n>> \n```\n# mysqldump -u root -p123456 --all-databases  --lock-tables=false > ~/temp/all.sql\n```\n>>> 若数据库数据量大，中间可能会有数据操作，可设置读锁定，详细见 （配置从服务器中第3节）\n> 4. 将all.sql移到从服务器中\n\n#### 3. 配置从服务器\n> 1. 主服务器数据库数据备份到从库\n>> $ mysql -uroot -p < all.sql\n> 2. 修改my.cnf文件(与主服务器修改配置地方一致)\n>> server-id=165\n>> relay-log-index=slave-relay-bin.index\n>> relay-log=slave-relay-bin\n> 3. 重启mysql服务\n> 4. 登录主服务器mysql,查询主服务器当前二进制日志名和偏移值\n>> a. 设置读锁定有效，确保没有数据库操作，以便获得一致性的快照\n>>> mysql> flush tables with read lock;\n>>\n>> b. 查询主服务器当前二进制日志名和偏移值\n>>> mysql> show master status;\n>>>> File: 二进制日志名，如mysql-bin.000003\n>>>> Position: 偏移值，如1307\n>>\n>> c. 解除读锁定\n>>> mysql> unlock tables;\n> 5. 登录从服务器mysql，连接Master\n>> a. mysql> change master to master_host=\'106.3.138.164\',master_port=3306,master_user=\'repl\',master_password=\'123\',master_log_file=\'master-bin.000003\',master_log_pos=1307;\n>>> master_host: 主服务器IP\n>>> master_port: 主服务器mysql端口号\n>>> master_user: 主服务器mysql新增的有\"REPLICATION SLAVE\"权限的帐户\n>>> master_password: 对应帐户的密码\n>>> master_log_file: 当前二进制日志名\n>>> master_log_pos: 当前偏移值\n>>\n>> b. 启动从服务器\n>>> mysql> start slave;\n>>>> 关闭用：mysql> stop slave;\n> 6. 检测\n>> a. 从服务器mysql输入：\n>>> mysql> show slave status\\G;\n>>>> 若 Slave_IO_Running 和 Slave_SQL_Running 两项都为Yes，则表示成功\n>>\n>> b. 查看mysqld日志文件有无错误信息\n>>> $ tailf /var/log/mysqld.log\n>>>> 参考: 若有连接超时错误信息，可查看防火墙\n\n#### 4. 添加访问用户\n> I. `# mysql -uroot -p -> 输入密码进入mysql`\n> II. `mysql> grant all on \\*.* to 用户名@\'1.1.1.%\' identified by \'密码\';`\n>> 给1.1.1.* 网段的设置权限为<所有（增删改查）>权限，用户/密码\n>> 主服务器需要所有权限，但从服务器切忌给所有权限。因为从服务器修改数据，不会同步到主服务器\n>\n> II.` mysql> grant select on \\*.* to 用户名@\'1.1.1.%\' identified by \'密码\';`\n>> 给1.1.1.* 网段的设置权限为<查询>权限，用户/密码\n>> 主服务器需要所有权限，但从服务器切忌给所有权限。因为从服务器修改数据，不会同步到主服务器\n>\n> III. 刷新\n>> \n```\nmysql> flush privileges;\n```\n\n#### 更新密码\n> I. \n```\n# mysql -uroot -p 		# 输入密码进入mysql\n```\n> II. 修改密码\n```\nmysql> use mysql;\nmysql> update user set Password=PASSWORD(\'zd252!@#aa\') WHERE host=\'47.88.0.87\'; -- 这是一句sql语句，条件可以自己加。具体信息可用select语句查看\nmysql> flush privileges;\n```\n\n#### my.cnf配置参考\n```shell\n[client]\nport=3306\nsocket=/data/mysql_data/mysql.sock\n\n[mysqld]\nport=3306\ndatadir=/data/mysql_data\nsocket=/data/mysql_data/mysql.sock\nuser=mysql\nkey_buffer=4096M\nmax_allowed_packet=8M\n#table_cache = 2048\nsort_buffer_size=2M\nread_buffer_size=2M\njoin_buffer_size=3M\nread_rnd_buffer_size=8M\nmyisam_sort_buffer_size=64M\nthread_cache_size=16\nquery_cache_type=0\nquery_cache_size=512M\nthread_concurrency=8\n\ntmp_table_size=1024M\nmax_heap_table_size=1024M\nlog-queries-not-using-indexes\n\nexpire_logs_days=90\nskip-name-resolve\n#slave_skip_error=1062\nslow_query_log=1\nslow-query-log-file=/data/mysql_data/slow_query.log\nlong_query_time=1\nmax_connections=300\n\n#auto_increment_increment=2\n#auto_increment_offset=1\nconcurrent_insert=2\nsync_binlog=1\nback_log=500\ncharacter-set-server=utf8mb4\n\nsymbolic-links=0\n\n#log-slave-updates\n\ninnodb_file_per_table = 1\n\n#innodb_data_home_dir=/usr/local/mysql/var/\n#innodb_data_file_path=ibdata1:1000M;ibdata2:10M;ibdata3:10M:autoextend\n#innodb_log_group_home_dir=/usr/local/mysql/var/\n\ninnodb_buffer_pool_size = 24576M\n#innodb_additional_mem_pool_size=20M\n\n#innodb_log_file_size=100M\n#innodb_log_buffer_size=8M\n#innodb_flush_log_at_trx_commit=0\n#innodb_lock_wait_timeout=120\n\n[mysqldump]\nquick\nmax_allowed_packet=16M\n\n[mysql]\nno-auto-rehash\n\n[isamchk]\nkey_buffer=256M\nsort_buffer_size=256M\nread_buffer=2M\nwrite_buffer=2M\n\n[myisamchk]\nkey_buffer=256M\nsort_buffer_size=256M\nread_buffer=2M\nwrite_buffer=2M\n\n[mysqlhotcopy]\ninteractive-timeout\n\n[mysqld_safe]\nlog-error=/data/mysql_data/mysqld.log\npid-file=/data/mysql_data/mysqld.pid\n```', '2', '0', '2017-06-15 14:32:26'), ('7', '1', '16', '## centos-redis-sentinel实现HA\n\n[TOC]\n\nps: 撰写文档时间为：2017-03-27，以下涉及到的版本可适时斟酌。\n\n### 序:\n> 软硬件配置：\n>> 1. 系统版本：CentOS Linux release 7.1.1503 (Core)\n>> 2. redis版本：3.2.4\n>> 3. 依赖redis主从, 即必须先配置好主从\n\n### 1. 主从配置\n> 1. sentinel依赖主从配置.\n> 2. 若主从配置了密码, 则确保所有redis.conf配置中的masterauth都配置了相同密码.\n> 因为配置sentinel后, 从节点也可能成为主节点. 以便从节点成为主节点后, 之前的主节点重新上线后加入不了主从配置中\n\n### 2. 配置sentinel\n> sentinel详细信息:\n>> sentinel详细介绍: http://redis.majunwei.com/topics/sentinel.html\n>> sentinel参数配置: http://doc.redisfans.com/topic/sentinel.html\n>\n> 1. 配置: 假如配置哨兵数为3, 则有以下配置三份(存放于不同服务器)\n>> \n```python\n# 哨兵端口\nport 63791\n# 是否后台\ndaemonize yes\n# 日志路径\nlogfile \"/data/log/redis/sentinel.log\"\n# mymaster(哨兵名称, 需一致); 主节点IP; 主节点对应端口; 哨兵通报主节点主观挂后变为客观挂数量, 若该数量超过哨兵数, 则主从永远不会进行故障转移\nsentinel monitor mymaster 127.0.0.1 6379 2\n# 主从配置的密码. 若没有, 该行可省略; 若有, 则该行必须\nsentinel auth-pass mymaster zoufanqi\n# ping主节点的间隔时间(毫秒)\nsentinel down-after-milliseconds mymaster 60000\n# failover（提升一个slave成为master）过期时间,如果超过这个时间没触发成功failover,sentinel会认为failover失败\nsentinel failover-timeout mymaster 1800000\n# 主故障后, 重新配置的主从中的从节点数量\nsentinel parallel-syncs mymaster 1\n```\n>\n> 2. 启动哨兵\n> ps: 先启动主从, 再依次启动哨兵\n>> $ redis-sentinel /path/to/sentinel.conf\n>> 或\n>> $ redis-server /path/to/sentinel.conf\n>\n> 3. 查看哨兵信息:\n>> $ redis-cli -p 63791 info sentinel\n>>> master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=1,sentinels=3\n>>> slaves: 从数量; sentinels: 哨兵数量\n\n### 3. spring创建jedis\nps: 测试的只会操作主节点\n1. pom.xml\n```xml\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>${jedis.version}</version>\n</dependency>\n```\n\n2. spring配置\n> \n```xml\n<bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\">\n        <property name=\"maxTotal\" value=\"${redis.maxTotal}\"/>\n        <property name=\"maxIdle\" value=\"${redis.maxIdle}\"/>\n        <property name=\"minIdle\" value=\"${redis.minIdle}\"/>\n        <property name=\"maxWaitMillis\" value=\"${redis.maxWaitMillis}\"/>\n        <property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\"/>\n        <property name=\"testOnReturn\" value=\"${redis.testOnReturn}\"/>\n        <property name=\"testWhileIdle\" value=\"${redis.testWhileIdle}\"/>\n</bean>\n<!-- 配置sentinel哨兵 -->\n<bean id=\"redisSentinel\" class=\"redis.clients.jedis.JedisSentinelPool\">\n    <constructor-arg index=\"0\" value=\"${redis.sentinel.name}\" />\n    <constructor-arg index=\"1\">\n        <set>\n            <value>${redis.sentinel.1}</value>\n            <value>${redis.sentinel.2}</value>\n            <value>${redis.sentinel.3}</value>\n        </set>\n    </constructor-arg>\n    <constructor-arg index=\"2\" ref=\"poolConfig\" />\n    <constructor-arg index=\"3\" value=\"${redis.master.pass}\" />\n</bean>\n```\n\n3. config.properties配置\n> \n```python\n#redis\nredis.db=0\nredis.maxTotal=1000\nredis.maxIdle=10\nredis.minIdle=1\nredis.maxWaitMillis=30000\nredis.testOnBorrow=true\nredis.testOnReturn=true\nredis.testWhileIdle=true\nredis.timeout=5000\n#redis sentinels\nredis.sentinel.name=mymaster\nredis.master.pass=zoufanqi\nredis.sentinel.1=127.0.0.1:63791\nredis.sentinel.2=127.0.0.1:63792\nredis.sentinel.3=127.0.0.1:63793\n```', '2', '0', '2017-06-15 14:32:29'), ('8', '1', '18', '## centos-redis主从配置\n\n[TOC]\n\nps: 撰写文档时间为：2016-10-24，以下涉及到的版本可适时斟酌。\n\n#### 序:\n> 软硬件配置：\n>> 1. 系统版本：CentOS Linux release 7.1.1503 (Core)\n>> 2. redis版本：3.2.4\n>> 3. 主从配置服务器设置\n>>> 1.1.1.1(主)\n>>> 1.1.1.2(从)\n>>> 1.1.1.3(从)\n\n#### 1. 安装redis\n> 1. rpm安装\n>> \n```\n# wget http://download.redis.io/releases/redis-3.2.4.tar.gz\n# tar xzf redis-3.2.4.tar.gz\n# mv redis-3.2.4 /usr/local/\n# cd /usr/local/redis-3.2.4\n# make\n```\n>>> ps: 不用`make install`\n>>> ps: 详见官网安装：http://redis.io/download\n>\n> 2. 修改配置\n>> \n```\ndaemonize no\n修改成：daemonize yes # 是否后台运行\ndir ./ \n修改成：dir /data/redis  # 数据目录\n```\n>>> ps:\n>>> 1. dir配置后对应目录需手动创建\n>>> 2. vi可通过`:/查找内容` -> 按字母`n`查找下一个，进行查找\n>\n> 3. 启动测试\n>> a. 启动服务\n>>> \n```\n# /usr/local/redis-3.2.4/src/redis-server /usr/local/redis-3.2.4/redis.conf\n```\n>>\n>> b. 关闭服务\n>>> \n```\n# /usr/local/redis-3.2.4/src/redis-cli -p <端口号> shutdown\n```\n>>> 或 绑定域名变更了，添加了密码\n>>> \n```\n# /usr/local/redis-3.2.4/src/redis-cli -p <端口号> -h [IP地址] -a \"密码\" shutdown\n```\n>>>> ps: 若是默认端口`6379`，则`-p <端口号>`可以省略\n>>\n>> c. 启动服务后登录客户端\n>>> \n```\n# /usr/local/redis-3.2.4/src/redis-cli -p <端口号>\n```\n>>> 或 绑定域名变更了，添加了密码\n>>> \n```\n# /usr/local/redis-3.2.4/src/redis-cli -p <端口号> -h [IP地址] -a \"密码\" shutdown\n```\n>>>> ps: 若是默认端口`6379`，则`-p <端口号>`可以省略\n>>\n>> d. redis测试\n>>> \n```\n127.0.0.1:6379> set a abc\nOK\n127.0.0.1:6379> get a\n\"abc\"\n```\n\n#### 2. 配置主从\n> a. 配置主服务器\n>> 编辑`redis.conf`\n>>> \n```\n# vi /usr/local/redis-3.2.4/redis.conf\n```\n>>>> 1. 修改绑定IP\n>>>>> \n```\nbind 1.1.1.3\n```\n>>>>>> ps: IP为当前服务器的IP, 从服务器需ping通。多个用空格隔开\n>>>> 2. 添加密码\n>>>>> \n```\nrequirepass <主服务器密码>\n```\n>\n> b. 配置从服务器\n>> 编辑`redis.conf`\n>>> 1. 配置主服务器信息\n>>>> \n```\nslaveof 1.1.1.3 16859\n```\n>>>>> ps: 主服务器IP + 主服务器端口号\n>>>\n>>> 2. 配置主服务器密码\n>>>> \n```\nmasterauth <主服务器密码>\n```\n>>>>> ps: 若从服务器不配置主服务器密码，可以登录成功，也可以获取到之前的数据，但主服务器数据变更后不会同步\n>\n> c. 测试\n>> 1. 主服务器添加一个key\n>> 2. 从服务器获取\n>\n> 完成配置！\n\n#### 附\n> 1. 若做主从分离，则需要连接从服务器。那么需注意这几点：\n>> 1. 配置中`bind`的域名，连接客户端需要ping通最少一个\n>> 2. 为从服务器设置密码\n\n> 2. 查看集群状态\n>> \n```\n# redis-cli -p <端口> -a <密码> info replication\n```', '2', '0', '2017-06-15 14:32:33'), ('9', '1', '20', '## centos-zabbix安装部署\n\nps: 文档撰写于2017-03-29, 版本问题适时斟酌\n\n[TOC]\n\n### 序\n> 软硬件配置：\n>> 1. 系统版本：CentOS Linux release 7.1.1503 (Core)\n>> 2. 软件依赖: MySQL\n>\n> zabbix简介:\n>> - zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。\n- zabbix由zabbix server与可选组件zabbix agent两部门组成。\n- zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视。\n- zabbix agent需要安装在被监视的目标服务器上，它主要完成对硬件信息或与操作系统有关的内存，CPU等信息的收集。\n>\n> zabbix的主要特点:\n>> - 安装与配置简单，学习成本低\n- 支持多语言（包括中文）\n- 免费开源\n- 自动发现服务器与网络设备\n- 分布式监视以及WEB集中管理功能\n- 可以无agent监视\n- 用户安全认证和柔软的授权方式\n- 通过WEB界面设置或查看监视结果\n- email等通知功能\n- 等等\n>\n> zabbix主要功能:\n>> - CPU负荷\n- 内存使用\n- 磁盘使用\n- 网络状况\n- 端口监视\n- 日志监视\n\n### 安装zabbix\n> 1. 安装软件依赖\n```\n# yum install mysql-devel gcc net-snmp-devel curl-devel perl-DBI php-gd php-mysql php-bcmath php-mbstring php-xm httpd php php-xml\n```\n>\n> 2. 安装mysql, 并添加zabbix访问权限\n```\n# grant all privileges on zabbix.* to zabbix_user@\'ip\' identified by \'123456\';\n```\n>\n> 3. 安装zabbix服务\n>> 1. 下载软件包\n>> ps: 下载地址: ```http://www.zabbix.com/download```\n```\n# wget https://fossies.org/linux/misc/zabbix-3.2.4.tar.gz\n# tar -zxvf zabbix-3.2.4.tar.gz\n# cd zabbix-3.2.4\n```\n>>\n>> 2. 安装\n>>> 1. 在 ```zabbix-3.2.4/database/mysql``` 目录中有sql文件, 将sql导入到mysql中\n>>> 2. 执行命令\n```\n# ./configure --prefix=/usr/local/zabbix --with-mysql --with-net-snmp --with-libcurl --enable-server --enable-agent --enable-proxy\n```\n>>>> ps1: **若只是客户端安装, 则 \\--enable-server 可省去**\n>>>> ps2: 缺少依赖编译不成功的, 根据提示安装好依赖重新编译.\n>>>\n>>> 3. 修改服务器配置(zabbix服务)\n>>>> ```# vi /usr/local/zabbix/etc/zabbix_server.conf```\n>>>>> \n```python\nDBHost=xxx.xxx.xxx.xxx\nDBName=zabbix\nDBUser=zabbix_user\nDBPassword=123456\nDBPort=3306\nListenIP=127.0.0.1    #服务器IP地址\n```\n>>> 4. 修改代理配置(其它监测服务器只需启动agent服务即可, 不用配置zabbix_server)\n>>>> ```# vi /usr/local/zabbix/etc/zabbix_agentd.conf```\n>>>>> \n```python\nServer=xxx.xxx.xxx.xxx # 部署zabbix_server服务的服务器IP\n# 在文件最后加入\nUserParameter=tcp_status[*],/usr/local/zabbix/bin/tcp_status.py $1 $2 $3\nUserParameter=custom.vfs.dev.read.ops[*],cat /proc/diskstats | grep $1 | head -1 | awk \'{print $$4}\'\nUserParameter=custom.vfs.dev.read.ms[*],cat /proc/diskstats | grep $1 | head -1 | awk \'{print $$7}\'\nUserParameter=custom.vfs.dev.write.ops[*],cat /proc/diskstats | grep $1 | head -1 | awk \'{print $$8}\'\nUserParameter=custom.vfs.dev.write.ms[*],cat /proc/diskstats | grep $1 | head -1 | awk \'{print $$11}\'\nUserParameter=custom.vfs.dev.io.active[*],cat /proc/diskstats | grep $1 | head -1 | awk \'{print $$12}\'\nUserParameter=custom.vfs.dev.io.ms[*],cat /proc/diskstats | grep $1 | head -1 | awk \'{print $$13}\'\nUserParameter=custom.vfs.dev.read.sectors[*],cat /proc/diskstats | grep $1 | head -1 | awk \'{print $$6}\'\nUserParameter=custom.vfs.dev.write.sectors[*],cat /proc/diskstats | grep $1 | head -1 | awk \'{print $$10}\'\nUserParameter=zabbix_low_discovery[*],/bin/bash /usr/local/zabbix/bin/partition_low_discovery.sh $1\nUserParameter=discovery_tcp_port[*],/bin/bash /usr/local/zabbix/bin/discovery_tcp_port.sh $1\nUserParameter=check_port[*],/bin/bash /usr/local/zabbix/bin/check_port.sh $1\n# 以下为数据库配置, 本地服务器没有数据库可不加\nUserParameter=mysql.slave,mysql -uroot -ptodayhero -e \"show slave status\\G\" | grep -E \"Slave_IO_Running:|Slave_SQL_Running:\"|awk \'{print $2}\'|grep -c Yes\nUserParameter=mysql.time,mysql -uroot -ptodayhero -e \'show slave status\\G;\'| grep Seconds_Behind_Maste| awk -F: \'{print $2}\'\n```\n>>>>> 以上涉及到的脚本, 分别有(文件具体内容见本文档最下方):\n>>>>>> - ```/usr/local/zabbix/bin/tcp_status.py```\n>>>>>> - ```/usr/local/zabbix/bin/partition_low_discovery.sh```\n>>>>>> - ```/usr/local/zabbix/bin/discovery_tcp_port.sh```\n>>>>>> - ```/usr/local/zabbix/bin/check_port.sh```\n>>\n>> 设置开机启动\n>>> ```# vi /etc/rc.d/rc.local```\n>>> 添加:\n```\n/usr/local/zabbix/sbin/zabbix_server\n/usr/local/zabbix/sbin/zabbix_agentd\n```\n\n### 安装httpd并启动\n> 1. 依赖在上节已安装\n> 2. 修改配置文件: ```/etc/php.ini```\n>> \n```\nmax_execution_time = 300\nmax_input_time = 300\nmemory_limit = 128M\npost_max_size = 32M\ndate.timezone = Asia/Shanghai	# 注意去掉前面的分号\nmbstring.func_overload = 2\n```\n>\n> 3. 拷贝源tar包解压后目录: zabbix-3.2.4/frontends/php 文件内容到 /usr/loca/zabbix/php\n> 4. 编辑zabbix客户端配置文件\n```\n# cd /usr/loca/zabbix/php/conf\n# cp zabbix.conf.php.example zabbix.conf.php\n# vi zabbix.conf.php\n```\n>>> 根据提示修改该配置文件\n> 5. ```# vi /etc/httpd/conf.d/zabbix.conf```\n>> \n```xml\n#\n# Zabbix monitoring system php web frontend\n#\nAlias /zabbix /usr/local/zabbix/php\n<Directory \"/usr/local/zabbix/php\">\n    Options FollowSymLinks\n    AllowOverride None\n    <IfModule mod_authz_core.c>\n      # Apache 2.4\n      Require all granted\n    </IfModule> \n    <IfModule !mod_authz_core.c>\n      # Apache 2.2\n      Order allow,deny\n      Allow from all\n    </IfModule>\n</Directory>\n<Directory ~ \"^/usr/local/zabbix/php/(conf|api|include)/\">\n    <IfModule mod_authz_core.c>\n      # Apache 2.4\n      Require all denied\n    </IfModule>\n    <IfModule !mod_authz_core.c>\n      # Apache 2.2\n      Order deny,allow\n      Deny from all\n    </IfModule>\n    <files *.php>\n      <IfModule mod_authz_core.c>\n        # Apache 2.4\n        Require all denied\n      </IfModule>\n      <IfModule !mod_authz_core.c>\n        Order deny,allow\n        Deny from all\n      </IfModule>\n    </files>\n</Directory>\n```\n>\n> 6. 启动服务\n```\n# service httpd start\n# /usr/local/zabbix/sbin/zabbix_server\n```\n>>> ps: 关闭zabbix_server服务:\n>>>> ```# killall zabbix_server```\n>\n> 7. 浏览器访问\n>> http://xxx.xxx.xxx.xxx/zabbix/index.php\n>\n> 8. zabbix_agentd客户端服务连接\n>> 安装步骤与以上服务器安装一致，只是装zabbix时注意不要选服务配置（上面有介绍）\n>> 修改：/usr/local/zabbix/conf/zabbix_agentd.conf\n>>> 将：Server 属性改为部署zabbix_server服务器IP即可，若是内网最好写内网地址\n\n### 附\n> zabbix_agentd.conf配置文件中的脚本内容\n>> 1. /usr/local/zabbix/bin/tcp_status.py\n>>> \n```python\n#!/usr/bin/env python\n#coding:UTF-8\nimport sys \ntcp_dict = {}\nsystem = {\'00\':\'ERROR_STATUS\',\'01\':\'ESTABLISHED\',\'02\':\'SYN_SENT\',\'03\':\'SYN_RECV\',\'04\':\'FIN_WAIT1\',\'05\':\'FIN_WAIT2\',\'06\':\'TIME_WAIT\',\'07\':\'CLOSE\',\'08\':\'CLOSE_WAIT\',\'09\':\'LAST_ACK\',\'0A\':\'LISTEN\',\'0B\':\'CLOSING\'}\ndef main(x):\n    with open(\'/proc/net/tcp\',\'rb\') as file:\n        for line in file:\n            tcp_status = line.split()[3]\n            if tcp_status in system:\n                if system[tcp_status] in tcp_dict:\n                    tcp_dict[system[tcp_status]] = tcp_dict.get(system[tcp_status],0) + 1 \n                else:\n                    tcp_dict[system[tcp_status]] = 1\n    if x not in tcp_dict:\n        print 0\n    else:\n        print tcp_dict[x]\nmain(sys.argv[1])\n```\n\n>> 2. /usr/local/zabbix/bin/partition_low_discovery.sh\n>>> \n```python\n#!/bin/bash\npartition() {\n        port=($(grep -E \"(vd[a-z]$|sd[a-z]$|sddlma[a-z]$)\" /proc/partitions|awk \'{print $4}\'))\n            printf \'{\\n\'\n            printf \'\\t\"data\":[\\n\'\n               for key in ${!port[@]}\n                   do\n                       if [[ \"${#port[@]}\" -gt 1 && \"${key}\" -ne \"$((${#port[@]}-1))\" ]];then\n                          printf \'\\t {\\n\'\n                          printf \"\\t\\t\\t\\\"{#PARTITIONNAME}\\\":\\\"${port[${key}]}\\\"},\\n\"\n                     else [[ \"${key}\" -eq \"((${#port[@]}-1))\" ]]\n                          printf \'\\t {\\n\'\n                          printf \"\\t\\t\\t\\\"{#PARTITIONNAME}\\\":\\\"${port[${key}]}\\\"}\\n\"\n                       fi\n               done\n                          printf \'\\t ]\\n\'\n                          printf \'}\\n\'\n}\n$1\n```\n\n>> 3. /usr/local/zabbix/bin/discovery_tcp_port.sh\n>>> \n```python\n#!/usr/bin/env python\n#coding:UTF-8\nimport sys\ntcp_dict = {}\nsystem = {\'00\':\'ERROR_STATUS\',\'01\':\'ESTABLISHED\',\'02\':\'SYN_SENT\',\'03\':\'SYN_RECV\',\'04\':\'FIN_WAIT1\',\'05\':\'FIN_WAIT2\',\'06\':\'TIME_WAIT\',\'07\':\'CLOSE\',\'08\':\'CLOSE_WAIT\',\'09\':\'LAST_ACK\',\'0A\':\'LISTEN\',\'0B\':\'CLOSING\'}\ndef main(x):\n    with open(\'/proc/net/tcp\',\'rb\') as file:\n        for line in file:\n            tcp_status = line.split()[3]\n            if tcp_status in system:\n                if system[tcp_status] in tcp_dict:\n                    tcp_dict[system[tcp_status]] = tcp_dict.get(system[tcp_status],0) + 1 \n                else:\n                    tcp_dict[system[tcp_status]] = 1\n    if x not in tcp_dict:\n        print 0\n    else:\n        print tcp_dict[x]\nmain(sys.argv[1])\n```\n\n>> 4. /usr/local/zabbix/bin/check_port.sh\n>>> \n```python\n#!/bin/bash\nport=$1\nif [ `netstat -an|grep ${port} |wc -l` -gt 0 ];then\n        echo 1\nelse\n        echo 0\nfi\n```', '2', '0', '2017-06-15 14:32:37'), ('10', '1', '22', '## centos-zookeeper集群配置\n\n[TOC]\n\nps: 撰写文档时间为：2016-10-24，以下涉及到的版本可适时斟酌。\n\n#### 序\n> 软硬件配置：\n1. 系统版本：CentOS Linux release 7.1.1503 (Core)\n2. zookeeper版本：3.4.9\n3. java版本：1.7.0_79\n4. 集群服务器\nps：节点数量为大于1的奇数\n```xml\n1.1.1.1\n1.1.1.2\n1.1.1.3\n```\n\n#### 1. 安装zookeeper\n```\n$ wget http://apache.org/dist/zookeeper/zookeeper-3.4.9/zookeeper-3.4.9.tar.gz\n$ tar -zxvf zookeeper-3.4.9.tar.gz\n$ mv zookeeper-3.4.9.tar.gz /usr/local/		-- 安装目录\n```\n\n#### 2. 集群配置\n> 1. 添加zoo.cfg文件\n```\n$ cd /usr/local/zookeeper-3.4.9/conf\n$ cp zoo_sample.cfg zoo.cfg\n```\n>\n> 2. 编辑zoo.cfg文件\n>> a. 修改数据存储目录\n```\n#dataDir=/tmp/zookeeper\n-- 上面行修改为以下配置\ndataDir=/data/zookeeper/data		-- 存放数据目录\ndataLogDir=/data/zookeeper/logs	 -- 存放日志目录\n```\n>>>> ps1: 对应存储目录需手动创建\n>>>> ps2: 2888端口号是服务之间通信的端口;3888是zookeeper与其他应用程序通信的端口\n>>\n>> b. 在配置文件最后添加集群服务器配置\n```\n# three servers of the cluster\nserver.1=1.1.1.1:2888:3888\nserver.2=1.1.1.2:2888:3888\nserver.3=1.1.1.3:2888:3888\n```\n>>> ps: `server.1`后面的数字`1`为myid，等下要用到\n>\n> 3. 添加myid文件\n```\n$ cd /data/zookeeper/data	# 2.a 节添加的dataDir目录\n$ vi myid	# 创建一个名为\"myid\"文件\n```\n>> 在myid文件中添加 `2.b` 节对应的myid(数字序号)\n>\n> 4. 测试\n>> a. 启动服务\n```\n$ /usr/local/zookeeper-3.4.9/bin/zkServer.sh start\n$ jps\n```\n>>>> 当看到 `QuorumPeerMain`JAVA进程时表示成功启动\n>>\n>> b. 关闭服务\n```\n$ /usr/local/zookeeper-3.4.9/bin/zkServer.sh stop\n```\n>>\n>> c. 客户端连接\n```\n$ /usr/local/zookeeper-3.4.9/bin/zkCli.sh -server localhost:2181\n```\n>>\n>> d. 查看状态\n```\n$ /usr/local/zookeeper-3.4.9/bin/zkServer.sh status\n```\n>>>> 会有以下状态\n```\nZooKeeper JMX enabled by default\nUsing config: /usr/local/zookeeper-3.4.9/bin/../conf/zoo.cfg\nMode: leader\n或\nZooKeeper JMX enabled by default\nUsing config: /usr/local/zookeeper-3.4.9/bin/../conf/zoo.cfg\nMode: follower\n```\n>>>>\n>>>> 如果出现以下错误信息\n```\nError contacting service. It is probably not running.\n```\n>>>>>> 可能原因：\n>>>>>> 1. myid配置错误\n>>>>>> 2. zoo.cfg 集群信息配置错误\n\nps: 注意防火墙！', '2', '0', '2017-06-15 14:32:43'), ('11', '1', '23', '### centos-elasticsearch5.x插件head安装\n\n文档更新于：2017-05-20\n\n序：\n> 环境：\n>> centos7\n>> jdk1.8\n>> elasticsearch5.3.2\n\n1.下载node.js\n\n2.相当于添加环境变量\n```shell\n# ln -s /usr/local/node-v6.9.5-linux-x64/bin/node /usr/bin/node\n# ln -s /usr/local/node-v6.9.5-linux-x64/bin/npm /usr/bin/npm\n\n# npm install -g grunt-cli\n# ln -s /usr/local/node-v6.9.5-linux-x64/lib/node_modules/grunt-cli/bin/grunt /usr/bin/grunt\n```\n\n3.下载head并解压\n> git: http://github.com/mobz/elasticsearch-head\n>> \n```\n# chown -R elasticsearch:elasticsearch elasticsearch-head/\n```\n\n4.配置es允许跨域访问\n> \n```\n# vi elasticsearch.yml\n```\n添加：\n>> \n```\nhttp.cors.enabled: true\nhttp.cors.allow-origin: \"*\"\n```\n\n5.在es-head目录执行 npm install  不用管报错\n\n6.修改插件主页对应es的TCP访问路径\n> \n```\n# vi elasticsearch-head/_site/app.js\n```\n>> 找到：`localhost`， 将 `http://localhost:9200` 改为 `http://esIP:es端口`\n\n7.修改访问权限\n> \n```\n# vi elasticsearch-head/Gruntfile.js\n```\n```json\nconnect: {\n	server: {\n		options: {\n			hostname: \'0.0.0.0\',  -- 加上这行\n		}\n	}\n}\n```\n\n\n8.在elasticserach-head 根目录执行： `# grunt server &`', '2', '0', '2017-06-15 14:32:40'), ('12', '1', '26', '### centos-更改163yum源\n\n[TOC]\n\n163源官网: http://mirrors.163.com/.help/centos.html\n\n#### 1. 进入yum源目录\n```# cd /etc/yum.repos.d```\n\n#### 2. 找到：CentOS-Base.repo，将其移除备份\n```# mv CentOS-Base.repo CentOS-Base.repo.bak```\n\n#### 3. 下载国内源，如：163（下面举例为centos6的源）\n```# wget http://mirrors.163.com/.help/CentOS6-Base-163.repo```\n\n#### 4. 输入命令立即生效\n```\n# yum clean all\n# yum makecache\n```', '2', '0', '2017-06-15 14:32:47'), ('13', '1', '28', '## centos-glusterfs集群\n\n[TOC]\n\nps: 撰写文档时间为：2017-3-20，以下涉及到的版本可适时斟酌。\n\n### 序\n> 1. centos版本: CentOS Linux release 7.2.1511 (Core)\n> 2. 服务器(最少两台)\n>> 1.1.1.1(host1)\n>> 1.1.1.2(host2)\n\n### yum安装glusterfs-server\n> \n```\n# yum install centos-release-gluster310\n```\n>> 310为版本号: 3.10\n>\n> \n```\n# yum install glusterfs-server\n```\n>\n> ps: 可参考:\n>> gluster版本下载: https://download.gluster.org/pub/gluster/glusterfs/\n>> glusterfs-server的yum安装: https://wiki.centos.org/SpecialInterestGroup/Storage\n\n### 配置\n> 1. 添加启动项(全部节点操作)\n>> \n```\n# chchkconfig glusterd on\n```\n>\n> 2. 启动服务(全部节点操作)\n>> \n```\n# service glusterd start\n```\n>\n> 3. 添加集群节点(单台节点操作)\n> ps: 操作时各节点的glusterd服务需启动\n```\n# gluster peer probe host1\n# gluster peer probe host2\n```\n>>> 查看状态\n>>>> \n```\n# gluster peer status\n```\n>>>\n>>> 移除节点\n>>>> \n```\n# gluster peer detach host1\n```\n>\n> 4. 创建卷(单台节点操作)\n> ps: glusterfs卷有很多种, 只把常用的几种列出\n> ps2: 卷最后一个目录会自动创建, 父目录及以上需手动. 如卷目录:`/data/glusterfs/volume`, `/data/glusterfs`需手动, `volume`会自动创建\n> ps3: 加`force`能用`root`创建卷,否则会报错\n>> 分布式卷\n>>> \n```\n# gluster volume create 卷名称 host1:/data/glusterfs host2:/data/glusterfs force\n```\n>>>> 1. `host1/host2`配置为两个节点,它们存储的数据是不重复的\n>>>> 2. 查看信息: `# gluster volume info [卷名称]`, 能看到`Type: Distributed`\n>>\n>> 复制卷\n>>> \n```\n# gluster volume create 卷名称 replica 2 host1:/data/glusterfs/data host2:/data/glusterfs/data\n```\n>>>> 1. `replica 2`->表示副本数，`host1/host2`存储数据是一样的,并且是全部数据\n>>>> 2. 该类型创建与扩展时, 节点数必须为`replica`设置的数的倍数; 即`replica=2`,则节点数`2N`\n>>>> 3. 查看信息: `# gluster volume info [卷名称]`, 能看到`Type: Replicate`\n>>\n>> 分布式复制卷\n>>> \n```\n# gluster volume create 卷名称 replica 2 host1:/data/glusterfs/data/volume1 host2:/data/glusterfs/data/volume1 host1:/data/glusterfs/data/volume2  host2:/data/glusterfs/data/volume2 force\n```\n>>>> 1. 节点顺序需固定. 如上配置效果: `host1`目录`volume1+host2:volume2=完整数据`; `host1:volume2+host2:volume2=完整数据`; 会成对匹配\n>>>> 2. `replica 2`->表示副本数, 创建与扩展时, 为`replica值的倍数`\n>>>> 3. 查看信息: `# gluster volume info [卷名称]`, 能看到`Type: Distributed-Replicate`\n>\n> 5. 启动分卷(单台节点操作)\n>> \n```\n# gluster volume start 卷名称\n```\n>\n> 6. 挂载测试\n> ps: 安装了gluster-server服务器可直接挂载,否则需要安装客户端程序\n>> \n```\n# mount -t glusterfs host1:/卷名称 /挂载目录\n```\n>\n> **分卷操作(单台节点操作)**\n>> 1. 启动分卷\n>>> \n```\n# gluster volume start 卷名称\n```\n>>\n>> 2. 关闭分卷\n>>> \n```\n# gluster volume stop 卷名称\n```\n>>\n>> 3. 删除分卷(需先关闭分卷)\n>>> \n```\n# gluster volume delete 卷名称\n```\n>>\n>> 4. 查看分卷\n>>> \n```\n# gluster volume info [卷名称]\n```\n>>\n>> 5. 添加brick\n>>> \n```\n# gluster volume add-brick 卷名称 host3:/data/glusterfs/data ... force\n```\n>>>> 带复制卷的添加节点需为replica值的倍数\n>>\n>> 6. 重新均衡卷\n```\n# gluster volume rebalance 卷名称 start\n# gluster volume rebalance 卷名称 stop\n# gluster volume rebalance 卷名称 status\n```\n>>\n>> 7. 收缩卷\n>> ps: 先将数据迁移到其它可用的Brick，迁移结束后才将该Brick移除：\n>>> \n```\n# gluster volume remove-brick <VOLNAME> <BRICK> start\n```\n>>> 在执行了start之后，可以使用status命令查看移除进度：\n>>> \n```\n# gluster volume remove-brick <VOLNAME> <BRICK> status\n```\n>>> 不进行数据迁移，直接删除该Brick:\n>>> \n```\n# gluster volume remove-brick <VOLNAME> <BRICK> commit\n```\n>>> 注意，如果是复制卷或者条带卷，则每次移除的Brick数必须是replica或者stripe的整数倍。', '2', '0', '2017-06-15 14:32:05'), ('14', '1', '32', '#### jquery-回车登录\n> 回车对应的keyCode为13，所以给对应的input添加onkeyup事件即可\n> 如：\n> ```html\n<div id=\"j_login\">\n	用户名：<input type=\"text\" />\n	密 码：<input type=\"password\" />\n</div>\n```\n>\n> 则对应的js\n> ```javascript\n$(function () {\n	$(\'#j_login input\').keyup(function (event) {\n		if (event.keyCode != 13) return;\n		// do login...\n	});\n});\n```', '2', '0', '2017-06-15 14:32:03'), ('15', '1', '34', '```javascript\n/**\n * \n * 数字转中文, 最高位万亿\n * \n */\nfunction numToCN(numberValue) {\n	var numberValue = new String(Math.round(numberValue * 100)); // 数字金额\n	// alert(numberValue);\n	var chineseValue = \"\"; // 转换后的汉字金额\n	var String1 = \"零壹贰叁肆伍陆柒捌玖\"; // 汉字数字\n	var String2 = \"万仟佰拾亿仟佰拾万仟佰拾圆角分\"; // 对应单位\n	var len = numberValue.length; // numberValue 的字符串长度\n	var Ch1; // 数字的汉语读法\n	var Ch2; // 数字位的汉字读法\n	var nZero = 0; // 用来计算连续的零值的个数\n	var String3; // 指定位置的数值\n	if (len > 15) {\n		alert(\"超出计算范围\");\n		return \"\";\n	}\n	/*\n	 * if (numberValue == 0) { chineseValue = \"零圆整\"; return chineseValue; }\n	 */\n	String2 = String2.substr(String2.length - len, len); // 取出对应位数的STRING2的值\n	// alert(String2);\n	for (var i = 0; i < len; i++) {\n		String3 = parseInt(numberValue.substr(i, 1), 10); // 取出需转换的某一位的值\n		if (i != (len - 3) && i != (len - 7) && i != (len - 11)\n				&& i != (len - 15)) {\n			if (String3 == 0) {\n				Ch1 = \"\";\n				Ch2 = \"\";\n				nZero = nZero + 1;\n			} else if (String3 != 0 && nZero != 0) {\n				Ch1 = \"零\" + String1.substr(String3, 1);\n				Ch2 = String2.substr(i, 1);\n				nZero = 0;\n			} else {\n				Ch1 = String1.substr(String3, 1);\n				Ch2 = String2.substr(i, 1);\n				nZero = 0;\n			}\n		} else { // 该位是万亿，亿，万，元位等关键位\n			if (String3 != 0 && nZero != 0) {\n				Ch1 = \"零\" + String1.substr(String3, 1);\n				Ch2 = String2.substr(i, 1);\n				nZero = 0;\n			} else if (String3 != 0 && nZero == 0) {\n				Ch1 = String1.substr(String3, 1);\n				Ch2 = String2.substr(i, 1);\n				nZero = 0;\n			} else if (String3 == 0 && nZero >= 3) {\n				Ch1 = \"\";\n				Ch2 = \"\";\n				nZero = nZero + 1;\n			} else {\n				Ch1 = \"\";\n				Ch2 = String2.substr(i, 1);\n				nZero = nZero + 1;\n			}\n			if (i == (len - 11) || i == (len - 3)) { // 如果该位是亿位或元位，则必须写上\n				Ch2 = String2.substr(i, 1);\n			}\n		}\n		chineseValue = chineseValue + Ch1 + Ch2;\n	}\n	if (String3 == 0 && numberValue != 0) { // 最后一位（分）为0时，加上“整”\n		chineseValue = chineseValue + \"整\";\n	}\n	return chineseValue;\n}\n/**\n * \n * 数字转中文, 最高位为千亿\n * \n */\nfunction numToCN(num) {\n	var capUnit = [ \'万\', \'亿\', \'万\', \'圆\', \'\' ];\n	var capDigit = {\n		2 : [ \'角\', \'分\', \'\' ],\n		4 : [ \'仟\', \'佰\', \'拾\', \'\' ]\n	};\n	var capNum = [ \'零\', \'壹\', \'贰\', \'叁\', \'肆\', \'伍\', \'陆\', \'柒\', \'捌\', \'玖\' ];\n	if (((num.toString()).indexOf(\'.\') > 16) || (isNaN(num)))\n		return \'\';\n	num = (Math.round(num * 100) / 100).toString();\n	num = ((Math.pow(10, 19 - num.length)).toString()).substring(1) + num;\n	var i, ret, j, nodeNum, k, subret, len, subChr, CurChr = [];\n	for (i = 0, ret = \'\'; i < 5; i++, j = i * 4 + Math.floor(i / 4)) {\n		nodeNum = num.substring(j, j + 4);\n		for (k = 0, subret = \'\', len = nodeNum.length; ((k < len) && (parseInt(nodeNum\n		.substring(k)) != 0)); k++) {\n			CurChr[k % 2] = capNum[nodeNum.charAt(k)]\n			+ ((nodeNum.charAt(k) == 0) ? \'\' : capDigit[len][k]);\n			if (!((CurChr[0] == CurChr[1]) && (CurChr[0] == capNum[0])))\n				if (!((CurChr[k % 2] == capNum[0]) && (subret == \'\') && (ret == \'\')))\n					subret += CurChr[k % 2];\n		}\n		subChr = subret + ((subret == \'\') ? \'\' : capUnit[i]);\n		if (!((subChr == capNum[0]) && (ret == \'\')))\n			ret += subChr;\n	}\n	ret = (ret == \'\') ? capNum[0] + capUnit[3] : ret;\n	return ret;\n}\n```', '2', '0', '2017-06-15 14:31:56'), ('16', '1', '38', '[TOC]\n\n#### 1. java生成图片验证码\n> 生成随机字母与数字的组合\n\n```java\nimport sun.misc.BASE64Encoder;\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Random;\n\n/**\n * Created by vanki on 2017/4/5.\n */\npublic class ImageCodeUtil {\n    protected static final Random RANDOM = new Random();\n    // 字体样式, 加粗, 斜体...\n    private static final int[] FONT_STYLE_ARR = {Font.BOLD, Font.ITALIC + Font.BOLD, Font.PLAIN + Font.ITALIC + Font.BOLD};\n    private static final String DEFAULT_STR = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\";\n    private static final String FORMAT_NAME = \"PNG\";\n    // 背景色范围\n    private static final int[] RGB_BACKGROUND = new int[]{200, 250};\n    private static final int[] RGB_DISTURB = new int[]{1, 255};\n    private static final int[] RGB_STRING = new int[]{1, 100};\n    // 字体\n    private static String[] FONT_NAME_ARR = new String[]{\"Default\"};\n    // 验证码\n    private String code = null;\n    // 图片的宽度。\n    private int width = 140;\n    // 图片的高度。\n    private int height = 40;\n    // 验证码字符个数\n    private int codeCount = 4;\n    // 验证码干扰线数\n    private int lineCount = 20;\n    // 验证码图片Buffer\n    private BufferedImage buffImg = null;\n\n    public ImageCodeUtil() {\n        createImage();\n    }\n\n    public ImageCodeUtil(String code) {\n        this.code = code;\n        if (code != null) this.codeCount = code.length();\n        createImage();\n    }\n\n    public ImageCodeUtil(int width, int height) {\n        this.width = width;\n        this.height = height;\n        createImage();\n    }\n\n    public ImageCodeUtil(int width, int height, String code) {\n        this.width = width;\n        this.height = height;\n        this.code = code;\n        if (code != null) this.codeCount = code.length();\n        createImage();\n    }\n\n    public ImageCodeUtil(int width, int height, String code, int lineCode) {\n        this.width = width;\n        this.height = height;\n        this.code = code;\n        this.lineCount = lineCode;\n        createImage();\n    }\n\n    public ImageCodeUtil(int width, int height, int codeCount) {\n        this.width = width;\n        this.height = height;\n        this.codeCount = codeCount;\n        createImage();\n    }\n\n    public ImageCodeUtil(int width, int height, int codeCount, int lineCount) {\n        this.width = width;\n        this.height = height;\n        this.codeCount = codeCount;\n        this.lineCount = lineCount;\n        createImage();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new ImageCodeUtil(\"12+343\").write(\"/data/aa.jpeg\");\n    }\n\n    protected static int getScopeNum(int min, int max) {\n        return RANDOM.nextInt(max) % (max - min + 1) + min;\n    }\n\n    protected static char getRandomChar(String str) {\n        int index = RANDOM.nextInt(str.length());\n        return str.charAt(index);\n    }\n\n    // 得到随机字符\n    protected String drawString() {\n        this.code = \"\";\n        int len = DEFAULT_STR.length() - 1;\n        double r;\n        for (int i = 0; i < this.codeCount; i++) {\n            r = (Math.random()) * len;\n            this.code = this.code + DEFAULT_STR.charAt((int) r);\n        }\n        return this.code;\n    }\n\n    public void write(String outImgPath) throws IOException {\n        ImageIO.write(buffImg, FORMAT_NAME, new File(outImgPath));\n    }\n\n    public void write(OutputStream os) throws IOException {\n        try {\n            ImageIO.write(buffImg, FORMAT_NAME, os);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (os != null) os.close();\n        }\n    }\n\n    /**\n     * 图片字节转base64字符, html解码: <img src=\"data:image/png;base64,这里放BASE64字符\"/>\n     *\n     * @return\n     *\n     * @throws IOException\n     */\n    public String writeBASE64() throws IOException {\n        ByteArrayOutputStream os = null;\n        try {\n            os = new ByteArrayOutputStream(2048);\n            ImageIO.write(buffImg, FORMAT_NAME, os);\n            return new BASE64Encoder().encode(os.toByteArray());\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (os != null) os.close();\n        }\n    }\n\n    public BufferedImage getBuffImg() {\n        return buffImg;\n    }\n\n    public String getCode() {\n        return code;\n    }\n\n    // 生成图片\n    private void createImage() {\n        if (this.code == null) {\n            this.code = drawString();// 得到随机字符\n            this.codeCount = this.code.length();\n        }\n\n        int fontWidth = width / codeCount;// 字体的宽度\n        int fontHeight = height - 2;// 字体的高度\n        int codeY = height - 6;\n\n        // 图像buffer\n        buffImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n        Graphics g = buffImg.getGraphics();\n        //Graphics2D g = buffImg.createGraphics();\n        // 设置背景色\n        g.setColor(getRandColor(RGB_BACKGROUND[0], RGB_BACKGROUND[1]));\n        g.fillRect(0, 0, width, height);\n\n        // 设置字体\n        Font font = getFont(fontHeight);\n        g.setFont(font);\n\n        // 设置干扰线\n        for (int i = 0; i < lineCount; i++) {\n            int xs = RANDOM.nextInt(width);\n            int ys = RANDOM.nextInt(height);\n            int xe = xs + RANDOM.nextInt(width);\n            int ye = ys + RANDOM.nextInt(height);\n            g.setColor(getRandColor(RGB_DISTURB[0], RGB_DISTURB[1]));\n            g.drawLine(xs, ys, xe, ye);\n        }\n\n        // 添加噪点\n        float yawpRate = 0.01f;// 噪声率\n        int area = (int) (yawpRate * width * height);\n        for (int i = 0; i < area; i++) {\n            int x = RANDOM.nextInt(width);\n            int y = RANDOM.nextInt(height);\n\n            buffImg.setRGB(x, y, RANDOM.nextInt(255));\n        }\n\n        for (int i = 0; i < this.codeCount; i++) {\n            String strRand = this.code.substring(i, i + 1);\n            g.setColor(getRandColor(RGB_STRING[0], RGB_STRING[1]));\n            // g.drawString(a,x,y);\n            // a为要画出来的东西，x和y表示要画的东西最左侧字符的基线位于此图形上下文坐标系的 (x, y) 位置处\n            g.drawString(strRand, i * fontWidth + 1, codeY);\n        }\n    }\n\n    // 得到随机颜色\n    private Color getRandColor(int fc, int bc) {// 给定范围获得随机颜色\n        if (fc > 255) fc = 255;\n        if (bc > 255) bc = 255;\n        int r = getScopeNum(fc, bc);\n        int g = getScopeNum(fc, bc);\n        int b = getScopeNum(fc, bc);\n        return new Color(r, g, b);\n    }\n\n    /**\n     * 产生随机字体\n     */\n    private Font getFont(int fontSize) {\n        initFontNameArr();\n        int indexName = RANDOM.nextInt(FONT_NAME_ARR.length);\n        int indexStyle = RANDOM.nextInt(FONT_STYLE_ARR.length);\n        return new Font(FONT_NAME_ARR[indexName], FONT_STYLE_ARR[indexStyle], fontSize);\n    }\n\n    private void initFontNameArr() {\n        if (FONT_NAME_ARR != null) return;\n        FONT_NAME_ARR = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n    }\n}\n```\n\n#### 2. java生成图片数学计算图片验证码（继承1）\n> 该类继承自上面的类，生成的图片验证码为简单的数学四则运算\n\n```java\nimport java.io.IOException;\n\n/**\n * Created by vanki on 2017/4/5.\n */\npublic class ImageCodeMathCalcUtil extends ImageCodeUtil {\n    private static final String MATH_CALC_SIGN = \"+-*/加减乘除\";\n    //    private static final String MATH_CALC_SIGN = \"/\";\n    private String value;\n\n    public ImageCodeMathCalcUtil() {\n        super(180, 30);\n    }\n\n    public ImageCodeMathCalcUtil(int width, int height) {\n        super(width, height);\n    }\n\n    public static void main(String[] args) throws IOException {\n        ImageCodeMathCalcUtil imageCode = new ImageCodeMathCalcUtil();\n//        System.out.println(imageCode.writeBASE64());\n//        System.out.println(imageCode.writeBASE64());\n        imageCode.write(\"/data/aa.png\");\n        System.out.println(imageCode.getCode());\n        System.out.println(imageCode.getValue());\n    }\n\n    public String getValue() {\n        return this.value;\n    }\n\n    /**\n     * 生成随机数学四则运算的字符串 <br />\n     * 数组0: 运算公式, 如: 43减1=? <br />\n     * 数组1: 运算值, 如: 42\n     *\n     * @return\n     */\n    @Override\n    protected String drawString() {\n        char calcSignChar = getRandomChar(MATH_CALC_SIGN);\n\n        String[] arr = null;\n\n        switch (calcSignChar) {\n            case \'+\':\n                arr = mathCalcPlus(\'+\');\n                break;\n            case \'-\':\n                arr = mathCalcSub(\'-\');\n                break;\n            case \'*\':\n                arr = mathCalcMul(\"*\");\n                break;\n            case \'/\':\n                arr = mathCalcDivide(\"÷\");\n                break;\n            case \'加\':\n                arr = mathCalcPlus(\'加\');\n                break;\n            case \'减\':\n                arr = mathCalcSub(\'减\');\n                break;\n            case \'乘\':\n                arr = mathCalcMul(\"乘以\");\n                break;\n            case \'除\':\n                arr = mathCalcDivide(\"除以\");\n                break;\n        }\n        arr[0] = arr[0] + \"=?\";\n\n        this.value = arr[1];\n        return arr[0];\n    }\n\n\n    /**\n     * 加法计算, 两个加数中最多只有一个为两位数, 100以内\n     *\n     * @return\n     */\n    private String[] mathCalcPlus(char signChar) {\n        int val1 = getScopeNum(0, 90);\n        int val2;\n        if (val1 > 9) {\n            val2 = getScopeNum(0, 9);\n        } else {\n            val2 = getScopeNum(0, 90);\n        }\n        String code = new StringBuffer().append(val1).append(signChar).append(val2).toString();\n        String codeVal = String.valueOf(val1 + val2);\n        return new String[]{code, codeVal};\n    }\n\n    /**\n     * 减法计算, 值为正整数, 100以内\n     *\n     * @param signChar\n     *\n     * @return\n     */\n    private String[] mathCalcSub(char signChar) {\n        int val1 = getScopeNum(0, 99);\n        int val2 = getScopeNum(0, val1 > 9 ? 9 : val1);\n\n        String code = new StringBuffer().append(val1).append(signChar).append(val2).toString();\n        String codeVal = String.valueOf(val1 - val2);\n\n        return new String[]{code, codeVal};\n    }\n\n    /**\n     * 乘法计算, 乘数与被乘数都是1位\n     *\n     * @param signChar\n     *\n     * @return\n     */\n    private String[] mathCalcMul(String signChar) {\n        int val1 = getScopeNum(0, 9);\n        int val2 = getScopeNum(0, 9);\n\n        String code = new StringBuffer().append(val1).append(signChar).append(val2).toString();\n        String codeVal = String.valueOf(val1 * val2);\n\n        return new String[]{code, codeVal};\n    }\n\n    /**\n     * 除法计算, 值为整数, 值和除数皆为1位\n     *\n     * @param signChar\n     *\n     * @return\n     */\n    private String[] mathCalcDivide(String signChar) {\n        int val1 = getScopeNum(1, 9);\n        int val2 = getScopeNum(1, 9);\n\n        String code = new StringBuffer().append(val1 * val2).append(signChar).append(val1).toString();\n        String codeVal = String.valueOf(val2);\n\n        return new String[]{code, codeVal};\n    }\n}\n```', '2', '0', '2017-06-15 14:31:59'), ('17', '1', '40', '## 常用Markdown操作案例\n### 主要特性\n\n- 支持“标准”Markdown / CommonMark和Github风格的语法，也可变身为代码编辑器；\n- 支持实时预览、图片（跨域）上传、预格式文本/代码/表格插入、代码折叠、搜索替换、只读模式、自定义样式主题和多语言语法高亮等功能；\n- 支持ToC（Table of Contents）、Emoji表情、Task lists、@链接等Markdown扩展语法；\n- 支持TeX科学公式（基于KaTeX）、流程图 Flowchart 和 时序图 Sequence Diagram;\n- 支持识别和解析HTML标签，并且支持自定义过滤标签解析，具有可靠的安全性和几乎无限的扩展性；\n- 支持 AMD / CMD 模块化加载（支持 Require.js & Sea.js），并且支持自定义扩展插件；\n- 兼容主流的浏览器（IE8+）和Zepto.js，且支持iPad等平板设备；\n- 支持自定义主题样式；\n\n**目录 (Table of Contents)**\n\n[TOCM]\n\n[TOC]\n\n# Heading 1\n## Heading 2\n### Heading 3\n#### Heading 4\n##### Heading 5\n###### Heading 6\n# Heading 1 link [Heading link](http://www.qiqinote.com \"Heading link\")\n## Heading 2 link [Heading link](http://www.qiqinote.com \"Heading link\")\n### Heading 3 link [Heading link](http://www.qiqinote.com \"Heading link\")\n#### Heading 4 link [Heading link](http://www.qiqinote.com \"Heading link\") Heading link [Heading link](http://www.qiqinote.com \"Heading link\")\n##### Heading 5 link [Heading link](http://www.qiqinote.com \"Heading link\")\n###### Heading 6 link [Heading link](http://www.qiqinote.com \"Heading link\")\n\n#### 标题（用底线的形式）Heading (underline)\n\nThis is an H1\n=============\n\nThis is an H2\n-------------\n\n### 字符效果和横线等\n\n----\n\n~~删除线~~ <s>删除线（开启识别HTML标签时）</s>\n*斜体字*      _斜体字_\n**粗体**  __粗体__\n***粗斜体*** ___粗斜体___\n\n上标：X<sub>2</sub>，下标：O<sup>2</sup>\n\n**缩写(同HTML的abbr标签)**\n\n> 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启\n\nThe <abbr title=\"Hyper Text Markup Language\">HTML</abbr> specification is maintained by the <abbr\n                title=\"World Wide Web Consortium\">W3C</abbr>.\n\n### 引用 Blockquotes\n\n> 引用文本 Blockquotes\n\n引用的行内混合 Blockquotes\n\n> 引用：如果想要插入空白换行`即<br/>标签`，在插入处先键入两个以上的空格然后回车即可，[普通链接](http://www.qiqinote.com)。\n\n### 锚点与链接 Links\n\n[普通链接](http://www.qiqinote.com)\n\n[普通链接带标题](http://www.qiqinote.com \"普通链接带标题\")\n\n直接链接：<http://www.qiqinote.com>\n\n[锚点链接][anchor-id]\n\n[anchor-id]: http://www.this-anchor-link.com/\n\n### 多语言代码高亮 Codes\n\n#### 行内代码 Inline code\n\n执行命令：`npm install marked`\n\n#### 缩进风格\n\n即缩进四个空格，也做为实现类似`<pre>`预格式化文本(Preformatted Text)的功能。\n\n    <?php\n        echo \"Hello world!\";\n    ?>\n\n            预格式化文本：\n\n    | First Header  | Second Header |\n    | ------------- | ------------- |\n    | Content Cell  | Content Cell  |\n    | Content Cell  | Content Cell  |\n\n#### JS代码　\n\n```javascript\nfunction test(){\n	console.log(\"Hello world!\");\n}\n\n(function(){\n    var box = function(){\n        return box.fn.init();\n    };\n\n    box.prototype = box.fn = {\n        init : function(){\n            console.log(\'box.init()\');\n\n			return this;\n        },\n\n		add : function(str){\n			alert(\"add\", str);\n\n			return this;\n		},\n\n		remove : function(str){\n			alert(\"remove\", str);\n\n			return this;\n		}\n    };\n\n    box.fn.init.prototype = box.fn;\n\n    window.box =box;\n})();\n\nvar testBox = box();\ntestBox.add(\"jQuery\").remove(\"jQuery\");\n```\n\n#### HTML代码 HTML codes\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <mate charest=\"utf-8\"/>\n        <title>Hello world!</title>\n    </head>\n    <body>\n        <h1>Hello world!</h1>\n    </body>\n</html>\n```\n\n### 图片 Images\n\nImage:\n\n![](https://pandao.github.io/editor.md/examples/images/4.jpg)\n\n> Follow your heart.\n\n![](https://pandao.github.io/editor.md/examples/images/8.jpg)\n\n> 图为：厦门白城沙滩\n\n图片加链接 (Image + Link)：\n\n[![](https://pandao.github.io/editor.md/examples/images/7.jpg)](https://pandao.github.io/editor.md/examples/images/7.jpg \"李健首张专辑《似水流年》封面\")\n\n> 图为：李健首张专辑《似水流年》封面\n\n----\n\n### 列表 Lists\n\n#### 无序列表（减号）Unordered Lists (-)\n\n- 列表一\n- 列表二\n- 列表三\n\n#### 无序列表（星号）Unordered Lists (*)\n\n* 列表一\n* 列表二\n* 列表三\n\n#### 无序列表（加号和嵌套）Unordered Lists (+)\n\n+ 列表一\n+ 列表二\n    + 列表二-1\n    + 列表二-2\n    + 列表二-3\n+ 列表三\n    * 列表一\n    * 列表二\n    * 列表三\n\n#### 有序列表 Ordered Lists (-)\n\n1. 第一行\n2. 第二行\n3. 第三行\n\n#### GFM task list\n\n- [x] GFM task list 1\n- [x] GFM task list 2\n- [ ] GFM task list 3\n    - [ ] GFM task list 3-1\n    - [ ] GFM task list 3-2\n    - [ ] GFM task list 3-3\n- [ ] GFM task list 4\n    - [ ] GFM task list 4-1\n    - [ ] GFM task list 4-2\n\n----\n\n### 绘制表格 Tables\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机      | $1600   |   5     |\n| 手机        |   $12   |   12   |\n| 管线        |    $1    |  234  |\n\nFirst Header  | Second Header\n------------- | -------------\nContent Cell  | Content Cell\nContent Cell  | Content Cell\n\n| First Header  | Second Header |\n| ------------- | ------------- |\n| Content Cell  | Content Cell  |\n| Content Cell  | Content Cell  |\n\n| Function name | Description                    |\n| ------------- | ------------------------------ |\n| `help()`      | Display the help window.       |\n| `destroy()`   | **Destroy your computer!**     |\n\n| Left-Aligned  | Center Aligned  | Right Aligned |\n| :------------ |:---------------:| -----:|\n| col 3 is      | some wordy text | $1600 |\n| col 2 is      | centered        |   $12 |\n| zebra stripes | are neat        |    $1 |\n\n| Item      | Value |\n| --------- | -----:|\n| Computer  | $1600 |\n| Phone     |   $12 |\n| Pipe      |    $1 |\n\n----\n\n#### 特殊符号 HTML Entities Codes\n\n&copy; &  &uml; &trade; &iexcl; &pound;\n&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;\n\nX&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;\n\n18&ordm;C  &quot;  &apos;\n\n#### 反斜杠 Escape\n\n\\*literal asterisks\\*\n\n### 科学公式 TeX(KaTeX)\n\n$$E=mc^2$$\n\n行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。\n\n$$\\(\\sqrt{3x-1}+(1+x)^2\\)$$\n\n$$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$\n\n多行公式：\n\n```math\n\\displaystyle\n\\left( \\sum\\_{k=1}^n a\\_k b\\_k \\right)^2\n\\leq\n\\left( \\sum\\_{k=1}^n a\\_k^2 \\right)\n\\left( \\sum\\_{k=1}^n b\\_k^2 \\right)\n```\n\n```katex\n\\displaystyle\n    \\frac{1}{\n        \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\n        \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {\n        1+\\frac{e^{-6\\pi}}\n        {1+\\frac{e^{-8\\pi}}\n         {1+\\cdots} }\n        }\n    }\n```\n\n```latex\nf(x) = \\int_{-\\infty}^\\infty\n    \\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\n    \\,d\\xi\n```\n\n### 绘制流程图 Flowchart\n\n```flow\nst=>start: 用户登陆\nop=>operation: 登陆操作\ncond=>condition: 登陆成功 Yes or No?\ne=>end: 进入后台\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n### 绘制序列图 Sequence Diagram\n\n```seq\nAndrew->China: Says Hello\nNote right of China: China thinks\\nabout it\nChina-->Andrew: How are you?\nAndrew->>China: I am good thanks!\n```\n\n### End', '2', '0', '2017-06-15 14:31:52'), ('18', '1', '42', '#### java分页\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Page<Entity> {\n\n    //数据库总行数\n    private int rowCount;\n\n    //一页多少行\n    private int pageSize = 10;\n\n    //第几页\n    private int num;\n\n    //查询起始行\n    private int startRow;\n\n    //下一页\n    private int next;\n\n    //上一页\n    private int prev;\n\n    //一共多少页\n    private int pageCount;\n\n    //显示导航起始\n    private int begin;\n\n    //显示的导航结束\n    private int end;\n\n    //首页\n    private int first = 1;\n\n    //尾页\n    private int last;\n\n    //一共显示多少导航\n    private int navNum = 10;\n\n    //分页查询之后的数据\n    private List<Entity> data = new ArrayList<Entity>(0);\n\n\n    public Page() {\n        super();\n    }\n\n    public Page(Integer pageNo, Integer pageSize, Integer rowCount) {\n        this(pageNo, pageSize, rowCount, 10);\n    }\n\n    public Page(Integer pageNo, Integer pageSize, Integer rowCount, Integer navNum) {\n        pageNo = pageNo == null || pageNo < 1 ? 1 : pageNo;\n        pageSize = pageSize == null || pageSize < 0 ? 10 : pageSize;\n        rowCount = rowCount == null || rowCount < 0 ? 0 : rowCount;\n        navNum = navNum == null || navNum < 0 ? 10 : navNum;\n        this.navNum = navNum;\n        this.rowCount = rowCount;\n        this.pageSize = pageSize;\n        this.pageCount = (int) Math.ceil(this.rowCount * 1.0 / this.pageSize);\n        this.last = this.pageCount;\n        this.num = Math.min(this.last, this.num);\n        this.num = Math.max(this.first, pageNo);\n\n        //this.startRow = Math.max(0, (this.num - 1) * this.pageSize);\n        this.startRow = Math.max(0, (pageNo - 1) * this.pageSize);\n\n        this.next = Math.min(this.last, this.num + 1);\n        this.prev = Math.max(this.first, this.num - 1);\n\n        this.begin = Math.max(this.first, this.num - (this.navNum / 2));\n        this.end = Math.min(this.last, this.begin + this.navNum - 1);\n\n        if ((this.end - this.begin) < (this.navNum - 1)) {\n            this.begin = Math.max(this.first, this.last - this.navNum + 1);\n        }\n    }\n\n    public static <T> void copyData(Page<T> receivePage, Page<?> expendPage) {\n        if (receivePage == null || expendPage == null) return;\n        receivePage.setRowCount(expendPage.getRowCount());\n        receivePage.setPageSize(expendPage.getPageSize());\n        receivePage.setNum(expendPage.getNum());\n        receivePage.setStartRow(expendPage.getStartRow());\n        receivePage.setNext(expendPage.getNext());\n        receivePage.setPrev(expendPage.getPrev());\n        receivePage.setPageCount(expendPage.getPageCount());\n        receivePage.setBegin(expendPage.getBegin());\n        receivePage.setEnd(expendPage.getEnd());\n        receivePage.setFirst(expendPage.getFirst());\n        receivePage.setLast(expendPage.getLast());\n        receivePage.setNavNum(expendPage.getNavNum());\n    }\n\n    public int getRowCount() {\n        return rowCount;\n    }\n\n    public void setRowCount(int rowCount) {\n        this.rowCount = rowCount;\n    }\n\n    public int getPageSize() {\n        return pageSize;\n    }\n\n    public void setPageSize(int pageSize) {\n        this.pageSize = pageSize;\n    }\n\n    public int getNum() {\n        return num;\n    }\n\n    public void setNum(int num) {\n        this.num = num;\n    }\n\n    public int getStartRow() {\n        return startRow;\n    }\n\n    public void setStartRow(int startRow) {\n        this.startRow = startRow;\n    }\n\n    public int getNext() {\n        return next;\n    }\n\n    public void setNext(int next) {\n        this.next = next;\n    }\n\n    public int getPrev() {\n        return prev;\n    }\n\n    public void setPrev(int prev) {\n        this.prev = prev;\n    }\n\n    public int getPageCount() {\n        return pageCount;\n    }\n\n    public void setPageCount(int pageCount) {\n        this.pageCount = pageCount;\n    }\n\n    public int getBegin() {\n        return begin;\n    }\n\n    public void setBegin(int begin) {\n        this.begin = begin;\n    }\n\n    public int getEnd() {\n        return end;\n    }\n\n    public void setEnd(int end) {\n        this.end = end;\n    }\n\n    public int getFirst() {\n        return first;\n    }\n\n    public void setFirst(int first) {\n        this.first = first;\n    }\n\n    public int getLast() {\n        return last;\n    }\n\n    public void setLast(int last) {\n        this.last = last;\n    }\n\n    public int getNavNum() {\n        return navNum;\n    }\n\n    public void setNavNum(int navNum) {\n        this.navNum = navNum;\n    }\n\n    public List<Entity> getData() {\n        return data;\n    }\n\n    public void setData(List<Entity> data) {\n        this.data = data;\n    }\n\n    @Override\n    public String toString() {\n        return \"Page [rowCount=\" + rowCount + \", pageSize=\" + pageSize + \", num=\" + num + \", startRow=\" + startRow\n                + \", next=\" + next + \", prev=\" + prev + \", pageCount=\" + pageCount + \", begin=\" + begin + \", end=\" + end\n                + \", first=\" + first + \", last=\" + last + \", navNum=\" + navNum + \", data=\" + data + \"]\";\n    }\n```', '2', '0', '2017-05-22 11:13:55');
INSERT INTO `note_detail` VALUES ('19', '1', '44', '[TOC]\n\n### mac安装golang开发环境\n\n#### 1、安装Golang的SDK\n* google官网下载地址如下:  http://www.golangtc.com/download ，下载最新的安装包，之后双击安装即可。\n安装完成之后，打开终端，输入go、或者go version(查看安装版本)出现如下信息即表示安装成功：\n> `# go version`\n```\ngo version go1.5rc1 darwin/amd64\n```\n\n#### 2、配置环境变量（如果是安装goclispe插件，则可不配）\n* a、添加两个文件path:\n> \n```\nGOPATH：日常开发的根目录\nGOBIN：GOPATH下的bin目录\n```\n\n* b、配置path到`~/.bash_profile`\n> \n```\nexport GOPATH=/Users/vanki/Documents/workspace/GO\nexport GOBIN=$GOPATH/bin\nexport PATH=GOBIN\n```\n\n* c、输入：`# go env` 查看配置，结果如下：\n```shell\nGOARCH=\"amd64\"\nGOBIN=\"/Users/vanki/Documents/workspace/GO/bin\"\nGOEXE=\"\"\nGOHOSTARCH=\"amd64\"\nGOHOSTOS=\"darwin\"\nGOOS=\"darwin\"\nGOPATH=\"/Users/vanki/Documents/workspace/GO\"\nGORACE=\"\"\nGOROOT=\"/usr/local/go\"\nGOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\"\nGO15VENDOREXPERIMENT=\"\"\nCC=\"clang\"\nGOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fno-common\"\nCXX=\"clang++\"\nCGO_ENABLED=\"1\"\n```\n\n#### 3、安装IDE及编译\n * eclipse 安装插件\n> github地址：https://github.com/GoClipse/goclipse/blob/latest/documentation/Installation.md#installation\n在eclipse->Install new software添加地址： http://goclipse.github.io/releases/\n选择：Goclipse，一路安装即可\n\n* 配置go环境\n> 打开eclipse “偏好设置”，在go页面添加配置\n```\nGOROOT：安装的go根目录\nGOPATH：工作区目录\n```\n\n* 安装LiteIDE\n> 下载LiteIDE，解压即可\n> 若要调试程序则还需安装gdb，安装方法\n>> `# brew install gdb`', '2', '0', '2017-06-15 14:31:49'), ('20', '1', '45', '```javascript\n/**\n * 数字转义可读字符串（需先添加转义类型）。如：12345->1.2万，123456789->1.2亿\n * @param num               数值\n * @param exactNum          精确位数，为假时自动识别最大定义的类型\n * @param decimalNum        保留小数位，默认为2\n * @param isDecimalNumMust  小数位最后若为0是否强制保留，默认不保留\n * @returns {*}\n */\nfunction numToHumanView(num, exactNum, decimalNum, isDecimalNumMust) {\n    num = Number(num);\n    if (!num) return 0;\n\n    decimalNum = decimalNum || 2;	// 小数点后精确位数\n\n    tInfo = {\n        5: [10000, \'万\'],\n        9: [100000000, \'亿\'],\n        // 在此添加转义类型\n    };\n    var nArr;\n\n    if (exactNum) {\n        nArr = tInfo[exactNum];\n    } else {	// 自适应最高位的转义\n        var nTemp;\n        for (i in tInfo) {\n            nTemp = tInfo[i];\n            if (nTemp[0] > num) break;\n            nArr = nTemp;\n        }\n    }\n\n    if (!nArr) return num;\n    if (num < nArr[0]) return num;\n\n    var result = Number(num / nArr[0]).toFixed(decimalNum);\n\n    /**\n     * 小数点后如果最后为0是否去除，默认去除\n     */\n    outIf: if (!isDecimalNumMust) {\n        var rArr = result.split(\".\");\n        result = rArr[0];\n        var suffixArr = rArr[1];\n        if (!suffixArr) break outIf;\n\n        var decimalSuffix = \'\';\n\n        for (var i = suffixArr.length; i > 0; i--) {\n            var v = suffixArr[i - 1];\n            if (v == \'0\' && decimalSuffix == \'\') continue;\n            decimalSuffix = v + decimalSuffix;\n        }\n        if (!decimalSuffix) break outIf;\n        result += \".\" + decimalSuffix;\n    }\n    return result + nArr[1];\n}\n```', '2', '0', '2017-06-15 14:31:43'), ('21', '1', '46', '```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\n/**\n * Created by vanki on 2017/8/2.\n */\npublic class ExceptionUtil {\n    /**\n     * 获取异常的全部信息，便于记录log\n     *\n     * @param ex\n     *\n     * @return 2015年12月12日 上午11:28:20\n     */\n    public static String getAllExceptionMessages(Exception ex) {\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        ex.printStackTrace(pw);\n        pw.flush();\n        sw.flush();\n        if (pw != null) pw.close();\n        try {\n            if (sw != null) sw.close();\n        } catch (IOException e1) {\n        }\n        return sw.toString();\n    }\n}\n\n```', '2', '0', '2017-06-15 14:31:46'), ('22', '1', '48', '\n### java web乱码\n\n1. 服务器向客户端传数据乱码（即：向浏览器输出）\n> 解决方案：```response.setContentType(\"text/html;charset=utf-8\");```\n\n2. 客户端向服务器传数据乱码（比如：浏览器请求链接时传中文）\n> 解决方案：\n>> a. 打开tomcat下的```server.xml```文件\n  b. 找到```port=\"8080\"```该属性，在其加上：```URIEncoding=\"utf-8\"```\n  c. 如：\n  ```xml\n  <Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" URIEncoding=\"utf-8\"/>\n  ```', '2', '0', '2017-05-22 15:17:23'), ('23', '1', '50', '#### ubuntu下修改eclipse提示框颜色\n\n> eclipse提示框的背景颜色使用的是系统的提示框颜色配置，在windows下为黄色，但在Ubuntu12.04(gnome)下却是黑色，造成提示内容很难看清。\n在eclipse中我们是无法修改这个颜色的配置的，只能通过修改系统的颜色配置。\n在ubuntu11.10以前，我们是可以能过自定义系统外观来修改这一颜色的配置的，但自ubuntu11.10以后，就没有相关的操作界面了，只能通过修改配置文件的方式实现了。这个文件位于```/usr/share/themes/```下对应的主题文件夹下，如你使用Radiance主题，就进入到```/usr/share/themes/Radiance/```目录下，具体操作：\n>> - 进入Radiance主题\n```shell\n# cd /usr/share/themes/Radiance\n```\n- 打开gtk-2.0/gtkrc文件\n>>> sudo vim gtk-2.0/gtkrc\n- 修改第一行的tooltip_fg_color和tooltip_bg_color两个属性的值，如果没有改属性，可以自行添加，其值仿照windows的默认值，分别设定位：\n```\ntooltip_fg_color:#000000\ntooltip_bg_color:#f2edbc\n```\n- 保存退出，打开系统外观配置，切换一下主题，当切换回来的时候，修改的效果就生效了。\n', '2', '0', '2017-05-22 15:26:59'), ('24', '1', '51', '#### eclipse内存溢出\n\n> 启动项目，内存溢出（tomcat）\n> 解决方法：\n>> 在run或debug配置参数后面加上：\n```\n-Xms256m -Xmx512m -XX:MaxNewSize=256m -XX:MaxPermSize=256m\n```\n\n> 增大eclipse内存\n>> 打开eclipse根目录下的eclipse.ini文件\n```\n将后面几行改为：\n-Xms512m\n-Xmx512m\n-XX:PermSize=512m\n-XX:MaxPermSize=512m\n```', '2', '0', '2017-05-22 15:33:08'), ('25', '1', '53', '【目录】\n\n[TOC]\n\n### RabbitMQ 安装与配置\n\n* ps：由于安装环境是mac，所以以下文档都是基于mac环境编写，但也适用于linux，只是可能某些命令不同。其它系统步骤是一致的。\n\n* 简介\n> \n		MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消 息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。\n		MQ是消费-生产者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取或者订阅队列中的消息。MQ和JMS类似，但不同的是JMS是SUN JAVA消息中间件服务的一个标准和API定义，而MQ则是遵循了AMQP协议的具体实现和产品。\n		RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统。他遵循Mozilla Public License开源协议。\n\n#### 1.安装Erlang\n> 由于RabbitMQ 服务器是用Erlang编写，所以安装之前先安装Erlang\n- 下载erlang源文件包\n> 参考地址：http://www.erlang.org/download.html\n> * 下载后解压安装，安装步骤，输入命令：\n```\n# ./configure\n# make && make install\n```\n> * 检测是否安装成功，输入命令：\n```\n# erl\n```\n\n#### 2. 安装RabbitMQ\n> 命令如下：\n```\nmac: # brew install rabbitmq\ncentos: # yum install rabbitmq-server\n```\n\n#### 3. 启动与关闭\n> brew 会将软件安装到目录：```/usr/local/opt/```，所以在该目录下进入：```# ./rabbitmq/sbin```操作rabbitmq（也可配置环境变量）\n- 启动rabbitmq\n>> ```# ./rabbitmq-server -detached```\n- 查看rabbitmq 状态\n>> ```# ./rabbitmqctl status```\n- 关闭rabbitmq\n>> ```# ./rabbitmqctl stop```\n- rabbitmq插件列表\n>> ```# ./rabbitmq-plugins list```\n\n\n#### 4. 操作用户\n1. 默认有一个用户：guest，tags为：administrator\n> 官方命令文档：http://www.rabbitmq.com/man/rabbitmqctl.1.man.html\n2. 添加用户\n```# ./rabbitmqctl add_user <用户名> <用户密码>```\n> - 若要删除用户\n```# ./rabbimtctl delete_user <用户名>```\n\n3. 修改密码\n```# ./rabbitmqctl change_password <用户名> <用户新密码>```\n\n4. 给用户设置角色\n```# ./rabbitmqctl set_user_tags <用户名> administrator```\n\n5. 查看用户\n```./rabbitmqctl list_users```\n\n6. 查看用户权限\n```# ./rabbitmqctl list_permissions```\n\n7. 设置用户权限\n ```# ./rabbitmqctl set_permissions <用户名>  \'.\\*\' \'.\\*\' \'.*\'```\n> （三个“.”分别代表：配置、读、写权限）\n\n\n- 若想远程访问，则需修改配置：\n```# vi /etc/rabbitmq/rabbitmq.config（若没有，则新建）```\n> 添加：\n```\n[\n{rabbit, [{tcp_listeners, [5672]}, {loopback_users, [\"test\"]}]}\n].\n```\n\n- 启动管理插件\n> 在sbin目录下（与rabbitmqctl同一目录），输入命令：\n```# rabbitmq-plugins enable rabbitmq_management```\n然后重启rabbitmq即可，登录：http://[server-name]:15672/ 进行访问\n\n#### 5. Rabbit用户角色及权限控制\n* RabbitMQ的用户角色分类\n> none、management、policymaker、monitoring、administrator\n\n* RabbitMQ各类角色描述\n> * none\n>> 不能访问 management plugin\n>\n> * management\n>> 用户可以通过AMQP做的任何事外加：\n>>> * 列出自己可以通过AMQP登入的virtual hosts\n>>> * 查看自己的virtual hosts中的queues, exchanges 和 bindings\n>>> * 查看和关闭自己的channels 和 connections\n>>> * 查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。\n>\n> * policymaker\n>> management可以做的任何事外加：\n>>> * 查看、创建和删除自己的virtual hosts所属的policies和parameters\n>\n> * monitoring\n>> management可以做的任何事外加：\n>>> * 列出所有virtual hosts，包括他们不能登录的virtual hosts\n>>> * 查看其他用户的connections和channels\n>>> * 查看节点级别的数据如clustering和memory使用情况\n>>> * 查看真正的关于所有virtual hosts的全局的统计信息\n>\n> * administrator\n>> policymaker和monitoring可以做的任何事外加:\n>>> * 创建和删除virtual hosts\n>>> * 查看、创建和删除users\n>>> * 查看创建和删除permissions\n>>> * 关闭其他用户的connections\n\n* ps: rabbitmq概念详细介绍请参考地址\n> http://blog.csdn.net/whycold/article/details/41119807\n', '2', '0', '2017-06-15 14:31:39'), ('26', '1', '54', '【目录】\n\n[TOC]\n\n### centos-RabbitMQ集群配置\n\n- 文档撰写于：2016-01-29，涉及到版本问题就适时斟酌\n\n#### 序\n> 搭建的环境有：\n- centos7\n- rabbitmq3.6\n- 集群安装3个节点：\n>> - 1.1.1.1（node1）- 主节点\n>> - 1.1.1.2（node2）\n>> - 1.1.1.3（node3）\n\n\n#### 1. 安装\n> rpm安装\n>> 1. 下载，官方下载网站：http://www.rabbitmq.com/releases/rabbitmq-server/\n```# wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm```\n>> 2. 安装\n```# rpm -ivh rabbitmq-server-3.6.0-1.noarch.rpm```\n\n#### 2. 配置集群\n> * 1、在 node1/node2/node3 三个节点，开启 RabbitMQ 监控插件：\n```# rabbitmq-plugins enable rabbitmq_management```\n\n> * 2、分别修改三个节点下```/etc/hosts```文件\n```\n1.1.1.1 node1\n1.1.1.2 node2\n1.1.1.3 node3\n```\n\n> * 3、设置erlang cookie\n>> 将node1节点下将```/var/lib/rabbitmq/.erlang.cookie```文件复制到```node2```和```node3```节点下同一目录\n>>> 命令：```# scp node1:/var/lib/rabbitmq/.erlang.cookie /var/lib/rabbitmq```\n>>\n>> 复制到```node2```和```node3```下的cookie文件为```root```用户下，所以需更改用户与用户组到rabbitmq下\n>>> ```# chown rabbitmq:rabbitmq /var/lib/rabitmq/.erlang.cookie```\nps1: 该文件是需要先启动```rabbitmq-server```才会建立的\nps2: 该文件的权限为```400```，scp拷贝过去的会默认为400，若自己建的文件需更改权限为400\n\n> * 4、重启rabbitmq\n```\n# rabbitmqctl stop\n# rabbitmq-server -detached\n```\n\n> * 5、组成集群\n>> 将node2/node3与node1组成集群：\n>>> 在node2/node3节点下分别输入：\n```\n# rabbitmqctl stop_app\n# rabbitmqctl reset（删除之前配置的集群重新设置）\n# rabbitmqctl join_cluster rabbit@node1\n# rabbitmqctl start_app\n```\n如果要使用内存节点，则可以使用下面方法加入集群\n```# rabbitmqctl join_cluster --ram rabbit@node1```\n>>\n>> 查看集群状态\n```# rabbitmqctl cluster_status```\n\n> * 6、设置镜像队列策略\n>> 在任意一个节点上执行：\n```# rabbitmqctl set_policy ha-all \"^message\" \'{\"ha-mode\": \"all\"}\'```\n注意：\"^message\" 这个规则要根据自己修改，这个是指同步\"message\"开头的队列名称，我们配置时使用的应用于所有队列，所以表达式为\"^\n>>\n>> 将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态保持一直。\n\n> * 若添加集群配置时报错，如：\n```\nSegmentation fault\n```\n可能错误原因：防火墙未关闭，下面提供两种解决方案：\n>> ps：以下解决方案只需操作node1即可。\n>> - 解决方案一：关闭防火墙\n>>> centos7关闭防火墙：```# systemctl stop firewalld.service```\n若使用iptables则关闭iptables防火墙\n>> - 解决方案二：开放端口： 4369 / 25672，详见：http://www.rabbitmq.com/clustering.html\n>>> centos7开放端口方法：```# firewall-cmd --zone=public --add-port=端口号/tcp --permanent```\n若使用iptables则修改iptables配置文件：```# vi /etc/sysconf/iptables```\n\n', '2', '0', '2017-05-22 16:26:21'), ('27', '1', '55', '### spring mvc连接RabbitMQ\n\n#### config.properties 配置信息：\n```\nrabbitmq.queue.name=QUEUE_NAME\nrabbitmq.host=localhost1,localhost2\nrabbitmq.username=vanki\nrabbitmq.password=vanki\nrabbitmq.connection.max=3\n```\n\n#### 依赖类库\n```xml\n<!-- 消息机制 -->\n<dependency>\n    <groupId>com.rabbitmq</groupId>\n    <artifactId>amqp-client</artifactId>\n    <version>3.5.6</version>\n</dependency>\n```\n\n#### spring mvc配置\n- spring-rabbitmq.xml\n> spring 连接rabbitmq配置\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <rabbit:connection-factory id=\"connectionFactory\" username=\"${rabbitmq.username}\" password=\"${rabbitmq.password}\"\n                               addresses=\"${rabbitmq.host}\"\n                               channel-cache-size=\"25\"/>\n\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <rabbit:queue name=\"${rabbitmq.queue.name}\"/>\n\n    <rabbit:topic-exchange name=\"myExchange\">\n        <rabbit:bindings>\n            <rabbit:binding queue=\"${rabbitmq.queue.name}\" pattern=\"vanki.*\"/>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n    <rabbit:template id=\"amqpTemplate\" connection-factory=\"connectionFactory\"\n                     exchange=\"myExchange\" routing-key=\"vanki.routing\" queue=\"${rabbitmq.queue.name}\"/>\n\n    <bean id=\"listenerService\" class=\"cn.lofficiel.service.impl.mq.ListenerServiceImpl\"/>\n</beans>\n```\n- spring-rabbitmq-consumer.xml\n> 消费者\n\n```XML\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <rabbit:connection-factory id=\"connectionFactory\" username=\"${rabbitmq.username}\" password=\"${rabbitmq.password}\"\n                               addresses=\"${rabbitmq.host}\"\n                               channel-cache-size=\"25\"/>\n\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <rabbit:queue name=\"${rabbitmq.queue.name}\"/>\n\n    <rabbit:topic-exchange name=\"myExchange\">\n        <rabbit:bindings>\n            <rabbit:binding queue=\"${rabbitmq.queue.name}\" pattern=\"vanki.*\"/>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n    <rabbit:template id=\"amqpTemplate\" connection-factory=\"connectionFactory\"\n                     exchange=\"myExchange\" routing-key=\"vanki.routing\" queue=\"${rabbitmq.queue.name}\"/>\n\n    <!-- 消息监听 -->\n    <!-- prefetch: 一次获取消息数量, concurrency: 消费者数量, max-concurrency: 消费者最大数, 需大于或等于消费者数 -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" prefetch=\"${rabbitmq.consumer.num}\"\n                               concurrency=\"${rabbitmq.consumer.num}\" max-concurrency=\"25\">\n        <rabbit:listener ref=\"listenerService\" method=\"listen\" queue-names=\"${rabbitmq.queue.name}\"/>\n    </rabbit:listener-container>\n\n    <bean id=\"listenerService\" class=\"cn.zoufanqi.service.impl.mq.ListenerServiceImpl\"/>\n</beans>\n```\n\n### java发送消息代码\n```java\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.MessageProperties;\npublic class RabbitmqSend {\n	private static final String RABBITMQ_QUEUE_NAME = \"QUEUE_NAME\";\n	public static void sendMsg(String imagePath) throws Exception {\n		Connection connection = RabbitmqConn.getConn();\n        Channel channel = connection.createChannel();\n        \n        // 指定队列持久化\n        channel.queueDeclare(RABBITMQ_QUEUE_NAME, true, false, false, null);\n        // 指定消息持久化\n        channel.basicPublish(\"\", RABBITMQ_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, imagePath.getBytes());\n        \n        channel.close();\n        connection.close();\n	}\n}\n```\n\n### java接收消息代码\n```java\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.MessageProperties;\npublic class RabbitmqSend {\n	private static final String RABBITMQ_QUEUE_NAME = \"QUEUE_NAME\";\n	public static void sendMsg(String imagePath) throws Exception {\n		Connection connection = RabbitmqConn.getConn();\n        Channel channel = connection.createChannel();\n        \n        // 指定队列持久化\n        channel.queueDeclare(RABBITMQ_QUEUE_NAME, true, false, false, null);\n        // 指定消息持久化\n        channel.basicPublish(\"\", RABBITMQ_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, imagePath.getBytes());\n        \n        channel.close();\n        connection.close();\n	}\n}\n```\n', '2', '0', '2017-06-15 14:31:36'), ('28', '1', '56', '【目录】\n\n[TOC]\n\n### centos-redis集群配置（单服务器）\n\n文档撰写时间：2016-02-18，涉及到的版本问题就适时斟酌\n\n#### 序\n- redis集群配置环境：\n> - 系统：centos7\n> - redis版本：3.0.7（2016-2-18最新稳定版）\n> - ruby版本：ruby 2.0.0p598 (2014-11-13) [x86_64-linux]\n> - gem版本：2.0.14\n> - gem redis 版本：3.2.2\n\n#### 1. 安装redis\n* 执行以下步骤即可：\n```\n# wget http://download.redis.io/releases/redis-3.0.7.tar.gz\n# tar xzf redis-3.0.7.tar.gz\n# cd redis-3.0.7\n# make #如果报错用命令：make MALLOC=libc 或 安装jemalloc\n```\n> 查找最新版redis与官方安装详情请看：http://redis.io/download\n\n\n\n#### 2. 配置集群\n* ps：官方文档配置集群提供了两种方法：\n> - 通过工具配置\n> - 手动配置\n>\n详情请参考：http://redis.io/topics/cluster-tutorial\n* ps2：集群必须确保节点存活数在半数以上，否则集群无法工作\n\n\n* 方法一：工具配置集群\n```\n# cd redis-3.0.7/utils/create-cluster	-- 创建集群的工具目录\n# ./create-cluster start\n# ./create-cluster create\n```\nps：若不报错，则创建成功！\n> - 关闭集群：```# ./create-cluster stop```\n>\n> - 优缺点：\n>> 优点：方便、简单、快速\n>> 缺点：只能用于单服务器，只能创建一个3主3从的集群，端口号默认从30001开始\n\n* 方法二：手动配置\n> ps：创建6个节点，3主3从，端口分别为：7000、7001、7002、7003、7004、7005\n> 1. 创建存放节点信息目录\n```\n# mkdir custer-redis #集群所有节点父目录\n# cd custer-redis\n#mkdir 7000 #先创建单一节点目录，以节点端口号命名，等下配置好这个后再copy\n```\n> 2. 拷贝两个文件到刚新建目录7000\n>> 文件一：```redis-3.0.7/redis.conf```，用于集群配置\n>> 文件二：```redis-3.0.7/src/redis-server```，用于启动节点\n> 3. 编辑刚拷贝的文件一（redis.conf），更改配置为：\n```\nport 7000    #启动端口为7000\ncluster-enabled yes    #开启集群\ncluster-config-file nodes.conf    #集群配置文件，首次启动节点时在当前目录自动生成\ncluster-node-timeout 5000    #请求超时时间，5秒\nappendonly yes    #aof日志开启，每次写操作都会记录一条日志\n```\nps：vi编辑在非插入模式可用\"```/``` + ```要查找的字符串```查找信息，按```n```查找下一个\n> 4. 将7000文件夹及子文件分别拷贝至7001、7002、7003、7004、7005，之后分别更改redis.conf文件中的端口即可，例：\n```\n# cp -rf 7000 7001\n```\n> 5. 依次启动各个节点redis服务，例：\n```\n# cd 7000\n# ./redis-server ./redis.conf &\n```\n可以看到生成了appendonly.aof nodes.conf文件\n```# ps -ef | grep redis```查看是否启动成功\n> 6. 安装ruby与gem\n```\n# yum -y install ruby ruby-devel rubygems rpm-build\n# yum install gem\n```\n> 7. 安装redis gem\n```\n# gem install redis\n```\nps：若安装不成功，出现类似错误：\n```\nERROR:  Could not find a valid gem \'rails\' (>= 0), here is why:\n          Unable to download data from https://rubygems.org/ - Errno:: ETIMEDOUT: Connection timed out - connect(2) for \"s3.amazonaws.com\" port 443 (https://api.rubygems.org/latest_specs.4.8.gz)\n```\n尝试以下方法解决：\n```\n# sudo gem sources -r https://rubygems.org\n# sudo gem sources -a http://rubygems.org\n成功下载后更改回来：\n# sudo gem sources -r http://rubygems.org\n# sudo gem sources -a https://rubygems.org\n```\n> 8. 创建集群\n```\n# cd redis-3.0.7/src\n# ./redis-trib.rb create - -replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005\n```\nps：上列命令释义：\n>>  --replicas 1  表示：自动为每一个master节点分配一个slave节点    \n上面有6个节点，程序会按照一定规则生成 3个master（主）3个slave(从)\n\n至此，集群创建完毕！\n\n\n#### 3. 集群常用命令\n* 查看集群信息\n```# redis-3.0.7/src/redis-cli -p <集群任一节点的端口号> cluster nodes```\n如：\n```# redis-3.0.7/src/redis-cli -p 7000 cluster nodes```\nps：若是手动配置，则查看任一节点```node.conf```文件内容也可查看集群信息，内容是一致的\n\n* 查看集群执行情况：\n```# ps -ef | grep redis```\n\n* 连接某一节点客户端\n```# redis-3.0.7/src/redis-cli -c -p <端口号>```\n\n* 关闭集群\n```# pkill -9 redis```\n\n* 关闭某一节点\n```# kill -9 <PID>```\n\n', '2', '0', '2017-05-22 17:27:26'), ('29', '1', '58', '【目录】\n\n[TOC]\n\n### centos-Hadoop1.2.1集群搭建\n\n#### 序\n1. 服务器节点:\n> - node1(nameNode)\n> - node2(secondaryNameNode, dataNode)\n> - node3(dataNode)\n2. 依赖\n> - ssh\n> - jdk\n> - hadoop(1.2.1)\n\nps: 注意防火墙\n\n#### 1. 设置ssh免密码登录\n> 1. 在主节点服务器生成ssh的key\n> 2. 把公钥添加到文件：```authorized_keys```（没有则添加）\n> 3. 把三个文件(私钥,公钥,验证文件)拷贝到其它节点```~/.ssh```目录，确保这三个文件所有节点都一致\n> ps: 所有操作均在目录: ```~/.ssh```中操作\n```\n# ssh-keygen -t dsa -P \'\' -f ~/.ssh/id_dsa\n# cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys\n# ssh localhost -- 测试是否连接本地需要密码\n```\n>> 若不能成功连接，可能会提示```id_dsa```文件权限太大。这时候需要更改该文件权限为```600```\n>> ```\n# chmod 600 id_dsa\n```\n\n#### 2. 配置hdfs\nps: hadoop安装目录: ```/usr/local```\n> 1. 配置文件配置\n>> 1. 配置文件: ```conf/hadoop-env.sh```(配置所有节点)\n>>> 添加jdk目录, JAVA_HOME\n>> 2. 配置文件: ```conf/core-site.xml```(配置所有节点)\nps: 配置文件中的所有参数均可在: ```docs/core-default.html```中查看\n```xml\n<!-- namenode节点信息 -->\n<property>\n	<name>fs.default.name</name>\n	<value>hdfs://node1:9000</value>\n</property>\n<!-- 该目录用于存放nameNode信息. 默认存放于/tmp, 而tmp在重启系统后会自动清空 -->\n<property>\n	<name>hadoop.tmp.dir</name>\n	<value>/opt/hadoop</value>\n</property>\n```\n>> 3. 配置文件: ```conf/hdfs-site.xml```(配置所有节点)\nps: 配置文件中所有参数均可在: ```doc/hdfs-default.html```中查看\n>> ```xml\n<!-- 更改dataNode副本数量, 默认为3 -->\n<property>\n	<name>dfs.replication</name>\n	<value>2</value>\n</property>\n```\n>> 4. 添加sencondaryNameNode(配置所有节点)\n```\n# vi conf/masters\n```\n>>> 添加:\n```\nnode2\nnode3\n```\n>> 5. 添加dataNode(配置主节点即可, DataNode配置了也没关系)\n```\n# vi conf/slaves\n```\n>>> 添加:\n```\nnode2\n```\n> 2. 拷贝配置好的hadoop到各个节点\n> 3. 初始化（在配置的NameNode下执行）\n> ps: 只第一次配置集群时执行, 就好比重装系统第一格式化分区一样\n```\n# bin/hadoop namenode start-dfs.sh\n```\n> 4. 启动hdfs（在配置的NameNode下执行）\n```\n# bin/start-dfs.sh\n```\n> 5. 测试是否成功\n>> 1. 用命令: jps, 查看各各节点, 能看到配置的NameNode, SecondaryNameNode, DataNode信息即可\n>> 2. 浏览器访问: ```http://node1:50070``` 可查看hdfs详细信息(nameNode节点)\n\n#### 3. 配置MapReduce\nps: 有些公共配置在第2步中\n> 1. 配置配置文件: ```conf/mapred-site.xml```\n>> ```xml\n<!-- 任务分配者(测试:只能配置在nameNode节点, 其它节点配置就不成功)(配置所有节点) -->\n<property>\n	<name>mapred.job.tracker</name>\n	<value>node1:9001</value>\n</property>\n```\n> 2. 启动\n>> 因为已经配置好hdfs, 所有直接启动 bin/start-all.xml 即可\n> 3. 测试是否成功\n>> 1. 在各节点执行\n```\n# jps\n```\na. 在配置好的MapReduce会有JobTracker\nb. 在所有DataNode下会有TaskTracker\n>> 2. 浏览器访问:``` http://node1:50030``` 可查看MapReduce任务分配详细信息\n4. 完成!!!', '2', '0', '2017-06-15 14:31:33'), ('30', '1', '60', '#### tomcat GET请求数据乱码\n> 在```tomcat/conf/server.xml```更改信息：\n```xml\n<Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\"　redirectPort=\"8443\" URIEncoding=\"UTF-8\" />\n<Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\"  URIEncoding=\"UTF-8\"/>\n```', '2', '0', '2017-05-22 18:26:26'), ('31', '1', '61', '\n[TOC]\n\nImageMagicK是本地图片处理服务。[Linux服务器安装](http://www.qiqinote.com/note/9.html)\n\n#### maven依赖\n```xml\n<dependency>\n	<groupId>org.im4java</groupId>\n	<artifactId>im4java</artifactId>\n</dependency>\n```\n\n#### ImageMagickUtil工具类\n```java\npackage com.zoufanqi.utils;\n\nimport org.im4java.core.ConvertCmd;\nimport org.im4java.core.IMOperation;\nimport org.im4java.core.IdentifyCmd;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * 图片缩放、裁切工具类\n *\n * @author vanki\n * @project_name lofficiel-rabbitmq 2015年12月14日 上午9:45:24\n */\npublic class ImageMagickUtil {\n\n    /**\n     * 获得图片文件大小\n     *\n     * @param imagePath 文件路径\n     *\n     * @return 文件大小\n     */\n    public static int getSize(String imagePath) {\n        int size = 0;\n        FileInputStream inputStream = null;\n        try {\n            inputStream = new FileInputStream(imagePath);\n            size = inputStream.available();\n            inputStream.close();\n            inputStream = null;\n        } catch (Exception e) {\n            size = 0;\n        } finally {\n            // 可能异常为关闭输入流,所以需要关闭输入流\n            if (null != inputStream) {\n                try {\n                    inputStream.close();\n                } catch (IOException e) {\n                }\n                inputStream = null;\n            }\n        }\n        return size;\n    }\n\n    /**\n     * 根据坐标裁剪图片\n     *\n     * @param srcPath  要裁剪图片的路径\n     * @param destPath 裁剪图片后的路径\n     * @param x_start  起始横坐标\n     * @param y_start  起始纵坐标\n     * @param x_end    结束横坐标\n     * @param y_end    结束纵坐标\n     */\n\n    public static void cutImage(String srcPath, String destPath, int x_start,\n                                int y_start, int x_end, int y_end) throws Exception {\n        int width = x_end - x_start;\n        int height = y_end - y_start;\n        IMOperation op = new IMOperation();\n        op.addImage(srcPath);\n        /**\n         * width： 裁剪的宽度 height： 裁剪的高度 x： 裁剪的横坐标 y： 裁剪的挫坐标\n         */\n        op.crop(width, height, x_start, y_start);\n        op.addImage(destPath);\n        ConvertCmd convert = new ConvertCmd();\n        convert.run(op);\n    }\n\n    /**\n     * 根据尺寸等比缩放图片\n     *\n     * @param width    缩放后的图片宽度\n     * @param height   缩放后的图片高度\n     * @param srcPath  源图片路径\n     * @param destPath 缩放后图片的路径\n     */\n    public static void resize(int width, int height, String srcPath,\n                              String destPath) throws Exception {\n        IMOperation op = new IMOperation();\n        op.addImage(srcPath);\n        op.resize(width, height);\n        op.addImage(destPath);\n        ConvertCmd convert = new ConvertCmd();\n        convert.run(op);\n    }\n\n    public static void main(String[] args) throws Exception {\n        // /Users/vanki/Documents/company/lofficiel/data/1111.jpg\n        //resize_width(253, \"/Users/vanki/Documents/company/lofficiel/data/16.jpg\", \"/Users/vanki/Documents/company/lofficiel/data/16_1.jpg\");\n    }\n\n    /**\n     * 根据宽度缩放图片\n     *\n     * @param width    缩放后的图片宽度\n     * @param srcPath  源图片路径\n     * @param destPath 缩放后图片的路径\n     */\n    public static void resizeWidth(int width, String srcPath, String destPath)\n            throws Exception {\n        IMOperation op = new IMOperation();\n        op.addImage(srcPath);\n        op.resize(width, null);\n        op.addImage(destPath);\n        ConvertCmd convert = new ConvertCmd();\n        convert.run(op);\n    }\n\n    /**\n     * 根据高度缩放图片\n     *\n     * @param height   缩放后的图片高度\n     * @param srcPath  源图片路径\n     * @param destPath 缩放后图片的路径\n     */\n    public static void resizeHeight(int height, String srcPath, String destPath)\n            throws Exception {\n        IMOperation op = new IMOperation();\n        op.addImage(srcPath);\n        op.resize(null, height);\n        op.addImage(destPath);\n        ConvertCmd convert = new ConvertCmd();\n        convert.run(op);\n    }\n\n    /**\n     * 给图片加水印\n     *\n     * @param srcPath\n     *            源图片路径\n     */\n	/*\n	 * public static void addImgText(String srcPath, String destPath) throws\n	 * Exception { IMOperation op = new IMOperation();\n	 * op.font(\"宋体\").gravity(\"southeast\").pointsize(18).fill(\"#BCBFC8\")\n	 * .draw(\"text 5,5 我是水印\"); op.addImage(); op.addImage(); ConvertCmd convert\n	 * = new ConvertCmd(); convert.run(op, srcPath, destPath); }\n	 */\n}\n\n}\n```', '2', '0', '2017-05-22 18:32:40'), ('32', '1', '62', '#### mac下更新mysql密码\n```\n# sudo mysqld_safe –skip-grant-tables &\n```\n然后就没密码了！', '2', '0', '2017-05-22 19:05:54'), ('33', '1', '63', '[TOC]\n\n### mysql添加访问用户\n\n#### 初始化root密码\n```\n# /usr/bin/mysql_secure_installation\n\n建议root用户只允许本地访问\n```\n\n#### 添加访问用户\n1. 登录mysql\n```# mysql -hlocalhost -uroot -p```\n\n2. 添加外网用户\n- 1. 添加访问用户\n```\n所有：mysql> grant all on *.* to <用户名>@\'10.10.10.%\' identified by \'密码\';\n只有查询：mysql> grant select on *.* to <用户名>@\'%\' identified by \'密码\';\n10.10.10.% -- 表示该用户被访问的IP\n% -- 表示所有\n```\n- 2. 刷新\n```\nmysql> flush privileges;\n```\n\n#### 更新mysql用户密码\n1. ```mysql> use mysql```\n2. ```mysql> update user set Password=PASSWORD(\'新密码\') WHERE host=\'10.10.10.%\' and ...;（SQL查询条件）```\n3. ```mysql> flush privileges;```\n\n', '2', '0', '2017-05-22 19:17:01'), ('34', '1018', '64', '> **2017-05-24 14:46:24 星期三**\n\n------------\n\n\n\n##### CSS 用于控制网页的样式和布局。\n##### CSS3 是最新的 CSS 标准。\n\n\n## CSS3 被划分为模块。\n> **其中最重要的 CSS3 模块包括：**\n> ><a href=\'\'>选择器</a>\n<a href=\'\'>盒模型</a>\n<a href=\'\'>背景</a>和<a href=\'\'>边框</a>\n<a href=\'\'>文字特效</a>\n<a href=\'\'>2D/3D转换</a>\n<a href=\'\'>动画</a>\n<a href=\'\'>多列布局</a>\n<a href=\'\'>用户界面</a>', '2', '0', '2017-06-15 14:31:30'), ('35', '1018', '77', '> 2017-05-24 14:53:44 星期三\n\n------------\n\n\n#### 之前所用到过的Jquery插件，整理并记录下来，方便以后的使用：\n1. <a href=\"http://www.qiqinote.com:8181/note/78.html\">jQuery插件版日历签到</a>', '2', '0', '2017-06-15 14:31:28'), ('36', '1018', '78', '> **2017-05-24 14:48:49 星期三**\n\n------------\n\n\n# jQuery插件版日历签到\n### 版本一（使用方法）\n1. 在页面中引入样式文件style.css，jquery.min.js和签到js主文件main.js。\n```html\n<link rel=\"stylesheet\" href=\"css/style.css\">\n<script src=\"js/jquery.min.js\"></script>\n<script src=\"js/main.js\"></script> \n```\n2. 签到界面的HTML结如下：\n```html\n<div class=\"qiandao-warp\">\n    <div class=\"qiandap-box\">\n        <div class=\"qiandao-con clear\">\n            <div class=\"qiandao-left\">\n                <div class=\"qiandao-left-top clear\">\n                    <div class=\"current-date\">2016年1月6日</div>\n                    <div class=\"qiandao-history qiandao-tran qiandao-radius\" id=\"js-qiandao-history\">我的签到</div>\n                </div>\n                <div class=\"qiandao-main\" id=\"js-qiandao-main\">\n                    <ul class=\"qiandao-list\" id=\"js-qiandao-list\">\n                    </ul>\n                </div>\n            </div>\n            <div class=\"qiandao-right\">\n                <div class=\"qiandao-top\">\n                    <div class=\"just-qiandao qiandao-sprits\" id=\"js-just-qiandao\">\n                    </div>\n                    <p class=\"qiandao-notic\">今日已领<span>0.1</span>元，请明日继续签到</p>\n                </div>\n                <div class=\"qiandao-bottom\">\n                    <div class=\"qiandao-rule-list\">\n                        <h4>签到规则</h4>\n                        <p>首次签到获得0.05元现金奖励</p>\n                        <p>连续签到每天增加0.01元现金奖励</p>\n                        <p>连续签到16天及以上每天获得0.2元现金奖励</p>\n                    </div>\n                    <div class=\"qiandao-rule-list\">\n                        <h4>其他说明</h4>\n                        <p>如果中间有一天间断未签到的，重先开始计算连续签到时间。</p>\n                        <p>连续签到获得奖励后分享到QQ空间、微信朋友圈后再获得一次奖励，每天只限分享一次。</p>\n                        <p>获得的奖励不能直接提现，只能投资后转让变现。</p>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>    \n```\n3. 展示我的签到的弹出层界面的HTML结构如下：\n```html\n<div class=\"qiandao-layer qiandao-history-layer\">\n    <div class=\"qiandao-layer-con qiandao-radius\">\n        <a href=\"javascript:;\" class=\"close-qiandao-layer qiandao-sprits\"></a>\n        <ul class=\"qiandao-history-inf clear\">\n            <li>\n                <p>连续签到</p>\n                <h4>5</h4>\n            </li>\n            <li>\n                <p>本月签到</p>\n                <h4>17</h4>\n            </li>\n            <li>\n                <p>总共签到数</p>\n                <h4>28</h4>\n            </li>\n            <li>\n                <p>签到累计奖励</p>\n                <h4>30</h4>\n            </li>\n        </ul>\n        <div class=\"qiandao-history-table\">\n            <table>\n                <thead>\n                    <tr>\n                        <th>签到日期</th>\n                        <th>奖励</th>\n                        <th>说明</th>\n                    </tr>\n                </thead>\n                <table>\n                    <tr>\n                        <td>2016-1-6 14:23:45</td>\n                        <td>0.20</td>\n                        <td>连续签到19天奖励</td>\n                    </tr>\n                    <tr>\n                        <td>2016-1-6 14:23:45</td>\n                        <td>0.20</td>\n                        <td>分享奖励</td>\n                    </tr>\n                    <tr>\n                        <td>2016-1-6 14:23:45</td>\n                        <td>0.20</td>\n                        <td>连续签到19天奖励</td>\n                    </tr>\n                    <tr>\n                        <td>2016-1-6 14:23:45</td>\n                        <td>0.20</td>\n                        <td>连续签到19天奖励</td>\n                    </tr>\n                    <tr>\n                        <td>2016-1-6 14:23:45</td>\n                        <td>0.20</td>\n                        <td>连续签到19天奖励</td>\n                    </tr>\n                    <tr>\n                        <td>2016-1-6 14:23:45</td>\n                        <td>0.20</td>\n                        <td>连续签到19天奖励</td>\n                    </tr>\n                    <tr>\n                        <td>2016-1-6 14:23:45</td>\n                        <td>0.20</td>\n                        <td>连续签到19天奖励</td>\n                    </tr>\n                    <tr>\n                        <td>2016-1-6 14:23:45</td>\n                        <td>0.20</td>\n                        <td>连续签到19天奖励</td>\n                    </tr>\n                </table>\n            </table>\n        </div>\n    </div>\n    <div class=\"qiandao-layer-bg\"></div>\n</div> \n```\n4. 点击签到后的弹出层的HTML结构如下：\n```html\n<div class=\"qiandao-layer qiandao-active\">\n    <div class=\"qiandao-layer-con qiandao-radius\">\n        <a href=\"javascript:;\" class=\"close-qiandao-layer qiandao-sprits\"></a>\n        <div class=\"yiqiandao clear\">\n            <div class=\"yiqiandao-icon qiandao-sprits\"></div>您已连续签到<span>2</span>天\n        </div>\n        <div class=\"qiandao-jiangli qiandao-sprits\">\n            <span class=\"qiandao-jiangli-num\">0.55<em>元</em></span>\n        </div>\n        <a href=\"#\" class=\"qiandao-share qiandao-tran\">分享获取双倍收益</a>\n    </div>\n    <div class=\"qiandao-layer-bg\"></div>\n</div> \n```\n5.main.js\n```javascript\nvar signFun = function() {\n\n        var dateArray = [1, 2, 4, 6]；\n        var $dateBox = $(\"#js-qiandao-list\"),\n            $currentDate = $(\".current-date\"),\n            $qiandaoBnt = $(\"#js-just-qiandao\"),\n            _html = \'\',\n            _handle = true,\n            myDate = new Date();\n        $currentDate.text(myDate.getFullYear() + \'年\' + parseInt(myDate.getMonth() + 1) + \'月\' + myDate.getDate() + \'日\');\n\n        var monthFirst = new Date(myDate.getFullYear(), parseInt(myDate.getMonth()), 1).getDay();\n\n        var d = new Date(myDate.getFullYear(), parseInt(myDate.getMonth() + 1), 0);\n        var totalDay = d.getDate(); \n\n        for (var i = 0; i < 42; i++) {\n            _html += \' <li><div class=\"qiandao-icon\"></div></li>\'\n        }\n        $dateBox.html(_html) \n\n        var $dateLi = $dateBox.find(\"li\");\n        for (var i = 0; i < totalDay; i++) {\n            $dateLi.eq(i + monthFirst).addClass(\"date\" + parseInt(i + 1));\n            for (var j = 0; j < dateArray.length; j++) {\n                if (i == dateArray[j]) {\n                    $dateLi.eq(i + monthFirst).addClass(\"qiandao\");\n                }\n            }\n        } \n\n        $(\".date\" + myDate.getDate()).addClass(\'able-qiandao\');\n\n        $dateBox.on(\"click\", \"li\", function() {\n                if ($(this).hasClass(\'able-qiandao\') && _handle) {\n                    $(this).addClass(\'qiandao\');\n                    qiandaoFun();\n                }\n            }) \n\n        $qiandaoBnt.on(\"click\", function() {\n            if (_handle) {\n                qiandaoFun();\n            }\n        }); \n\n        function qiandaoFun() {\n            $qiandaoBnt.addClass(\'actived\');\n            openLayer(\"qiandao-active\", qianDao);\n            _handle = false;\n        }\n\n        function qianDao() {\n            $(\".date\" + myDate.getDate()).addClass(\'qiandao\');\n        }\n    }();\n\n    function openLayer(a, Fun) {\n        $(\'.\' + a).fadeIn(Fun)\n    }\n\n    var closeLayer = function() {\n            $(\"body\").on(\"click\", \".close-qiandao-layer\", function() {\n                $(this).parents(\".qiandao-layer\").fadeOut()\n            })\n        }() \n\n    $(\"#js-qiandao-history\").on(\"click\", function() {\n        openLayer(\"qiandao-history-layer\", myFun);\n\n        function myFun() {\n            console.log(1)\n        } \n    })\n```\n\n\n### 版本二\n```html\n<!DOCTYPE html>\n<html>\n<head>\n	<meta charset=\"utf-8\">\n	<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n	<title>签到</title>\n	<style>\n	*{margin:0;padding:0;font:14px/1.8 \"Helvetica Neue\",\"microsoft yahei\";}\n	ul,li{list-style:none;}\n	body{background: #fff; }\n	.checkin{margin: auto auto auto auto; }\n	.clear {clear:both; height:0; overflow:hidden; display:block; line-height:0}\n	.clearfix:after {clear:both;font-size:0; height:0; display:block; visibility:hidden; content:\" \"; line-height:0}\n	.clearfix {zoom:1}/* for IE6 IE7 */\n	.title{height: 36px;line-height: 36px;font-size: 16px;margin-bottom: 10px;}\n	.title p{float: left;width: 80%;height: 36px;line-height: 36px;font-size: 16px;}\n	.title a{display: inline-block;width: 20%;height: 36px;line-height: 36px;text-align: center;background: #42941a;border-radius: 5px;color: #fff;text-decoration: none;font-size: 16px;}\n	.checkin li{background: #fee684; float: left;padding: 10px;text-align: center;}\n\n	li.able-qiandao{background: #e9c530; }\n	li.checked{background:#fee684 url(http://i2.piimg.com/508767/a9576b09fc014d6e.png) no-repeat center;}\n	.mask{ width: 100%;height: 100%;position: absolute;top: 0;left: 0; background-color: rgba(0,0,0,0.55);visibility: hidden;transition: all 0.25s ease}\n	.modal{background:#fff;width: 450px;height: 400px;border-radius: 10px;position: absolute;margin-top: -200px;margin-left:-225px;left: 50%;top: 50%;border:5px solid #42941a;box-sizing:border-box;overflow: hidden;transform: translateY(-200%);transition: all 0.25s ease}\n	a.closeBtn{display: block;position: absolute;right: 10px;top: 5px;font-family: \'simsun\';font-size: 18px;text-decoration: none;font-weight: bolder;color: #333}\n	.title_h1{text-align: center;font-size: 40px;font-weight: normal;padding-top: 80px;display: block;width: 100%}\n	.title_h1 span{display: inline-block;width: 40px;height: 40px;border-radius: 100%;background: #42941a;color: #fff;position: relative;float: left;margin-left: 30%;margin-top: 7px;}\n	.title_h1 span::before{width: 10px;height: 2px;background: #fff;position: absolute;left: 8px;top: 23px;display: block;line-height: 0;font-size: 0;content: \"\"; transform: rotate(52deg);}\n	.title_h1 span::after{width: 24px;height: 2px;background: #fff;position: absolute;left: 12px;top: 20px;display: block;line-height: 0;font-size: 0;content: \"\";transform: rotate(-45deg);}\n	.title_h1 em{display: inline-block;font-size: 30px;float: left;margin-left: 10px;}\n	.title_h1 i{display: inline-block;font-size: 16px;float: left;margin: 14px 0 0 10px;}\n	.title_h2{text-align: center;font-size: 16px;display: block;padding-top: 20px;}\n	.title_h2 span{font-size: 36px;color: #b25d06;}\n	.trf{visibility: visible;}\n	.trf .modal{transform: translateY(0);}\n	</style>	\n	<script src=\"http://apps.bdimg.com/libs/jquery/1.10.1/jquery.min.js\"></script>        \n	 \n</head>\n<body>\n	<div class=\"checkin\">\n		\n	</div>\n	<div class=\"mask\">\n		<div class=\"modal\">\n			<a href=\"#\" class=\"closeBtn\">×</a>\n			<h1 class=\"title_h1 clearfix\"><span></span><em>已签到</em> <i>您已签到2天</i></h1>\n			<h2 class=\"title_h2\">您获得现金<span>0.88元</span></h2>\n		</div>\n	</div>\n	<script>\n	;\n	(function($) {\n		var Checkin = function(ele, options) {\n			this.ele = ele;\n			this.opt = options;\n			this.defaults = {\n				width: 452,\n				height: \'auto\',\n				background: \'#f90\',\n				radius: 10,\n				color: \'#fff\',\n				padding: 10,\n				dateArray: [1, 2, 4, 6], // 假设已签到的天数+1\n			};\n			this.obj = $.extend({}, this.defaults, this.opt);\n		}\n		Checkin.prototype.init = function() {\n			var _self = this.ele,\n				html = \'\',\n				myDate = new Date(),\n				year = myDate.getFullYear(),\n				month = myDate.getMonth(),\n				day = myDate.getDate(),\n				weekText = [\'日\', \'一\', \'二\', \'三\', \'四\', \'五\', \'六\'];\n			_self.css({\n				width: this.obj.width + \'px\',\n				height: this.obj.height,\n				background: this.obj.background,\n				borderRadius: this.obj.radius,\n				color: this.obj.color,\n				padding: this.obj.padding\n			}).append(\"<div class=\'title\'><p>\" + year + \'年\' + (month + 1) + \'月\' + day + \'日\' + \"</p><a class=\\\'checkBtn\\\' href=\\\"javascript:;\\\">签到</a></div>\");\n			$(\"<ul class=\'week clearfix\'></ul><ul class=\'calendarList clearfix\'></ul>\").appendTo(_self);\n			for (var i = 0; i < 7; i++) {\n				_self.find(\".week\").append(\"<li>\" + weekText[i] + \"</li>\")\n			};\n			for (var i = 0; i < 42; i++) {\n				html += \"<li></li>\"\n			};\n			_self.find(\".calendarList\").append(html);\n			var $li = _self.find(\".calendarList\").find(\"li\");\n			_self.find(\".week li\").css({\n				width: (_self.width() / 7) + \'px\',\n				height: 50 + \'px\',\n				borderRight: \'1px solid #f90\',\n				boxSizing: \'border-box\',\n				background: \'#b25d06\'\n			});\n			$li.css({\n				width: (_self.width() / 7) + \'px\',\n				height: 50 + \'px\',\n				borderRight: \'1px solid #f90\',\n				borderBottom: \'1px solid #f90\',\n				boxSizing: \'border-box\',\n				color: \"#b25d06\"\n			});\n			_self.find(\".calendarList\").find(\"li:nth-child(7n)\").css(\'borderRight\', \'none\');\n			_self.find(\".week li:nth-child(7n)\").css(\'borderRight\', \'none\');\n			var monthFirst = new Date(year, month, 1).getDay();\n			var d = new Date(year, (month + 1), 0)\n			var totalDay = d.getDate(); //获取当前月的天数\n			for (var i = 0; i < totalDay; i++) {\n				$li.eq(i + monthFirst).html(i + 1);\n				$li.eq(i + monthFirst).addClass(\'data\' + (i + 1))\n				if (isArray(this.obj.dateArray)) {\n					for (var j = 0; j < this.obj.dateArray.length; j++) {\n						if (i == this.obj.dateArray[j]) {\n							// 假设已经签到的\n							$li.eq(i + monthFirst).addClass(\'checked\');\n						}\n					}\n				}\n			}\n			//$li.eq(monthFirst+day-1).css(\'background\',\'#f7ca8e\')\n			_self.find($(\".data\" + day)).addClass(\'able-qiandao\');\n		}\n		var isChecked = false;\n		Checkin.prototype.events = function() {\n			var _self = this.ele;\n			var $li = _self.find(\".calendarList\").find(\"li\");\n			$li.on(\'click\', function(event) {\n				event.preventDefault();\n				/* Act on the event */\n				if ($(this).hasClass(\'able-qiandao\')) {\n					$(this).addClass(\'checked\');\n					modal(_self);\n					isChecked = true;\n				}\n			});\n			var checkBtn = _self.find(\".checkBtn\");\n			checkBtn.click(function(event) {\n				modal(_self);\n				_self.find(\'.able-qiandao\').addClass(\'checked\');\n				isChecked = true;\n			});\n		}\n		var modal = function(e) {\n			var mask = e.parents().find(\".mask\");\n			var close = e.parents().find(\".closeBtn\");\n			if (mask && !isChecked) {\n				mask.addClass(\'trf\');\n			} else {\n				return\n			};\n			close.click(function(event) {\n				event.preventDefault();\n				mask.removeClass(\'trf\')\n			});\n			e.parents().find(\'.checkBtn\').text(\"已签到\");\n		}\n		$.fn.Checkin = function(options) {\n			var checkin = new Checkin(this, options);\n			var obj = [checkin.init(), checkin.events()]\n			return obj\n		}\n		var isArray = function(arg) {\n			return Object.prototype.toString.call(arg) === \'[object Array]\';\n		};\n	})(jQuery);\n	// 插件调用\n	$(\".checkin\").Checkin();\n	// 元素居中显示，与插件无关，根本自己需要修改；\n	$(\".checkin\").css(\'marginTop\',parseInt(($(window).innerHeight()-$(\".checkin\").outerHeight())/2)+\'px\');\n	</script>\n</body>\n</html>\n```\n\n', '2', '0', '2017-06-15 14:31:25'), ('37', '1005', '79', '', '2', '0', '2017-06-15 14:31:22'), ('38', '1005', '80', '[TOC]\n\n# mongodb简要介绍\n\nMongoDB是时下流行的NoSql数据库, 它的存储方式是文档式存储，并不是key-value形式。\n\n![](http://img.qiqinote.com/2017/6/23/28956a0ecea24cc481f094c1c3b3c58b.png)\n\nMongodb(M)表示主节点，Mongodb(S)表示备节点，Mongodb(A)表示仲裁节点。主备节点存储数据，仲裁节点不存储数据。客户端同时连接主节点与备节点，不连接仲裁节点。\n       默认设置下，主节点提供所有增删查改服务，备节点不提供任何服务。但是可以通过设置使备节点提供查询服务，这样就可以减少主节点的压力，当客户端进行数据查询时，请求自动转到备节点上。这个设置叫做Read Preference Modes，同时Java客户端提供了简单的配置方式，可以不必直接对数据库进行操作。\n       仲裁节点是一种特殊的节点，它本身并不存储数据，主要的作用是决定哪一个备节点在主节点挂掉之后提升为主节点，所以客户端不需要连接此节点。这里虽然只有一个备节点，但是仍然需要一个仲裁节点来提升备节点级别。我开始也不相信必须要有仲裁节点，但是自己也试过没仲裁节点的话，主节点挂了备节点还是备节点，所以咱们还是需要它的。\n# 集群搭建\n## 创建对应的文件夹\n创建数据文件夹，日志文件夹等\n\n```\nmkdir -p /mongodb/data/master   \nmkdir -p /mongodb/data/slaver   \nmkdir -p /mongodb/data/arbiter    \n#三个目录分别对应主，备，仲裁节点  \n```\n## 创建配置文件\n\n```\n#master.conf  \ndbpath=/mongodb/data/master  \nlogpath=/mongodb/log/master.log  \npidfilepath=/mongodb/master.pid  \ndirectoryperdb=true  \nlogappend=true  \nreplSet=testrs  \nbind_ip=10.10.148.130  \nport=27017  \noplogSize=10000  \nfork=true  \nnoprealloc=true  \n```\n\n```\n#slaver.conf  \ndbpath=/mongodb/data/slaver  \nlogpath=/mongodb/log/slaver.log  \npidfilepath=/mongodb/slaver.pid  \ndirectoryperdb=true  \nlogappend=true  \nreplSet=testrs  \nbind_ip=10.10.148.131  \nport=27017  \noplogSize=10000  \nfork=true  \nnoprealloc=true  \n```\n\n\n```\n#arbiter.conf  \ndbpath=/mongodb/data/arbiter  \nlogpath=/mongodb/log/arbiter.log  \npidfilepath=/mongodb/arbiter.pid  \ndirectoryperdb=true  \nlogappend=true  \nreplSet=testrs  \nbind_ip=10.10.148.132  \nport=27017  \noplogSize=10000  \nfork=true  \nnoprealloc=true  \n```\n**参数解释：**\n\n参数名称 | 作用\n---|---\ndbpath |数据存放目录\nlogpath|日志存放路径\npidfilepath|进程文件，方便停止mongodb\ndirectoryperdb|为每一个数据库按照数据库名建立文件夹存放\nlogappend|以追加的方式记录日志\nreplSet|replica set的名字\nbind_ip|mongodb所绑定的ip地址\nport|mongodb进程所使用的端口号，默认为27017\noplogSize|mongodb操作日志文件的最大大小。单位为Mb，默认为硬盘剩余空间的5%\nfork|以后台方式运行进程\nnoprealloc|不预先分配存储\n\n## 启动mongodb节点\n进入每个mongodb节点的目录下启动节点\n```\nmonood -f master.conf  \nmongod -f slaver.conf  \nmongod -f arbiter.conf  \n```\n注意：配置文件的路径一定要保证正确，可以是相对路径也可以是绝对路径。\n\n# 配置主，备，仲裁节点\n\n\n```\n./mongo 10.10.148.130:27017   #ip和port是某个节点的地址  \n>use admin  \n>cfg={ _id:\"testrs\", members:[ {_id:0,host:\'10.10.148.130:27017\',priority:2}, {_id:1,host:\'10.10.148.131:27017\',priority:1},   \n{_id:2,host:\'10.10.148.132:27017\',arbiterOnly:true}] };  \n>rs.initiate(cfg)             #使配置生效  \n```\n  cfg是可以任意的名字，当然最好不要是mongodb的关键字，conf，config都可以。最外层的_id表示replica set的名字，members里包含的是所有节点的地址以及优先级。优先级最高的即成为主节点，即这里的10.10.148.130:27017。特别注意的是，对于仲裁节点，需要有个特别的配置——arbiterOnly:true。这个千万不能少了，不然主备模式就不能生效。\n  \n  如果生效了，执行rs.status()命令会看到如下信息：\n  \n```\n{  \n        \"set\" : \"testrs\",  \n        \"date\" : ISODate(\"2013-01-05T02:44:43Z\"),  \n        \"myState\" : 1,  \n        \"members\" : [  \n                {  \n                        \"_id\" : 0,  \n                        \"name\" : \"10.10.148.130:27017\",  \n                        \"health\" : 1,  \n                        \"state\" : 1,  \n                        \"stateStr\" : \"PRIMARY\",  \n                        \"uptime\" : 200,  \n                        \"optime\" : Timestamp(1357285565000, 1),  \n                        \"optimeDate\" : ISODate(\"2013-01-04T07:46:05Z\"),  \n                        \"self\" : true  \n                },  \n                {  \n                        \"_id\" : 1,  \n                        \"name\" : \"10.10.148.131:27017\",  \n                        \"health\" : 1,  \n                        \"state\" : 2,  \n                        \"stateStr\" : \"SECONDARY\",  \n                        \"uptime\" : 200,  \n                        \"optime\" : Timestamp(1357285565000, 1),  \n                        \"optimeDate\" : ISODate(\"2013-01-04T07:46:05Z\"),  \n                        \"lastHeartbeat\" : ISODate(\"2013-01-05T02:44:42Z\"),  \n                        \"pingMs\" : 0  \n                },  \n                {  \n                        \"_id\" : 2,  \n                        \"name\" : \"10.10.148.132:27017\",  \n                        \"health\" : 1,  \n                        \"state\" : 7,  \n                        \"stateStr\" : \"ARBITER\",  \n                        \"uptime\" : 200,  \n                        \"lastHeartbeat\" : ISODate(\"2013-01-05T02:44:42Z\"),  \n                        \"pingMs\" : 0  \n                }  \n        ],  \n        \"ok\" : 1  \n}  \n```\n如果配置正在生效，其中会包含如下信息：\n\n```\n\"stateStr\" : \"RECOVERING\" \n```\n# 添加一个节点\n在主节点上添加其它节点到副本集中。\n步骤同上创建节点配置文件，启动节点，然后使用mongo连接主节点。\n\n```\n[root@node2 bin]# ./mongo 10.10.148.130:27017\n    MongoDB shell version: 2.6.5\n    connecting to: node1:27017/test\nblort:PRIMARY>rs.add(\"10.10.148.133:27017\");\n\nrs.status();  //查看节点状态\n```\n\n# 删除一个节点\n在主节点上删除node3服务器\n在要删除的节点中停止Mongodb服务。然后使用mongo连接现有的主节点。\n```\n[root@node2 bin]# ./mongo 10.10.148.130:27017\nrs.remove(\"node3:27017\");\nrs.status();  //查看节点状态\n```\n# 在从节点读取数据\n\n实例如下：\n```\n[root@node3 bin]# ./mongo node3:27017\nMongoDB shell version: 2.6.5\nconnecting to: node3:27017/test\nblort:SECONDARY> show dbs\nadmin   (empty)\nlocal  10.073GB\ntong    0.078GB\nblort:SECONDARY> use tong\nswitched to db tong\nblort:SECONDARY> db.user.find();\nerror: { \"$err\" : \"not master and slaveOk=false\", \"code\" : 13435 }      --查找数据提示出错\nblort:SECONDARY> db.getMongo().setSlaveOk();          --执行可以从主节点读取\nblort:SECONDARY> db.user.find();                                --在从节点可以读取数据了\n{ \"_id\" : ObjectId(\"547542321fcfc3fe272b9cfd\"), \"id\" : 1 }\n{ \"_id\" : ObjectId(\"5475423a1fcfc3fe272b9cfe\"), \"id\" : \"1\" }\n{ \"_id\" : \"123\" }\nblort:SECONDARY> \n```\n# 在主服务器上插入数据，检查从服务器是否同步\n实例如下：\n\n```\n主服务器:\n[root@node1 bin]# ./mongo node2:27017\nMongoDB shell version: 2.6.5\nconnecting to: node2:27017/test\nblort:PRIMARY> use tong\nswitched to db tong\nblort:PRIMARY> db.user.insert({\"id\":1});\nWriteResult({ \"nInserted\" : 1 })\nblort:PRIMARY> db.user.insert({\"id\":\"1\"});\nWriteResult({ \"nInserted\" : 1 })\nblort:PRIMARY> db.user.find();\n{ \"_id\" : ObjectId(\"547542321fcfc3fe272b9cfd\"), \"id\" : 1 }\n{ \"_id\" : ObjectId(\"5475423a1fcfc3fe272b9cfe\"), \"id\" : \"1\" }\nblort:PRIMARY>\n\n从服务器:\n[root@node2 bin]# ./mongo node3:27017\nMongoDB shell version: 2.6.5\nconnecting to: node3:27017/test\nblort:SECONDARY> use tong\nswitched to db tong\nblort:SECONDARY> db.user.find();\nerror: { \"$err\" : \"not master and slaveOk=false\", \"code\" : 13435 }           --从服务器不能查数据\nblort:SECONDARY>\n```\n\n# 其他\n## 节点ip配置和ip地址对主机名的解析\nnode1:配置IP地址\n\n```\n[root@node1 ~]# vim /etc/sysconfig/network-scripts/ifcfg-eth0\nDEVICE=eth0\nHWADDR=10:78:D2:C9:50:28\nTYPE=Ethernet\nUUID=c96e0866-df98-4898-8ada-aa2511d0a0f4\nONBOOT=yes\nNM_CONTROLLED=yes\nBOOTPROTO=static\nIPADDR=192.168.1.250\nNETMASK=255.255.255.0\nGATEWAY=192.168.1.1\n[root@node1 ~]#\n```\nnode1:对IP地址和主机名解析\n\n```\n[root@node1 ~]# vim /etc/hosts\n192.168.1.250 node1\n192.168.1.251 node2\n192.168.1.252 node3\n[root@node1 ~]#\n```\n\n', '2', '0', '2017-06-15 14:31:19'), ('39', '1018', '68', '> 2017-05-24 15:09:05 星期三\n\n------------\n\n\nReact - ⽤于构建⽤户界⾯的JAVASCRIPT库 仅仅是UI - 许多⼈使⽤React作为MVC架构的V层。 尽管React并没有假设过你的其余技术栈， 但它仍可以作为⼀个⼩特征轻易地在已有项⽬中使⽤ 虚拟DOM - React为了更⾼超的性能⽽使⽤虚拟DOM作为其不同的实现。 它同时也可以由服务端Node.js渲染 － ⽽不需要过重的浏览器DOM⽀持 数据流 - React实现了单向响应的数据流，从⽽减少了重复代码，这也是它为什么⽐传统数据绑定更简单', '2', '0', '2017-05-24 15:09:26'), ('40', '1018', '91', '# React+Redux 同构应用开发\n2017-05-24 15:13:02 星期三\n</br>\n### 1. 背景\n> 随着众多React + Redux 项目在团队中落地，基于此模式的单向数据流应用受到了广泛的推崇。但是在项目开发过程中，尤其是复杂单页应用，JS文件的体积往往高达数百KB。相较于以往开发模式（Kissy、jQuery、Zepto…）几十KB的体积，极大地增加了页面首次加载的时间。PC端中，这些问题并不突出，但对于移动端，尤其是弱网环境下，会大大增加用户的等待时间，从用户体验上来说，是极不友好的。\n\n### 2.服务端渲染（Server Rendering）\n> React中提出了 虚拟DOM 的概念，虚拟DOM以对象树的形式保存在内存中，与真实DOM相映射，通过ReactDOM的Render方法，渲染到页面中，并维护DOM的创建、销毁、更新等过程，以最高的效率，得到相同的DOM结构。\n\n> 虚拟DOM 给页面带来了前所未有的性能提升，但它的精髓不仅局限于此，还给我们带来了另一个福利： 服务端渲染 。\n\n> 不同于ReactDOM.render将DOM结构渲染到页面，React中还提供了另外两个方法：ReactDOMServer.renderToString 和 ReactDOMServer.renderToStaticMarkup 。二者将虚拟DOM渲染为一段字符串，代表了一段完整的HTML结构。\n\n### 3.同构（Isomorphic）\n\n> 通过React提供的服务端渲染方法，我们可以在服务器上生成DOM结构，让用户尽早看到页面内容，但是一个能够work的页面不仅仅是DOM结构，还包括了各种事件响应、用户交互。那么意味着，在客户端上，还得执行一段JS代码绑定事件、处理异步交互，在React中，意味着整个页面的组件需要重新渲染一次，反而带来了额外的负担。\n\n> 因此，在服务端渲染中，有一个十分重要的概念， 同构(Isomorphic) ，在服务端和客户端中，使用完全一致的React组件，这样能够保证两个端中渲染出的DOM结构是完全一致的，而在这种情况下，客户端在渲染过程中，会判断已有的DOM结构是否和即将渲染出的结构相同，若相同，不重新渲染DOM结构，只是进行事件绑定。\n\n### 4.配合Redux\n> 上述 服务端渲染 帮我们完成了组件层面的同构问题，对于要使用何种数据流并没有约束，在本次实践中，使用了Redux模式，关于Redux服务端渲染，参看官方文档。其中最重要的一点就是，在服务端和客户端保持 store 一致。\n\nstore 的初始状态在Server端生成，为了保持两个端中store的一致，官方示例中通过在页面插入脚本的方式，写入store初始值到window：\n```javascript\nwindow.__INITIAL_STATE__ = ${JSON.stringify(initialState)}\n```\n此处输出initialState到页面中，是十分危险的，一定要注意XSS的防范。\nRedux推荐使用 serialize-javascript 序列化JS对象，这一点十分必要。\n\n### 5.实践\n> 要进行服务端渲染，一个node server必不可少，Koa、Express 都是流行的Node端Web框架，前者似乎更受开发者青睐。\n\n### 6.Koa\n> Server端使用 Koa。配合如 xtemplate，koa-jade之类的视图模板，能够快速完成HTML页面的渲染。关于Koa的使用，并不是本文的重点，在此不过多阐述，选择一个顺手可靠的框架即可。\n\n##### 目录结构\n├── app                         //服务端\n│   ├── controllers                     //控制器\n│   ├── routes                          //路由\n│   ├── service                         //接口\n│   └── views                       //视图\n├── assets\n├── bin                         \n├── build                           //构建，css、js\n├── client                      //客户端\n│   ├── actions\n│   ├── api\n│   ├── components\n│   ├── constants\n│   ├── containers\n│   ├── less\n│   ├── reducers\n│   └── store\n├── lib\n├── logs\n├── mock\n└── webpack                     //Webpack配置\n\n**其中，所有React组件和Redux 模块都放在 /client 目录下，该目录下存放着一个和我们日常开发React+Redux完全一致的APP。**\n\n### 7.配置 Koa\n> 我们的HTML页面不再通过静态服务器获取，而是通过Koa Server，配置一个新路由，作为页面的入口。使用xtemplate for Koa作为View层，在/app/routes中新建路由：\n\n```javascript\n\'use strict\';\n\nvar HomeController = require(\'../controllers/home\');\nvar router = new (require(\'koa-router\'))();\nrouter.get(\'/home.html\', HomeController.index);\nmodule.exports = router;\n```\n\n在 /app/controllers中新建控制器：\n```javascript\n\'use strict\';\n\nexports.index = function* () {\n\n    //do something\n\n    yield this.render(\'home\');\n\n};\n```\n\'home\', 对应 /app/views下的视图文件\n\n### 8.服务端ES6/7支持\n通常，在客户端代码中，我们的编程风格里使用了大量的ES6/7语法，如import， class 等，但在服务端，这些语言特性Node还不能完全支持，这就需要我们使用相关的插件，帮助服务端识别此类语法。\n\n> #### 引入babel-register\n> > babel-register 通过绑定 require函数的方式（require hook）,在 require jsx文件时，使用babel转换语法，因此，应该在任何 jsx 代码执行前，执行 require(\'babel-register\')(config)，同时通过配置项config，配置babel语法等级、插件等。具体配置方法可参看官方文档。> babel-register 通过绑定 require函数的方式（require hook）,在 require jsx文件时，使用babel转换语法，因此，应该在任何 jsx 代码执行前，执行 require(\'babel-register\')(config)，同时通过配置项config，配置babel语法等级、插件等。具体配置方法可参看官方文档。\n\n> #### 处理CSS/LESS文件处理CSS/LESS文件\n> > babel-register 帮助服务端识别特殊的js语法，但对 less/css 文件无能为力，庆幸的是，在一般情况下，服务端渲染不需要样式文件的参与，css文件只要引入到HTML文件中即可，因此，可以通过配置项，忽略所有 css/less 文件:babel-register 帮助服务端识别特殊的js语法，但对 less/css 文件无能为力，庆幸的是，在一般情况下，服务端渲染不需要样式文件的参与，css文件只要引入到HTML文件中即可，因此，可以通过配置项，忽略所有 css/less 文件:\n```javascript\nrequire(\"babel-register\")({\n  // Optional ignore regex - if any filenames **do** match this regex then they\n  // aren\'t compiled. ignore: /(.css|.less)$/, });\n```\n完成jsx语法支持，就可以引入React组件或APP，通过 renderToString 方法进行服务端渲染：\n\n```javascript\n\'use strict\';\n\nimport React from \'react\';\nimport { renderToString } from \'react-dom/server\';\nimport { createStore } from \'redux\';\nimport configureStore from \'../../client/store/configureStore\';\nimport { Provider } from \'react-redux\';\nimport App from \'../../client/containers/home\';\nexports.index = function* () {\n    //do something\n    // 生成store\n    const store = configureStore();\n    // 从store中获取state\n    const finalState = store.getState();\n    const html = renderToString(\n        <Provider store={store}>\n             <App />\n        </Provider>\n    );\n    //将生成的html结构插入模版中\n    yield this.render(\'home\', {html: html});\n};\n```\n\n### 9.使用CSS Modules\n通过 babel-register 能够使用babel解决jsx语法问题，对 css/less 只能进行忽略，但在使用了 CSS Modules 的情况下，服务端必须能够解析 less文件，才能得到转换后的类名，否者服务端渲染出的 HTML 结构和打包生成的客户端 css 文件中，类名无法对应。\n\n为了解决这个问题，需要一个额外的工具 webpack-isomorphic-tools，帮助识别less文件。\n> #### webpack-isomorphic-tools\n简单地说，webpack-isomorphic-tools，完成了两件事：\n1. 以webpack插件的形式，预编译less（不局限于less，还支持图片文件、字体文件等），将其转换为一个 assets.json 文件保存到项目目录下。\n1. require hook，所有less文件的引入，代理到生成的 JSON 文件中，匹配文件路径，返回一个预先编译好的 JSON 对象。\n</br>\n上述过程解决了服务端渲染中不能解析非js文件的痛点，让我们使用CSS Modules时欲罢不能的快感，在服务端得以延续。\n配置文件十分冗长，配置细节可查阅官方文档。这里需要注意的是，webpack-isomorphic-tools 的 require hook，是通过一个回调函数进行的：\n```javascript\nvar WebpackIsomorphicTools = require(\'webpack-isomorphic-tools\'); \nglobal.webpackIsomorphicTools = new WebpackIsomorphicTools(require(\'../webpack/webpack-isomorphic-config\'))\n    .development(__DEVELOPMENT__)\n    .server(rootDir, function () {\n        //回调\n        require(\'./app.js\'); //启动 server\n    });\n```\nwebpack-isomorphic-tools 启动时，会先等待指定目录下 assets.json 文件生成，只有该文件就绪后，require hook 才会进行，进而触发 server 回调，只有在此回调中执行的代码，才能保证进行了require hook。\n\n### 10.环境变量\n另一个在同构应用中的常见问题就是环境变量，客户端开发中，只需要判断链接、URL参数等，但在server端，并没有清晰的host概念，同一个Server可以在多个host下被访问。 那么，一些环境参数的判断，就要通过环境变量进行。\n\n在webpack中，使用 DefinePlugin 定义环境变量（其实就是global变量）：\n```javascript\nplugins: [\n    ...\n    new webpack.DefinePlugin({\n        \'__ENV__\': JSON.stringify(\'development\'),\n        __CLIENT__: true,\n        __SERVER__: false,\n        __DEVELOPMENT__: true,\n        __DEVTOOLS__: true\n    }),\n    ...\n]\n```\n配置了不同环境变量的 webpack 配置文件，打包得到的也只是固定JS文件，如果要和服务端上多个环境（dev、prod）一一对应，需要使用多个配置文件来完成，发布到不同环境时，使用对应环境下的配置。\n\n### 11.构建\n通过 gulp，使用不同的 webpack 配置进行打包，生成对应静态资源，发布到CDN即可。\n\n这里需要注意的是，合理使用环境变量，和webpack插件，可以大大减少js文件的体积：\n```javascript\ngulp.task(\"env:prod\", function () {\n    env({\n        BABEL_ENV: \'production\',\n        NODE_ENV: \'production\'\n    });\n    prodConfig.plugins = prodConfig.plugins.concat(\n        new webpack.DefinePlugin({\n            \'process.env\': {\n                NODE_ENV: JSON.stringify(\'production\')\n            },\n            \'NODE_ENV\': JSON.stringify(\'production\'),\n            \'__ENV__\': JSON.stringify(\'production\')\n        }),\n        new webpack.optimize.DedupePlugin(),\n        new webpack.optimize.OccurenceOrderPlugin(),\n        // Compresses javascript files\n        new webpack.optimize.UglifyJsPlugin({\n            compress: {\n                warnings: false\n            }\n        })\n    );\n});\n```\n\n通过gulp任务，设置环境变量为production，webpack 将不会把 React 中如PropTypes检查之类的非必需代码打包，同时能够避免babel引入开发环境下的插件。\n\nDedupePlugin 和 UglifyJsPlugin 两个webpack插件必不可少，前者帮我们去除重复引入的js代码，后者进行js混淆压缩。\n\n本次项目中，开发阶段的代码 4MB+ 最终被压缩到了 300KB，发布到CDN，浏览器以gzip格式加载，实际大小约为 100KB，即使对于移动端而言，也是一个可以接受的大小。', '2', '0', '2017-06-15 14:31:06'), ('41', '1', '98', '[TOC]\n\n### 爱上线上服务器配置\n||LVS|KeepAlived|Nginx|Tomcat|ChatServer|MySQL|Redis|Mongodb|ActiveMQ|GlusterFS|\n|-\n|210.73.218.164|--|--|--|--|√|--|√主|--|√集群|--|\n|210.73.218.165|--|--|√|√|--|--|--|--|--|--|\n|210.73.218.166|--|--|--|--|--|√从|--|√集群|--|√集群|\n|210.73.218.167|--|--|--|--|--|√主|--|√集群|--|√集群|\n|210.73.218.168|--|--|√|√|--|--|--|--|√集群|--|\n|210.73.218.169|--|--|--|--|√|--|√从|√集群|√集群|--|\n|210.73.218.170|√主|√主|--|--|--|--|--|--|--|--|\n|210.73.218.171|√从|√从|--|--|--|--|--|--|--|--|\n\n### 爱上备份服务器配置\n||LVS|KeepAlived|Nginx|Tomcat|ChatServer|MySQL|Redis|Mongodb|ActiveMQ|GlusterFS|\n|-\n|10.10.10.242|√主|√主|--|--|--|--|--|--|--|--|\n|10.10.10.243|√从|√从|--|--|--|--|√主|√集群(仲裁者)|√集群|--|\n|10.10.10.244(1.8T)|--|--|√|√|√|--|--|--|--|√集群|\n|10.10.10.246|--|--|--|--|--|√主|√从|√集群|√集群|--|\n|10.10.10.247(1.8T)|--|--|√|√|√|--|--|--|--|√集群|\n|10.10.10.251|--|--|--|--|--|√从|--|√集群|√集群|--|\n\n\n### 其它配置信息\n1. git地址\n> 1. 后台\n>> git@gitlab.love.tv:project/lovetv.git\n>\n> 2. pc前端\n>> git@gitlab.love.tv:project/lovetv-www.git\n\n2. 给mvn扩大内存\n> $ vi /etc/profile\n> 添加\n>> export MAVEN_OPTS=\"-Xms1024m -Xmx1024m -XX:MaxNewSize=512m  -XX:MaxPermSize=512m\"\n>\n> $ source /etc/profile\n\n3. ssh生成公钥\n> $ ssh-keygen -t rsa -C \"邮箱地址\"\n\n4. 备份服务器对应外网\n> 60.247.26.x\n\n5. 对应开机启动项需加到:/etc/rc.d/rc.local', '2', '0', '2017-06-15 14:31:10'), ('42', '1', '97', '[TOC]\n\n### 时装历史\n> 1. 最早有独立运行的```PC网页```和```APP```，之后重新设计并重构程序\n2. 程序重构后存放于git的```pc_wending```分支\n3. 时装APP与爱上APP合并，但由于表结构相差太大，所以数据独立分开。APP程序合并后存放于git的```dev```分支\n4. 定时同步PC数据到APP 和 定时同步APP数据到PC\n\n### 时装服务器配置\n||Nginx|Tomcat|ChatServer|ImageMagicK|Elasticsearch|MySQL|Redis|Mongodb|ActiveMQ|\n|-\n|106.3.138.162|√|√|√|√||||||\n|106.3.138.163|√|√|√|√||||||\n|106.3.138.164|||||√集群|√主|√从|√集群|√集群|\n|106.3.138.165|||||√集群|√从|√从|√集群|√集群|\n|106.3.138.166|||||√集群|√从|√主|√集群|√集群|\nps：图片、视频等文件数据与爱上放置同一glusterFS文件系统中\n\n### git 信息\n> PC\n>> git 代码地址：```git@gitlab.love.tv:lofficiel/lofficiel-project.git```\ngit 代码分支：```pc_wending```\n\n>> 程序目录及描述\n>>\n|目录|描述|\n|-\n|dbscript|mysql数据库重大版本迭代的表结构备份|\n|document|文档|\n|generator|mybatis自动生成工具，与mysql表结构对应|\n|lofficiel-common|公共模块|\n|lofficiel-entity|实体模块，与mysql中表结构对应|\n|lofficiel-mapper|mybatis操作的mapper|\n|lofficiel-redis|redis的连接与常用操作的service|\n|lofficiel-service|业务service操作，主要操作的是mysql数据|\n|lofficiel-service-impl|对应```lofficiel-service```，是其子实现|\n|lofficiel-task|时装的定时任务模块，如：定时发布文章、定时导入数据到elasticsearch、定时导入APP数据等|\n|lofficiel-web|web相关公共数据处理，比如：异常处理等|\n|lofficiel-web-admin|后台|\n|lofficiel-web-consumer|单纯的一个发布tomcat，对应消息处理的模块|\n|lofficiel-web-file|文件上传模块|\n|lofficiel-web-h5|对应手机h5的页面与接口|\n|lofficiel-web-importOldDB|时装重构之前来自于postgreSql的数据，用于导库，现在数据已导完，该模块废弃|\n|lofficiel-web-mobile|时装重构之前的APP所用到的接口，重写接口数据来源于现在的数据库|\n|lofficiel-web-pc|时装PC页面与接口|\n|lofficiel-web-task|单纯的一个发布tomcat，对应定时数据处理模块|\n\n> APP\n>> git 代码地址：```git@gitlab.love.tv:lofficiel/lofficiel-project.git```\ngit 代码分支：```dev```\n\n>> 程序目录及描述\n>>\n|目录|描述|\n|-\n|dbscript|mysql数据库重大版本迭代的表结构备份|\n|document|文档|\n|generator|mybatis自动生成工具，与mysql表结构对应|\n|lofficiel-chat|直播聊天服务，打成jar包引用|\n|lofficiel-common|公共模块|\n|lofficiel-consumer|消息处理公共模块|\n|lofficiel-consumer-business|以前爱上消息处理监听器，主要操作对应mysql的数据|\n|lofficiel-consumer-persist|以前爱上消息处理监听器，主要操作对应mongodb的数据|\n|lofficiel-consumer-lofficiel|时装对应的消息处理监听器，主要处理图片缩放|\n|lofficiel-elasticsearch|实时搜索服务模块|\n|lofficiel-entity|实体模块，与mysql中表结构对应|\n|lofficiel-mapper|mybatis操作的mapper|\n|lofficiel-mongodb|对mongodb操作的service|\n|lofficiel-mq|所有消息处理都基于该模块，它是连接activemq的枢纽|\n|lofficiel-redis|redis的连接与常用操作的service|\n|lofficiel-service|业务service操作，主要操作的是mysql数据|\n|lofficiel-service-impl|对应```lofficiel-service```，是其子实现|\n|lofficiel-web|web相关公共数据处理，比如：异常处理等|\n|lofficiel-web-admin|后台|\n|lofficiel-web-analyse|合并爱上时遗留模块，暂时没有用到|\n|lofficiel-web-app|APP对应的接口|\n|lofficiel-web-h5|APP对应的H5页面|\n|lofficiel-web-managers|合并爱上时遗留模块，暂时没有用到|\n|lofficiel-web-pc|PC页面与接口|\n|lofficiel-web-quartz|定时周期任务，如：定时发布文章、定时导入数据到elasticsearch、定时导入PC数据等|\n\n\n### 程序发布相关\n\n#### APP 部署的Tomcat或服务\n> ps：所有tomcat全部部署在```106.3.138.162```和```106.3.138.163```\n>\n||162|163|备注|\n|-\n|lofficiel-chat|√|√|对应服务器目录：```/data/lofficiel/lofficiel_chat```|\n|lofficiel-consumer-business||√|对应服务器目录：```/data/lofficiel/tomcat/9191_consumer_business```|\n|lofficiel-consumer-persist||√|对应服务器目录：```/data/lofficiel/tomcat/9292_consumer_persist```|\n|lofficiel-consumer-lofficiel||√|对应服务器目录：```/data/lofficiel/tomcat/9393_consumer_lofficiel```|\n|lofficiel-web-admin|√||对应服务器目录：```/data/lofficiel/tomcat/8484_admin```|\n|lofficiel-web-app|√||对应服务器目录：```/data/lofficiel/tomcat/8282_app```|\n|lofficiel-web-h5|√||对应服务器目录：```/data/lofficiel/tomcat/8383_h5```|\n|lofficiel-web-pc|√||对应服务器目录：```/data/lofficiel/tomcat/8181_www```|\n|lofficiel-web-quartz||√|对应服务器目录：```/data/lofficiel/tomcat/9494_quartz```|\n>> *表格上相重的tomcat和服务对应的目录是一致的*\n>>> APP所有程序的配置文件均引用：```/data/lofficiel/tomcat/config.properties```\n除了```lofficiel-web-quartz```，其引用的配置文件：```/data/lofficiel/tomcat/config-importDB.properties```\n\n#### PC 部署的Tomcat或服务\n> ps：所有tomcat全部部署在```106.3.138.163```\n>\n||备注|\n|-\n|lofficiel-web-admin|对应服务器目录：```/data/lofficiel/tomcat/pc_wending/admin```|\n|lofficiel-web-consumer|对应服务器目录：```/data/lofficiel/tomcat/pc_wending/consumer```|\n|lofficiel-web-file|对应服务器目录：```/data/lofficiel/tomcat/pc_wending/file```|\n|lofficiel-web-h5|对应服务器目录：```/data/lofficiel/tomcat/pc_wending/h5```|\n|lofficiel-web-mobile|对应服务器目录：```/data/lofficiel/tomcat/pc_wending/app```|\n|lofficiel-web-pc|对应服务器目录：```/data/lofficiel/tomcat/pc_wending/www```|\n|lofficiel-web-task|对应服务器目录：```/data/lofficiel/tomcat/pc_wending/task```|\n>> *表格上相重的tomcat和服务对应的目录是一致的*\n>>> APP所有程序的配置文件均引用：```/data/lofficiel/tomcat/pc_wending/config.properties```\n除了```lofficiel-web-task```，其引用的配置文件：```/data/lofficiel/tomcat/pc_wending/config-importDB.properties```\n', '2', '0', '2017-06-15 14:31:13'), ('43', '1', '100', '[TOC]\n\n### 程序部署\n> 程序部署在服务器`106.3.138.172:/data/tools/listener/jobs`\n\n### git 信息\n> git 地址：```git@gitlab.love.tv:project/lovetv-listener.git```\n> git 分支：```master```\n\n### 程序概述\n- 将项目打成 jar 包后，可直接运行。主Main类：```tv.love.StartJobs.java```\n- 所有的监听任务都在包：```tv.love.jobs```\n\n### 配置文件概述\n> ***1. 动态添加定时任务时间***\n>> 规则：```timer.Job实现类的全路径=n分钟```\n>>> - n分钟：\n>>>> - 当 n=0 时：每次都会执行，每次的时间间隔取决于添加至crontab系统周期执行shell的时间\n>>>> - 当 n=-1 时：废弃该任务，即不执行\n>>>> - 当 n=正整数 时：执行间隔时间\n>>>\n>>> - 当对应任务的定时key不存在，则默认该任务5分钟执行一次\n>>\n>> 参考示例：```timer.tv.love.jobs.impl.JobAssets=10```\n>>> 位于```tv.love.jobs.impl.JobAssets```的任务每```10```分钟执行一次\n\n> ***2. 动态添加任务报警邮件接收邮箱***\n>> 规则：```email.Job实现类的全路径=邮箱1,邮箱2,邮箱3...```\n>> 参考示例：```email.tv.love.jobs.impl.JobMagazineAndVideoCheckingList=sunyuhai@5.cn,zoufanqi@5.cn```\n>>> 若对应的任务的邮箱不存在，则发送默认邮箱（```mail_tos```）\n\n> ***3. 监听数据库连接数异常任务，动态添加数据库***\n```\n# host,username,连接越野时间 - 连接数据库对应的服务器，三个信息中间以\",\"分隔\nmysql.connect.1=210.73.218.166,root,20000\n# 连接服务器密码\nmysql.connect.1.pwd=密码\n# 执行命令超时时间,要执行的命令 - 连接服务器成功后执行的获取数据库连接数的命令\nmysql.connect.1.cmd=1000,mysqladmin -uroot -pRoot密码 processlist|wc -l\n# 超过该连接数报警值\nmysql.connect.1.alarm.num=150\n```\n>> 以上key的数字```1```代码不同数据库，若添加下一个为```2```，依次添加，不可越级\n\n> ***4. key详细描述***\n>\n|key|描述|\n|-\n|timer.Job实现类全路径|动态添加任务执行时间，详见上面|\n|||\n|mail_smtp_server|发送邮件smtp服务器地址|\n|mail_from|发送邮件的邮箱|\n|mail_fromPwd|发送邮件的邮箱密码|\n|mail_fromAlias|发送邮件的邮箱别名|\n|mail_tos|默认邮件接收邮箱，多个以```,```分隔|\n|||\n|send_msg_phones|短信接收手机号，特定会发送短信，会发送短信的任务详见```任务信息```|\n|||\n|jdbc_driver|数据库连接驱动|\n|jdbc_url|数据库连接地址|\n|jdbc_username|数据库连接用户名|\n|jdbc_password|数据库连接用户密码|\n|||\n|msg_alarm_differ_num|短信余额任务，前后查询短信余额报警差值|\n|msg_notice_balance|短信余额任务，短信余额少于该阶段值时报警，多个以```,```分隔|\n|msg_add_balance_is_notice|短信余额任务，余额充值后是否发送通知。```1通知  0不通知```|\n|||\n|mysql.connect.1|数据库连接数任务，信息详见上面|\n|mysql.connect.1.pwd|数据库连接数任务，信息详见上面|\n|mysql.connect.1.cmd|数据库连接数任务，信息详见上面|\n|mysql.connect.1.alarm.num|数据库连接数任务，信息详见上面|\n|||\n|assets_record_time|帐户余额任务，统计数据时长，即保留数据统计时长，单位：小时|\n|assets_alarm_increase|帐户余额任务，在统计数据时长内增加资产报警值（发送邮件），单位：人民币```人民币：爱心=1：10```|\n|assets_alarm_decrease|帐户余额任务，在统计数据时长内减少资产报警值（发送邮件），单位：人民币```人民币：爱心=1：10```|\n|assets_alarm_msg_increase|帐户余额任务，在统计数据时长内增加资产报警值（发送短信），单位：人民币```人民币：爱心=1：10```|\n|assets_alarm_msg_decrease|帐户余额任务，在统计数据时长内减少资产报警值（发送短信），单位：人民币```人民币：爱心=1：10```|\n|assets_alarm_max_time|连接报警次数，-1为无限|\n|||\n|home_timeout|检测H5主页任务，超时时间报警，单位：毫秒|\n\n### 程序部署步骤\n1. 将项目生成```jar```包，主类指向：```tv.love.StartJobs```\n2. 在 jar 包同一目录下，放置```config.properties```配置文件，文件名固定\n3. 修改```config.properties```的配置信息，如发送邮件人，发送短信人等信息\n4. 将执行程序写成```shell```，在项目资源目录下有```run(执行jar包).sh```文件可供参考\n5. 将生成的```shell```文件执行命令添加到系统定时周期任务中，可参考：\n> \n```shell\n# crontab -e\n添加：\n*/1 * * * * (sh /data/tools/listener/jobs/listenjob.sh >> /tmp/listenjob.log 2>&1&)\n```\n注意1：设置的1分钟执行一次并不是任务一分钟执行，执行时间在```config.properties```中配置\n注意2：间隔的时间越长，误差会越大。比如系统定时为10分钟一次，若```config.properties```配置为5分钟。因为5<10，所以每次都会执行\n\n### 任务信息\n- 短信余额异常任务\n> 设置短信预警值```msg_notice_balance```，当达到设置值时会发送```邮件```和```短信```通知\n\n- 数据库连接数异常任务\n> 设置数据库连接数预警值```mysql.connect.2.alarm.num```，当达到该值时会发送```邮件```和```短信```通知\n\n- 帐户余额异常任务\n> 可分别灵活设置```邮件```和```短信```，帐户增加与减少的资产预警值\n\n- H5主页异常任务\n> 设置连接H5主页超时时长```home_timeout```，当超过该时长还未获取到主页信息，发送```邮件```和```短信```通知\n\n- 定时罗列杂志与微拍未审核数据任务\n> 设置任务执行时间间隔，当有未审核数据时发送```邮件```通知\n', '2', '0', '2017-06-15 14:31:16');
INSERT INTO `note_detail` VALUES ('44', '1', '104', '#### maven编译打包优化\n\n1、增加跳过测试代码的编译命令 ```-Dmaven.test.skip=true```\n2、增加编译```-Dmaven.compile.fork=true```参数，用以指明多线程进行编译；\n3、如果你用的Maven是3.×以上版本，可以增加```-T 1C```参数，表示每个CPU核心跑一个工程；\n\n示例：\n```\nmvn clean package -T 1C -Dmaven.test.skip=true -Dmaven.compile.fork=true\n```\n\n#### maven assembly插件打jar包\n> `pom.xml`添加插件\n```\n<project>\n<build>\n<plugins>\n	<plugin>\n		<artifactId>maven-assembly-plugin</artifactId>\n		<configuration>\n			<archive>\n				<manifest>\n					<mainClass>com.sdk.cron.startup.Main</mainClass>\n				</manifest>\n			</archive>\n			<descriptorRefs>\n				<descriptorRef>jar-with-dependencies</descriptorRef>\n			</descriptorRefs>\n		</configuration>\n	</plugin>\n</plugins>\n</build>\n</project>\n```\n> 执行命令打jar包\n```\nmvn clean compile assembly:single\n```', '2', '0', '2017-06-06 14:36:03'), ('45', '1020', '102', '##php对文件访问的保护机制\n\n```php\nPHP Warning:  realpath(): open_basedir restriction in effect. File(/usr/local/bin/phpunit) is not within the allowed path(s): (/srv/http/:/home/:/tmp/:/usr/share/pear/) in /usr/local/bin/phpunit on line 3\nPHP Warning:  Phar::mapPhar(): open_basedir restriction in effect. File(/usr/local/bin/phpunit) is not within the allowed path(s): (/srv/http/:/home/:/tmp/:/usr/share/pear/) in /usr/local/bin/phpunit on line 714\n```\nphp.ini中的open_basedir是php为保证安全进行文件访问的设置。如果该选项被赋值，所有的文件操作将限定在特定的目录里，这样可以防止某个用户使用php脚本读取未授权的内容。当你想通过fopen或gzopen打开一个文件时，如果该文件的位置不再被允许的目录下面，就会出现上述的警告信息。', '2', '0', '2017-06-15 14:30:57'), ('46', '1020', '105', '准备工作：\n\n1、准备好一台主机，带公网IP，最好上面没有其他的应用程序（对linux熟练的除外）\n\n2、准备一个一级域名，做好泛解析（二级域名的没有配置成功，汗。。。）\n下面是安装步骤：（安装环境：centos6.5 64bit , 阿里云主机带弹性IP）\n\n一、安装git\n\n1、安装git所需要的依赖包\n\n    yum -y install zlib-devel openssl-devel perl hg cpio expat-devel gettext-devel curl curl-devel perl-ExtUtils-MakeMaker hg wget gcc gcc-c++\n\n2、卸载系统自带的Git    \n\n    yum remove git    \n\n3、下载git\n\n    wget https://www.kernel.org/pub/software/scm/git/git-2.6.0.tar.gz\n\n4、解压git\n\n    tar zxvf git-2.6.0.tar.gz\n\n5、编译git\n\n    cd git-2.6.0\n    make configure\n    ./configure --prefix=/usr/local/git --with-iconv=/usr/local/libiconv\n    make all doc\n    make install install-doc install-html\n    echo \"export PATH=$PATH:/usr/local/git/bin\" >> /etc/bashrc\n    source /etc/bashrc\n\n6、创建git的软连接\n\n    ln -s /usr/local/git/bin/* /usr/bin/\n二、安装go环境\n\n1、安装go get工具：\n\n    yum install mercurial bzr subversion\n\n2、Centos/Linux下源码安装golang：\n\n    wget https://storage.googleapis.com/golang/go1.4.1.linux-amd64.tar.gz\n    tar -C /usr/local -xzf go1.4.1.linux-amd64.tar.gz\n    mkdir $HOME/go\n    echo \'export GOROOT=/usr/local/go\' >> ~/.bashrc \n    echo \'export GOPATH=$HOME/go\' >> ~/.bashrc \n    echo \'export PATH=$PATH:$GOROOT/bin:$GOPATH/bin\' >> ~/.bashrc \n    source $HOME/.bashrc \n\n3、go的命令需要做软连接到/usr/bin\n\n    ln -s /usr/local/go/bin/* /usr/bin/\n三、编译ngrok\n\ncd /usr/local/\ngit clone https://github.com/inconshreveable/ngrok.git\nexport GOPATH=/usr/local/ngrok/\nexport NGROK_DOMAIN=\"域名\"\ncd ngrok\n四、为域名生成证书\n\nopenssl genrsa -out rootCA.key 2048\nopenssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$NGROK_DOMAIN\" -days 5000 -out rootCA.pem\nopenssl genrsa -out server.key 2048\nopenssl req -new -key server.key -subj \"/CN=$NGROK_DOMAIN\" -out server.csr\nopenssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 5000\n五、在软件源代码目录下面会生成一些证书文件，我们需要把这些文件拷贝到指定位置\n\ncp rootCA.pem assets/client/tls/ngrokroot.crt\ncp server.crt assets/server/tls/snakeoil.crt\ncp server.key assets/server/tls/snakeoil.key\n六、如果是在国内的服务器需要改，香港或者国外的服务器不需要\n\nvim /usr/local/ngrok/src/ngrok/log/logger.go\nlog \"github.com/keepeye/log4go\"\n七、编译服务端（根据自己系统的来）\n\ncd /usr/local/go/src  \n\nGOOS=linux GOARCH=386 ./make.bash(32位)\nGOOS=linux GOARCH=amd64 ./make.bash(64位)    \n\ncd /usr/local/ngrok/\n\nGOOS=linux GOARCH=386 make release-server(32 )\nGOOS=linux GOARCH=amd64 make release-server（64位）\n八、编译客户端:\n\nMAC OS 64位操作系统（32位系统把amd64改成386）\n\ncd /usr/local/go/src\nGOOS=darwin GOARCH=amd64 ./make.bash\ncd /usr/local/ngrok/\nGOOS=darwin GOARCH=amd64 make release-client\n\nWindows 64位操作系统（32位系统把amd64改成386）\n\ncd /usr/local/go/src\nGOOS=windows GOARCH=amd64 ./make.bash\ncd /usr/local/ngrok/\nGOOS=windows GOARCH=amd64 make release-client\n九、客户端配置文件\n\nserver_addr: \"域名:4443\"\ntrust_host_root_certs: false\n十、服务端启动\n\n/usr/local/ngrok/bin/ngrokd -domain=\"$NGROK_DOMAIN\" -httpAddr=\":80\"\n\n十一、客户端使用\n\nngrok -config=ngrok.cfg -subdomain aaa 80 （windows系统客户端）\n\n十二、错误分析\n\n1、gopkg.in/inconshreveable/go-update.v0 (download)卡住不动\n\n    原因：git版本过低导致\n\n    解决办法：卸载自带的git1.7.1，安装git2.2.1并将git添加到环境变量中\n十三、总结：\n\n1、严格按照上面的操作步骤，应该是完全可以搭建成功的。\n\n2、上面是用一级域名搭建成功的，有用二级域名搭建，但都失败了。失败的地方：如果做了二级域名的泛解析，那么在执行客户端时无法连接到服务器；\n\n    如果只做二级域名的解析，不做泛解析，客户端可以连接到服务器，但没有域名出来，故放弃了。', '2', '0', '2017-06-15 14:31:00'), ('47', '1', '107', '### 数组、链表\n\n[TOC]\n\n#### 数组\n- 数据是连续的内存空间\n- 需要提前分配固定大小存储空间\n\n> 数组操作\n>> - 原始数组\n>>\n|0|1|2|3|•••|n-3|n-2|n-1|\n|-\n\n>> - 插入元素\n>>\n|0|1|2|3|插入元素在此位置，后面的元素则会全部后移|•••|n-3|n-2|n-1|\n|-\n\n>> - 删除元素\n>>\n|0|1|2|3|删除此位置元素，后面的元素则会全部前移|•••|n-3|n-2|n-1|\n|-\n>\n> 总结\n>> 优点：使用方便、查询效率高（比链表高）、遍历速度快\n>> 缺点：插入和删除速度慢\n>> 适合场景：插入和删除少，经常查询的数据\n\n#### 链表\n- 数据是非连续的内存单元\n- 通过指针将各个内存单元链接在一起\n- 最后一个指针指向```NULL```\n- 不需要提前分配固定大小存储空间\n\n> 链表操作\n>> - 原始链表\n>>\n|next: 数据2| -> |next:数据3| -> |next: ...|•••| -> |NULL|\n|-\n|数据1||数据2||数据3|\n\n>> - 插入元素\n>>\n|next: 数据4| -> |next: 数据2| -> |next: 数据3| -> |next: ...|•••| -> |NULL|\n|-\n|数据1||数据4||数据2||数据3|\n>>> 向```数据1```与```数据2```之间插入```数据4```\n\n>> - 删除元素\n>>\n|next: 数据3| -> |next: ...|•••| -> |NULL|\n|-\n|数据1||数据3|\n>>> 删除```数据2```\n>\n> 总结\n>> 优点：删除插入快、大小可变\n>> 缺点：只能通过顺次指针访问，查询效率低\n>> 适合场景：需要经常作插入或删除的数据\n\n#### 数组与链表对比\n||添加|删除|插入|索引取值|遍历|\n|-\n|数组|优|差|差|极优|极优|\n|链表|优|优|优|差|优|\n\n#### ArrayList与LinkedList性能对比\n（单位：毫秒）\n\n> ArrayList\n\n||十万|一百万|一千万|两千万|三千万|\n|-\n|添加|14|72|4426|5240|11860|\n|取第一角标|0|0|0|0|0|\n|取中间角标|0|0|0|0|0|\n|取最后角标|0|0|0|0|0|\n|iterator|10|29|31|45|63|\n|索引循环|3|17|26|43|64|\n|删除第一角标|1|1|5|0|16|\n|删除中间角标|0|1|4|5|8|\n|删除最后角标|0|0|0|0|0|\n|插入第一角标|0|1|6|12|0|\n|插入中间角标|0|1|3|7|13|\n|插入最后角标|0|0|0|0|0\n\n> LinkedList\n\n||十万|一百万|一千万|两千万|三千万|\n|-\n|添加|13|133|8340|14668|26712|\n|取第一角标|0|0|0|0|0|\n|取中间角标|1|6|54|78|115|\n|取最后角标|0|0|0|0|0|\n|iterator|12|33|120|234|287|\n|索引循环|6783|-|-|-|-|\n|删除第一角标|0|0|0|0|0|\n|删除中间角标|0|5|64|76|108|\n|删除最后角标|0|0|0|0|0|\n|插入第一角标|0|0|0|0|0|\n|插入中间角标|2|8|43|102|203|\n|插入最后角标|0|0|0|0|0|\n\n\n> 十万\n\n||ArrayList|LinkedList|\n|-\n|添加|14|13|\n|取角标0|0|0|\n|取角标50000|0|1|\n|取角标100000|0|0|\n|iterator|10|12|\n|索引循环|3|6783|\n|删除角标0|1|0|\n|删除角标50000|0|0|\n|删除角标99998|0|0|\n|插入角标0|0|0|\n|插入角标50000|0|2|\n|插入角标99998|0|0|\n\n> 一百万\n\n||ArrayList|LinkedList|\n|-\n|添加|72|133|\n|取角标0|0|0|\n|取角标500000|0|6|\n|取角标1000000|0|0|\n|iterator|29|33|\n|索引循环|17|-|\n|删除角标0|1|0|\n|删除角标500000|1|5|\n|删除角标999998|0|0|\n|插入角标0|1|0|\n|插入角标500000|1|8|\n|插入角标999998|0|0|\n\n> 一千万\n\n||ArrayList|LinkedList|\n|-\n|添加|4426|8340|\n|取角标0|0|0|\n|取角标5000000|0|54|\n|取角标10000000|0|0|\n|iterator|31|120|\n|索引循环|26|-|\n|删除角标0|5|0|\n|删除角标5000000|4|64|\n|删除角标9999998|0|0|\n|插入角标0|6|0|\n|插入角标5000000|3|43|\n|插入角标9999998|0|0|\n\n> 两千万\n\n||ArrayList|LinkedList|\n|-\n|添加|5240|14668|\n|取角标0|0|0|\n|取角标10000000|0|78|\n|取角标20000000|0|0|\n|iterator|45|234|\n|索引循环|43|-|\n|删除角标0|11|0|\n|删除角标10000000|5|76|\n|删除角标19999998|0|0|\n|插入角标0|12|0|\n|插入角标10000000|7|102|\n|插入角标19999998|0|0|\n\n> 三千万\n\n||ArrayList|LinkedList|\n|-\n|添加|11860|26712|\n|取角标0|0|0|\n|取角标15000000|0|115|\n|取角标30000000|0|0|\n|iterator|63|287|\n|索引循环|64|-|\n|删除角标0|16|0|\n|删除角标15000000|8|108|\n|删除角标29999998|0|0|\n|插入角标0|24|0|\n|插入角标15000000|13|203|\n|插入角标29999998|0|0|\n\n', '2', '0', '2017-06-08 13:02:24'), ('48', '1', '108', '### springBean作用域\n\n[TOC]\n\n- 创建bean时可以指定```scope```来更改作用域\n- 在spring2.0之前只有2种作用域：singleton、prototype，在spring2.0以后，增加了session、request、global session。所以默认情况下spring bean作用域有这五种\n- 默认作用域：```singleton```\n\n#### singleton\n- 这里的singleton有些地方会写单例，但需注意：```singleton与GOF设计模式中的单例不是一个概念```。这里只是一个作用域范畴，是spring自己定义的，而GOF设计模式是一个ClassLoader只有一个class存在\n- 一个spring IOC容器中只会存在一个共享的bean实例。所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例\n\n> 配置示例：\n```\n<bean id=\"myBean\" class=\"com.qiqinote.MyBean\" scope=\"singleton\"/>\n或者\n<bean id=\"myBean\" class=\"com.qiqinote.MyBean\" singleton=\"true\"/>\n```\n\n#### prototype\n- 每获取一次bean（注入或自己getBean）都会产生一个新的bean实例，相当于new了一个新对象\n- 每次产生的bean，spring之后是不会对其整个生命周期负责的。也就是说容器在初始化、配置、装饰或者装配完一个protytype实例后，会将它交给客户端，随后就对该prototype实例不闻不问，最终销毁实例也需客户端自己维护\n- 不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。而prototype实例，任何配置好的析构生命周期回调方法都不会被调用\n\n> 配置示例：\n```\n<bean id=\"myBean\" class=\"com.qiqinote.MyBean\" scope=\"prototype\"/>\n或者\n<bean id=\"myBean\" class=\"com.qiqinote.MyBean\" singleton=\"false\"/>\n```\n\n#### === 使用下面三种作用域注意点 ===\nrequest、session、global session因为其作用域是基于web容器，与http挂勾，所以使用的时候首先要在```web.xml```中添加配置：\n> - 如果使用servlet2.4及以上的web容器，那么你仅需要在```web.xml```中增加下述ContextListener即可：\n```\n<web-app>\n	...\n	<listener>\n		<listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>\n	</listener>\n	...\n</web-app>\n```\n> - 如果使用servlet2.4以前的web容器，那么你要使用一个javax.servlet.Filter的实现：\n```\n<web-app>\n	...\n	<filter>\n		<filter-name>requestContextFilter</filter-name> \n		<filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>\n	</filter>\n	<filter-mapping>\n		<filter-name>requestContextFilter</filter-name> \n		<url-pattern>/*</url-pattern>\n	</filter-mapping>\n	...\n</web-app>\n```\n\n#### request\n- 使用前需先配置好```web.xml```\n- 每一次HTTP请求都会产生一个新的bean\n- 仅在当前HTTP request内有效\n\n> 配置示例：\n```\n<bean id=\"myBean\" class=\"com.qiqinote.MyBean\" scope=\"request\"/>\n```\n\n#### session\n- 使用前需先配置好```web.xml```\n- 每一次HTTP请求都会产生一个新的bean\n- 仅在当前HTTP session内有效\n\n> 配置示例：\n```\n<bean id=\"myBean\" class=\"com.qiqinote.MyBean\" scope=\"session\"/>\n```\n\n#### global session\n- 使用前需先配置好```web.xml```\n- 该作用域类似于标准的HTTP session作用域，不过它仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局session的概念，它被所有构成某个portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局的portlet session的生命周期范围内。如果在web中使用global session作用域来标识bean，那么web会自动当成session类型来使用\n\n> 配置示例：\n```\n<bean id=\"myBean\" class=\"com.qiqinote.MyBean\" scope=\"global session\"/>\n```', '2', '0', '2017-06-08 14:39:13'), ('49', '1', '109', '### 数据库：事务ACID、事务隔离级别与事务传播行为\n\n[TOC]\n\n#### 四大特性（ACID）\n\n- ##### 原子性（Atomicity）\n> 原子性是指：事务包含的所有操作要么全部成功，要么全部失败回滚，不存在中间状态\n\n- ##### 一致性（Consistency）\n> 一致性是指：事务从一个一致性状态变换到另一个一致性状态其前后数据必须处于一致性状态\n>> 举个栗子：\n>>> 有4个帐户，每个帐户都有100元，那么总额是400元。期间A向B转账10元，B向C转账10元，C向A转账10元 等等，这些同一事务的操作，无论执行多少次，怎么执行，这4个帐户总额须为400元。保证操作之前与操作之前处于一致性状态。\n\n- ##### 隔离性（Isolation）\n> 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离\n>> 为此数据库提供了多种事务的隔离级别，在文章下面有作介绍\n\n- ##### 持久性（Durability）\n> 持久性是指：事务一旦被提交了，那么对数据库中的数据的改变则是永久的，不能通过回滚或其它操作还原数据\n\n#### 事务隔离级别\n> 注意点：事务隔离级别需在事务开始之前设置\n\n- ##### READ UNCOMMITTED（读取未提交内容）\n> - 该隔离级别，所有事务都可以“看到”未提交事务的执行结果\n> - 在这种级别上，可能会产生很多问题，除非用户真的知道自己在做什么，并有很好的理由选择这样做\n> - 本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少，而别的级别还有其他更多的优点\n> - 读取未提交数据，也被称之为“脏读”\n\n- ##### READ COMMITTED（读取提交内容）\n> 一个事务只能读取另一个事务已经提交了的数据。从事务开始到事务结束之前，中间更改的任何数据对其它事务都是不可见的\n\n- ##### REPEATABLE READ（可重读）\n> - 该隔离级别解决了```READ UNCOMMITTED```所导致的问题。它确保同一事务的多个实例在并发读取数据时，会“看到同样的”数据行。不过理论上，这会导致另一个问题：幻读。\n>> 幻读（Phantom Read）：在一个事务的两次查询中数据数不一致，例如：有一个事务查询了几列数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的\n> - InnoDB和Falcon存储引擎通过多版本并发控制（Multiversion concurrency Control）机制解决了幻读的问题\n> - ```该隔离级别也是Mysql默认事务隔离级别```\n\n- ##### SERIALIZABLE（可串行化）\n> - 该级别是最高级别的隔离级\n> - 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，其是在每个读的数据行上加锁\n> - 该级别可能会导致大量的```超时（Timeout）现象```和```锁竞争（Lock Contention）现象```\n\n- ##### 事务隔离级别总结\n\n||脏读可能性|不可重复读可能性|幻读可能性|加锁读|\n|-\n|READ UNCOMMITTED|是|是|是|否|\n|READ COMMITTED|否|是|是|否|\n|REPEATABLE READ|否|否|是|否|\n|SERIALIZABLE|否|否|否|是|\n\n#### 事务传播行为\n> 拿spring举例\n>> spring 事务一般设置在service 层。\n正常情况下，A方法执行开启一个事务，B方法执行也会开启一个事务。假如现在有个方法中调用了A和B，那该方法也会开启一个事务，且该事务包含了A和B的操作。这就是事务的传播行为', '2', '0', '2017-06-15 14:30:47'), ('50', '1', '112', '【目录】\n\n[TOC]\n\n## centos-Hadoop2.7.3完全分布式搭建（HA）\n\n### 序\n> #### 序.1. 服务器节点分配\n>> ***本文中对服务器节点的分配只作为参考***\n>>> hadoop集群作HA需要zookeeper集群，本文不对zk集群搭建作详述，所以把zookeeper单独列出。<a target=\"_blank\" href=\"http://www.qiqinote.com/note/22.html\">zookeeper集群搭建详细配置请戳我</a>\n>>\n||hadoop01|hadoop02|hadoop03|hadoop04|hadoop05|zk1|zk2|zk3|\n|:-|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|NameNode|√|√|||||||\n|JournalNode|√|√|√||||||\n|DFSZKFailoverController|√|√|||||||\n|DataNode|||√|√|√||||\n|ResourceManager|√||||||||\n|NodeManager|||√|√|√||||\n|Zookeeper||||||√|√|√|\n\n> #### 序.2. 依赖\n>> - ssh\n>> - jdk\n>> - [zookeeper集群](http://www.qiqinote.com/note/22.html)\n>> - hadoop-2.7.3.tar.gz\n\n> #### 序.3. 本文中的基础配置\n>> - hadoop安装目录：hadoop帐户下的根目录\n>> - hadoop数据目录：/data/hadoop\n\n官方完全分布式搭建文档：http://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html\n\nps: 搭建时会用到很多端口，所以需注意防火墙问题！\n\n### 1. 配置hosts\n*执行节点：全部节点*\n> ```[root /]# vi /etc/hosts```\n```\n1.1.1.1 hadoop01\n1.1.1.2 hadoop02\n1.1.1.3 hadoop03\n1.1.1.4 hadoop04\n1.1.1.5 hadoop05\n1.1.1.6 zk1\n1.1.1.7 zk2\n1.1.1.8 zk3\n```\nps: 对应IP需外网，否则部署成功后外网不能用监控查看信息。但若能解决上述问题，配置内网当然更好\n\n### 2. 创建hadoop用户\n*执行节点：hadoop节点*\nps: 不是必须！\n```\n[root /]# useradd hadoop	# 在root用户下创建\n[root /]# passwd hadoop 	# 修改hadoop用户密码\n[root /]# mkdir /数据目录/hadoop	# 创建hadoop数据目录，一般放置到挂载盘容量大的地方，可通过(df -h)命令查看\n[root /]# chown -R hadoop:hadoop /数据目录/hadoop	# 设置该目录为hadoop用户组\n[root /]# su - hadoop		# 切换到hadoop帐户\n```\n\n### 3. 设置ssh免密码登录\n*执行节点：hadoop节点*\n> 1. 在主节点服务器生成ssh的key\n> 2. 把公钥添加到文件：```authorized_keys```（没有则添加）\n> 3. 把三个文件(私钥,公钥,验证文件)拷贝到其它节点```~/.ssh```目录，确保这三个文件所有节点都一致\n> ps: 所有操作均在目录: ```~/.ssh```中操作\n```\n[hadoop@hadoop01 .ssh]$ ssh-keygen -t dsa -P \'\' -f ~/.ssh/id_dsa\n[hadoop@hadoop01 .ssh]$ cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys\n[hadoop@hadoop01 .ssh]$ chmod 600 id_dsa	# id_dsa 文件的权限不能太大\n[hadoop@hadoop01 .ssh]$ ssh localhost 	# 测试是否连接本地需要密码\n[hadoop@hadoop01 .ssh]$ cd ..	# 退回到 ~/.ssh 目录，准备打包\n[hadoop@hadoop01 ~]$ tar -zcvf ssh.tar.gz .ssh/	# 打包，准备远程拷贝\n[hadoop@hadoop01 ~]$ scp ssh.tar.gz hadoop@hadoop02:~	# 远程拷贝到另外节点，然后到另外节点解压即可\n# 到另一台机器解压\n[hadoop@hadoop02 ~]$ tar -zxvf ssh.tar.gz	# 解压\n[hadoop@hadoop02 ~]$ ssh hadoop01	# 测试是否能远程连接（不需要密码即成功）\n```\n>> 若不能成功连接，请检查：1、所有节点的`~/.ssh/`下的文件都是一致，2、文件`id_dsa`权限为`600`\n>> ```\n[hadoop .ssh]$ chmod 600 id_dsa\n```\n\n### 4. 下载安装hadoop\n*执行节点：hadoop任一节点，如：hadoop01*\nps: hadoop安装目录：~  （hadoop帐户根目录）\n官方hadoop下载引导页：\nhttp://hadoop.apache.org/releases.html\n或\nhttp://apache.fayea.com/hadoop/common/\n```\n[hadoop@hadoop01 ~]$ wget http://apache.fayea.com/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gz\n[hadoop@hadoop01 ~]$ scp hadoop-2.7.3.tar.gz hadoop@hadoop02:~ 	# 分别远程拷贝数据到其它节点到安装目录\n[hadoop@hadoop01 ~]$ tar -zxvf hadoop-2.7.3.tar.gz\n[hadoop@hadoop01 ~]$ mv hadoop-2.7.3 ~	# 安装目录\n```\n\n### 5. 配置hadoop\n*执行节点：hadoop节点*\n官方文档：http://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html\nps: 所有配置均在```~/hadoop-2.7.3```中完成，也就是上一步解压的hadoop包\n> #### 5.1. 配置```etc/hadoop/hadoop-env.sh```\n该配置为hadoop环境配置\n>> 修改配置：\n```\nexport JAVA_HOME=/path/to/JAVA_HOME	\n```\n还有一些配置可详见官网\n>\n> #### 5.2. 配置```etc/hadoop/profile.d/hadoop2.7.3.sh```\n该配置为用户配置\n>> ps: 该文件以及父目录可能不存在，需手动新建，父目录名称不可更改\n>> 添加配置：\n```\n[hadoop@hadoop节点 hadoop2.7.3] mkdir etc/hadoop/profile.d\n[hadoop@hadoop节点 hadoop2.7.3] vi etc/hadoop/profile.d/hadoop2.7.3.sh\n```\n>>> \n```shell\n#!/bin/sh\nexport HADOOP_HOME=\"~/hadoop-2.7.3\"		# Hadoop的安装目录\nexport PATH=\"$HADOOP_HOME/bin:$PATH\"\nexport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\nexport YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop\n```\n>\n> #### 5.3. 配置```etc/hadoop/core-site.xml```\n添加配置：\n```xml\n<configuration>\n	<!-- 指定hdfs的nameService，与（hdfs-site.xml）对应 -->\n	<property>\n		<name>fs.defaultFS</name>\n		<value>hdfs://ns1</value>\n	</property>\n	<!-- 指定hadoop运行时产生文件的存储路径 -->\n	<property>\n		<name>hadoop.tmp.dir</name>\n		<value>/data/hadoop/2.7.3/tmp</value>\n    </property>\n	<property>\n		<name>io.file.buffer.size</name>\n		<value>131072</value>\n	</property>\n	<!-- 指定zookeeper集群地址 -->\n	<property>\n		<name>ha.zookeeper.quorum</name>\n		<value>zk1:2181,zk2:2181,zk3:2181</value>\n	</property>\n</configuration>\n```\n>> ps：注意修改zk对应的hosts名称\n>\n> #### 5.4. 配置```etc/hadoop/hdfs-site.xml```\n添加配置：\n```xml\n<configuration>\n	<!-- 副本数，默认3 -->\n	<property>\n      <name>dfs.replication</name>\n      <value>3</value>\n    </property>\n	<!-- nameNode数据目录 -->\n    <property>\n      <name>dfs.namenode.name.dir</name>\n      <value>file:/data/hadoop/2.7.3/hdfs/name</value>\n    </property>\n	<!-- dataNode数据目录 -->\n    <property>\n      <name>dfs.datanode.data.dir</name>\n      <value>file:/data/hadoop/2.7.3/hdfs/data</value>\n    </property>\n	<!-- dfs.nameservices 命名空间的逻辑名称，多个用,分割 -->\n	<property>\n		<name>dfs.nameservices</name>\n		<value>ns1</value>\n	</property>\n	<!-- 指定ns1下有两个namenode，分别是nn1,nn2 -->\n	<property>\n		<name>dfs.ha.namenodes.ns1</name>\n		<value>nn1,nn2</value>\n	</property>\n	<!-- 指定nn1的RPC通信地址 -->\n	<property>\n		<name>dfs.namenode.rpc-address.ns1.nn1</name>\n		<value>hadoop01:8020</value>\n	</property>\n	<!-- 指定nn1的HTTP通信地址 -->\n	<property>\n		<name>dfs.namenode.http-address.ns1.nn1</name>\n		<value>hadoop01:50070</value>\n	</property>\n	<!-- 指定nn2的RPC通信地址 -->\n	<property>\n		<name>dfs.namenode.rpc-address.ns1.nn2</name>\n		<value>hadoop02:8020</value>\n	</property>\n	<!-- 指定nn2的HTTP通信地址 -->\n	<property>\n		<name>dfs.namenode.http-address.ns1.nn2</name>\n		<value>hadoop02:50070</value>\n	</property>\n	<!-- 指定namenode的元数据存放的Journal Node的地址，必须是大于1的奇数 -->\n	<property>\n		<name>dfs.namenode.shared.edits.dir</name>\n		<value>qjournal://hadoop01:8485;hadoop02:8485;hadoop03:8485/ns1</value>\n	</property>\n	<!--这是JournalNode进程保持逻辑状态的路径。这是在linux服务器文件的绝对路径-->\n	<property>\n		<name>dfs.journalnode.edits.dir</name>\n		<value>/data/hadoop/2.7.3/journal/</value>\n	</property>\n	<!-- 开启namenode失败后自动切换 -->\n	<property>\n		<name>dfs.ha.automatic-failover.enabled</name>\n		<value>true</value>\n	</property>\n	<!-- 配置失败自动切换实现方式 -->\n	<property>\n		<name>dfs.client.failover.proxy.provider.ns1</name>\n		<value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value>\n	</property>\n	<!-- 配置隔离机制方法，多个机制用换行分割 -->\n	<property>\n		<name>dfs.ha.fencing.methods</name>\n		<value>\n			sshfence\n			shell(/bin/true)\n		</value>\n	</property>\n	<!-- 使用sshfence隔离机制时需要ssh免登陆 -->\n	<property>\n		<name>dfs.ha.fencing.ssh.private-key-files</name>\n		<value>~/.ssh/id_dsa</value>\n	</property>\n	<!-- 配置sshfence隔离机制超时时间30秒 -->\n	<property>\n		<name>dfs.ha.fencing.ssh.connect-timeout</name>\n		<value>30000</value>\n	</property>\n</configuration>\n```\n>> ps：注意修改hadoop对应的hosts名称\n>\n> #### 5.5. 配置```etc/hadoop/mapred-site.xml```\n>> 该配置文件默认不存在，但提供了一个template\n>\n```\n[hadoop hadoop-2.7.3]$ cp mapred-site.xml.template mapred-site.xml\n```\n添加配置：\n```xml\n<configuration>\n    <!-- 通知框架MR使用YARN -->\n    <property>\n        <name>mapreduce.framework.name</name>\n        <value>yarn</value>\n    </property>\n</configuration>\n```\n>\n> #### 5.6. 配置```etc/hadoop/yarn-site.xml```\n添加配置：\n```xml\n<configuration>\n    <!-- 指定YARN的ResourceManager的地址，NameNode节点中的一个 -->\n    <property>\n        <name>yarn.resourcemanager.hostname</name>\n        <value>hadoop01</value>\n    </property>\n    <!-- reducer取数据的方式是mapreduce_shuffle -->\n    <property>\n        <name>yarn.nodemanager.aux-services</name>\n        <value>mapreduce_shuffle</value>\n    </property>\n</configuration>\n```\n>> ps：注意修改hadoop对应的hosts名称\n>\n> #### 5.7. 配置```etc/hadoop/slaves```\n>> 该文件配置的是DataNode，一行一个\n>\n添加配置：\n```\nhadoop03\nhadoop04\nhadoop05\n```\n\n### 6. 初始化与启动\n> #### 6.1. 启动 journalNode\n>> 执行节点：```hadoop01、hadoop02、hadoop03```，配置文件```etc/hadoop/hdfs-site.xml```中```dfs.namenode.shared.edits.dir```指定\n```\n[hadoop@配置journal节点 hadoop2.7.3]$ sbin/hadoop-daemon.sh start journalnode\n[hadoop@配置journal节点 hadoop2.7.3]$ jps	# 查看对应java进程名称，能看到：JournalNode\n```\n>\n> #### 6.2. 格式化 NameNode\n>> 执行节点：配置两台NameNode中任意一台\n```\n[hadoop@hadoop01 hadoop2.7.3]$ bin/hdfs namenode -format\n[hadoop@hadoop01 hadoop2.7.3]$ sbin/hadoop-daemon.sh start namenode		# 启动NameNode，standby的NameNode拷贝该NameNode元数据\n[hadoop@hadoop01 hadoop2.7.3]$ jps	# 查看对应java进程名称，能看到：NameNode\n```\n>\n> #### 6.3. 拷贝Active的NameNode元数据\n>> 执行节点：6.2执行完后剩下的另一个NameNode\n```\n[hadoop@hadoop02 hadoop2.7.3]$ bin/hdfs namenode -bootstrapStandby\n[hadoop@hadoop02 hadoop2.7.3]$ sbin/hadoop-daemon.sh start namenode\n[hadoop@hadoop02 hadoop2.7.3]$ jps	# 查看对应java进程名称，能看到：NameNode\n```\n>\n> #### === 6.2 / 6.3 注意点===\n>> 本文档NameNode有两台：hadoop01、hadoop02. 对于4.2节中格式化哪台并不是说它就变成主，hadoop01与hadoop02默认情况哪台先启动哪台就是Active，另一台则为standby，并无主从之分，只有先后之别。\n>\n> #### 6.4. 格式zookeeper\n>> 执行节点：配置两台NameNode中任意一台\n```\n[hadoop@hadoop01 hadoop2.7.3]$ bin/hdfs zkfc –formatZK\n[hadoop@hadoop01 hadoop2.7.3]$ sbin/hadoop-daemon.sh start zkfc\n[hadoop@hadoop01 hadoop2.7.3]$ jps	# 查看对应java进程名称，能看到：DFSZKFailoverController\n```\n>>> 若报错：`org.apache.hadoop.HadoopIllegalArgumentException: Bad argument: –formatZK`\n>>>> 复制粘贴会出现该问题，手动输入命令即可\n>\n> #### 6.5. 关闭所有hadoop的Java进程\n>> 执行节点：配置两台NameNode中任意一台\n```\n[hadoop@hadoop01 hadoop2.7.3]$ sbin/stop-all.sh\n```\n>\n> #### 6.6. 开启所有hadoop的Java进程\n>> 执行节点：配置两台NameNode中任意一台，建议在配置ResourceManager节点的那台NameNode节点执行\n```\n[hadoop@hadoop01 hadoop2.7.3]$ sbin/start-all.sh\n```\n>>> 注意点：ResourceManager会随启动hadoop而启动，若没有自动启动，手动执行以下命令即可：\n```\n[hadoop@配置ResourceManager节点 hadoop2.7.3]$ sbin/start-yarn.sh\n```\n>\n> #### 成功启动后各节点与Java进程对应关系\n>> 遵循上面表格成功配置完成后hadoop对应Java进程的映射关系\nps: 通过命令```jps```查看Java进程\n>>\n||hadoop01|hadoop02|hadoop03|hadoop04|hadoop05|\n|-|:-:|:-:|:-:|:-:|:-:|\n|NameNode|√|√||||\n|DFSZKFailoverController|√|√||||\n|JournalNode|√|√|√|||\n|ResourceManager|√|||||\n|NodeManager|||√|√|√|\n|DataNode|||√|√|√|\n\n### 7. 查看信息\n- http://NameNodeIP:50070/\n> 两个NameNode能分别看到：```Active```（运行中）和```standby```（HA）\n\n- http://ResourceManagerIP:8088/\n> Yarn的资源管理界面，打开后在```Nodes```菜单栏能看到对应所有NodeManager节点，若没有，看看是不是防火墙问题\n\n### 8. 测试\n- 通过```jps```查看Active的NameNode，用```kill -9 PID```，看是否能自动切换standby的NameNode为```Active```\n- 添加文件到HDFS中\n```\n[hadoop@hadoop集群中任意一台 hadoop2.7.3]$ bin/hdfs dfs -put /path/from/local /path/to/HDFS\n然后通过Active的NameNode访问 http://NameNodeIP:50070/ 查看信息\n```\n\n### 9. hdfs常用命令操作：http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html\n\n### 附\n![](http://img.qiqinote.com/2017/7/10/7e91c52d78e7473d9af4420cf6b7144b.png)\n![](http://img.qiqinote.com/2017/7/10/eae07df8d9774416b108640fd3811c48.png)\n![](http://img.qiqinote.com/2017/7/10/ce925277659c4a8eb62b285977a101c4.png)\n![](http://img.qiqinote.com/2017/7/10/43d40c95c52042c2ab5561e14292a558.png)\n![](http://img.qiqinote.com/2017/7/10/d650316f9a504f2f8d7c304dd2a9a322.png)\n![](http://img.qiqinote.com/2017/7/10/04f2ace3461c42d8b680d96f602466a2.png)\n![](http://img.qiqinote.com/2017/7/10/81835ac9c2084b318db5eaa13b417f89.png)\n![](http://img.qiqinote.com/2017/7/10/aaf769bbd52a40798d837def515559ed.png)', '2', '0', '2017-06-15 14:30:51'), ('51', '1', '114', '### RDD五大特性\n\n[TOC]\n\n#### 序\n	    RDD(Resilient Distributed Datasets)，弹性分布式数据集，是分布式内存的一个抽象概念，RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，只能通过在其他RDD执行确定的转换操作（如map、join和group by）而创建，然而这些限制使得实现容错的开销很低。对开发者而言，RDD可以看作是Spark的一个对象，它本身运行于内存中，如读文件是一个RDD，对文件计算是一个RDD，结果集也是一个RDD，不同的分片、数据之间的依赖、key-value类型的map数据都可以看做RDD。\n\n#### RDD的五大特性\n\n> - ##### A list of partitions\n		一个分片集合。这个特性是说RDD的组成是由一个分片集合组成。\n		对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，若未指定则使用默认值。默认值是程序所分配到的CPU Core的数目。每个分配的存储是由BlockManager实现的，每个分区都会被逻辑映射成BlockManager的一个Block，而这个Block会被一个Task负责计算。\n		简单来说：一个分区在一台机器上，一个分区其实就是放在一台机器的内存上，一台机器上可以有多个分区\n\n> - ##### A function for computing each split\n		一个计算函数会作用于每个分片上。\n		Spark中的RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个上的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。\n		举例来说：一个函数作用在一个分区上。比如说一个分区有1，2,3 在rdd1.map(_*10),把RDD里面的每一个元素取出来乘以10，每个分片都应用这个map的函数。\n\n> - ##### A list of dependencies on other RDDs\n		每个RDD可能会有一个依赖列表（不是每个RDD都会有）\n		RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。\n		举例来说：RDD之间有一系列的依赖rdd1.map(_*10).flatMap(..).map(..).reduceByKey(...)，构建成为DAG,这个DAG会构造成很多个阶段，这些阶段叫做stage，RDDstage之间会有依赖关系，后面根据前面的依赖关系来构建，如果前面的数据丢了，它会记住前面的依赖，从前面进行重新恢复。每一个算子都会产生新的RDD。textFile 与flatMap会产生两个RDD。\n\n> - ##### Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)\n		可选：key-value型的RDD是根据哈希来分区的，类似于mapReduce当中的partitioner接口，控制key分到哪个reduce\n		一个partitioner，即RDD的分片函数。当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个基于范围的RangePartitioner。只有对于key-value的RDD，都会有Partitioner，非key-value的RDD的Partitioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。\n		简单来说：分区器hash & Integer.Max % partiotioner 决定数据到哪个分区里面，可选，这个RDD是key-value 的时候才能有。\n\n> - ##### Optionally, a list of perferred locations to compute each split on (e.g. block locations for an HDFS file)\n		可选：分片的最优计算位置，比如HDFS的block的所在位置应该是优先计算的位置。\n		一个列表，存储存取每个Partition的优先位置(preferred location)。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。\n		简单来说：数据在哪台机器上，任务就启在哪个机器上，数据在本地上，不用走网络。不过数据进行最后汇总的时候就要走网络。（hdfs file的block块）\n\n#### RDD的特点\n- 它是在集群节点上的不可变的、已分区的集合对象\n- 通过并行转换的方式来创建如(map, filter, join, etc)\n- 失败自动重建\n- 可以控制存储级别（内存、磁盘等）来进行重用\n- 必须是可序列化的\n- 是表态类型的', '2', '0', '2017-06-15 14:30:54'), ('52', '1020', '115', '###酷狗音乐用户服务协议\n\n[服务协议:http://www.kugou.com/about/protocol.html](http://www.kugou.com/about/protocol.html) \n\n######请不要用于商业途径获利，仅供参考与技术交流分享 \n\n######API分析源站 http://www.kugou.com/\n\n\n###酷狗音乐查询\nURL：http://songsearch.kugou.com/song_search_v2?keyword=${关键词}&page=1&pagesize=10&userid=-1&clientver=&platform=WebFilter&tag=em&filter=2&iscorrection=1&privilege_filter=0&_=1497494089309\nHTTP请求方式：get\n\n添加头信息\n\n    Cookie:kg_mid=897e37889b6dde6cf903c17f8cf3c91b; Hm_lvt_aedee6983d4cfc62f509129360d6bb3d=1497494083; Hm_lpvt_aedee6983d4cfc62f509129360d6bb3d=1497497122\n    Host:songsearch.kugou.com\n    Referer:http://www.kugou.com/yy/html/search.html\n    User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\n\n**额外参数：**\n\n|参数|名称|参数类型|默认值|是否必须|备注|\n|:----|:----|:----|:----|:----|:----|\n|keyword|搜索关键词|string|1|true|-|\n|page|页码|Integer|-|true|-|\n|pagesize|每页显示条数|Integer|-|true|-|\n|callback|jsonp 回调函数名|string|-|false|-|\n|_|时间戳|long|-|false|13位|\n\n返回结果\n```JSON\n{\n  \"status\": 1,\n  \"error_code\": 0,\n  \"data\": {\n    \"page\": 1,\n    \"tab\": \"全部\",\n    \"lists\": [\n      {\n        \"SongName\": \"<em>童话镇</em>\",\n        \"OwnerCount\": 4092505,\n        \"MvType\": 2,\n        \"TopicRemark\": \"\",\n        \"SQFailProcess\": 0,\n        \"Source\": \"\",\n        \"Bitrate\": 128,\n        \"HQExtName\": \"mp3\",\n        \"SQFileSize\": 27948216,\n        \"ResFileSize\": 0,\n        \"Duration\": 257,\n        \"MvTrac\": 3,\n        \"SQDuration\": 258,\n        \"ExtName\": \"mp3\",\n        \"Auxiliary\": \"\",\n        \"SongLabel\": \"\",\n        \"Scid\": 23216520,\n        \"FailProcess\": 0,\n        \"SQBitrate\": 866,\n        \"HQBitrate\": 325,\n        \"Audioid\": 23216520,\n        \"HiFiQuality\": 2,\n        \"Grp\": {},\n        \"AlbumPrivilege\": 0,\n        \"TopicUrl\": \"\",\n        \"SuperFileHash\": \"\",\n        \"ASQPrivilege\": 0,\n        \"M4aSize\": 1061096,\n        \"AlbumName\": \"<em>童话镇</em>\",\n        \"Privilege\": 0,\n        \"ResBitrate\": 0,\n        \"HQFailProcess\": 0,\n        \"SQPayType\": 0,\n        \"HQPrice\": 0,\n        \"Type\": \"audio\",\n        \"SourceID\": 0,\n        \"FileName\": \"陈一发儿 - <em>童话镇</em>\",\n        \"ID\": \"e28898886c2390ae0540ea5b98859bb9\",\n        \"SuperFileSize\": 0,\n        \"QualityLevel\": 3,\n        \"SQFileHash\": \"1246CA3CE991E85FAE20BD7A35EAF336\",\n        \"A320Privilege\": 0,\n        \"HQPrivilege\": 0,\n        \"SuperBitrate\": 0,\n        \"SuperDuration\": 0,\n        \"AlbumID\": \"1918064\",\n        \"ResFileHash\": \"\",\n        \"PublishAge\": 255,\n        \"SuperExtName\": \"\",\n        \"HQFileHash\": \"F59E3587418C889D49A799164E8D87AE\",\n        \"HQPayType\": 0,\n        \"PayType\": 0,\n        \"mvTotal\": 1,\n        \"Accompany\": 1,\n        \"HQFileSize\": 10485560,\n        \"PkgPrice\": 0,\n        \"FileSize\": 4128292,\n        \"SQExtName\": \"flac\",\n        \"AudioCdn\": 100,\n        \"HQPkgPrice\": 0,\n        \"SQPrice\": 0,\n        \"ResDuration\": 0,\n        \"OldCpy\": 1,\n        \"Price\": 0,\n        \"Publish\": 1,\n        \"SingerName\": \"陈一发儿\",\n        \"SQPrivilege\": 0,\n        \"MvHash\": \"19081CFE9BD82EED1EFA57215279C5ED\",\n        \"SQPkgPrice\": 0,\n        \"HQDuration\": 258,\n        \"OtherName\": \"\",\n        \"HasAlbum\": 1,\n        \"MixSongID\": \"\",\n        \"FileHash\": \"ED35367BD830D24073CCE802C075C6AD\"\n      }\n    ],\n    \"chinesecount\": 3,\n    \"searchfull\": 1,\n    \"correctiontype\": 0,\n    \"subjecttype\": 0,\n    \"aggregation\": [\n      {\n        \"key\": \"DJ\",\n        \"count\": 0\n      },\n      {\n        \"key\": \"现场\",\n        \"count\": 0\n      },\n      {\n        \"key\": \"广场舞\",\n        \"count\": 0\n      },\n      {\n        \"key\": \"伴奏\",\n        \"count\": 0\n      },\n      {\n        \"key\": \"铃声\",\n        \"count\": 0\n      }\n    ],\n    \"allowerr\": 0,\n    \"correctionsubject\": \"\",\n    \"correctionforce\": 0,\n    \"total\": 199,\n    \"istagresult\": 0,\n    \"istag\": 0,\n    \"correctiontip\": \"\",\n    \"pagesize\": 1\n  }\n}\n\n```\n\n\n###获取音乐图片、歌词和播放地址\n\nURL: http://www.kugou.com/yy/index.php?r=play/getdata&hash=${音乐HASH}&album_id={唱片ID}&_=1497494411688\nHTTP请求方式：get\n\n添加头信息\n	\n    Cookie:kg_mid=897e37889b6dde6cf903c17f8cf3c91b; Hm_lvt_aedee6983d4cfc62f509129360d6bb3d=1497494083; Hm_lpvt_aedee6983d4cfc62f509129360d6bb3d=1497497239\n    Host:www.kugou.com\n    Pragma:no-cache\n    Referer:http://www.kugou.com/song/\n    User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\n    X-Requested-With:XMLHttpRequest\n\n**额外参数：**\n\n|参数|名称|参数类型|默认值|是否必须|备注|\n|:----|:----|:----|:----|:----|:----|\n|hash|搜索关键词|string|1|true|-|\n|album_id|页码|Integer|-|true|-|\n|_|时间戳|long|-|false|13位|\n\n例：http://www.kugou.com/yy/index.php?r=play/getdata&hash=1246CA3CE991E85FAE20BD7A35EAF336&album_id=1918064&_=1497494411688\n\nHASH来源查询接口\n\n	普通音乐 FileHash=ED35367BD830D24073CCE802C075C6AD\n	高音质音乐 HQFileHash=F59E3587418C889D49A799164E8D87AE\n    无损音乐 SQFileHash=1246CA3CE991E85FAE20BD7A35EAF336\n\n返回结果\n\n```JSON\n\n{\n  \"status\": 1,\n  \"err_code\": 0,\n  \"data\": {\n    \"hash\": \"F59E3587418C889D49A799164E8D87AE\",\n    \"timelength\": 258000,\n    \"filesize\": 10485560,\n    \"audio_name\": \"陈一发儿 - 童话镇\",\n    \"have_album\": 1,\n    \"album_name\": \"童话镇\",\n    \"album_id\": \"1918064\",\n    \"img\": \"http://imge.kugou.com/stdmusic/20161003/20161003150211820473.jpg\",\n    \"have_mv\": 1,\n    \"video_id\": \"620331\",\n    \"author_name\": \"陈一发儿\",\n    \"song_name\": \"童话镇\",\n    \"lyrics\": \"[00:00.73]童话镇 - 陈一发儿\\r\\n[00:01.50]词：竹君\\r\\n[00:01.64]曲：暗杠\\r\\n[00:01.79]编曲：暗杠\\r\\n[00:23.20]听说白雪公主在逃跑\\r\\n[00:26.60]小红帽在担心大灰狼\\r\\n[00:29.91]听说疯帽喜欢爱丽丝\\r\\n[00:33.33]丑小鸭会变成白天鹅\\r\\n[00:36.79]听说彼得潘总长不大\\r\\n[00:40.20]杰克他有竖琴和魔法\\r\\n[00:43.58]听说森林里有糖果屋\\r\\n[00:46.83]灰姑娘丢了心爱的玻璃鞋\\r\\n[00:50.64]只有睿智的河水知道\\r\\n[00:53.80]白雪是因为贪玩跑出了城堡\\r\\n[00:57.35]小红帽有件抑制自己\\r\\n[01:00.77]变成狼的大红袍\\r\\n[01:03.93]总有一条蜿蜒在童话镇里七彩的河\\r\\n[01:11.02]沾染魔法的乖张气息\\r\\n[01:14.56]却又在爱里曲折\\r\\n[01:17.93]川流不息扬起水花\\r\\n[01:20.93]又卷入一帘时光入水\\r\\n[01:24.72]让所有很久很久以前\\r\\n[01:28.24]都走到幸福结局的时刻\\r\\n[01:47.48]听说睡美人被埋藏\\r\\n[01:50.53]小人鱼在眺望金殿堂\\r\\n[01:53.85]听说阿波罗变成金乌\\r\\n[01:57.33]草原有奔跑的剑齿虎\\r\\n[02:00.77]听说匹诺曹总说着谎\\r\\n[02:04.31]侏儒怪拥有宝石满箱\\r\\n[02:07.81]听说悬崖有颗长生树\\r\\n[02:11.08]红鞋子不知疲倦地在跳舞\\r\\n[02:14.64]只有睿智的河水知道\\r\\n[02:17.85]睡美人逃避了生活的煎熬\\r\\n[02:21.34]小人鱼把阳光抹成眼影\\r\\n[02:24.74]投进泡沫的怀抱\\r\\n[02:27.81]总有一条蜿蜒在童话镇里七彩的河\\r\\n[02:35.27]沾染魔法的乖张气息\\r\\n[02:38.65]却又在爱里曲折\\r\\n[02:42.01]川流不息扬起水花\\r\\n[02:44.98]又卷入一帘时光入水\\r\\n[02:48.87]让所有很久很久以前\\r\\n[02:52.30]都走到幸福结局的时刻\\r\\n[02:55.57]总有一条蜿蜒在童话镇里梦幻的河\\r\\n[03:02.61]分隔了理想分隔现实\\r\\n[03:05.96]又在前方的山口汇合\\r\\n[03:09.36]川流不息扬起水花\\r\\n[03:12.44]又卷入一帘时光入水\\r\\n[03:16.25]让所有很久很久以前\\r\\n[03:19.66]都走到幸福结局的时刻\\r\\n[03:22.73]又陌生\\r\\n\",\n    \"author_id\": \"544892\",\n    \"privilege\": 0,\n    \"privilege2\": \"0\",\n    \"play_url\": \"http://fs.web.kugou.com/c599520fa6ad91c66e3280e836768796/5941f490/G079/M03/06/15/L5QEAFfrrY6AUmOVAJ__OAaBscw363.mp3\",\n    \"authors\": [\n      {\n        \"is_publish\": \"1\",\n        \"author_id\": \"544892\",\n        \"avatar\": \"20161222154900283.jpg\",\n        \"author_name\": \"陈一发儿\"\n      }\n    ],\n    \"bitrate\": 325\n  }\n}\n\n\n```', '2', '0', '2017-06-15 11:34:17'), ('53', '1020', '116', '###QQ音乐服务许可协议\n\n[服务协议:http://y.qq.com/y/static/tips/service_tips.html](http://y.qq.com/y/static/tips/service_tips.html) \n\n######请不要用于商业途径获利，仅供参考与技术交流分享 \n\n######API分析源站 https://y.qq.com/\n\n\n###QQ音乐查询\nURL：https://c.y.qq.com/soso/fcgi-bin/client_search_cp?inCharset=utf8&outCharset=utf-8&platform=yqq\nHTTP请求方式：get\n\n**额外参数：**\n\n|参数|名称|参数类型|默认值|是否必须|备注|\n|:----|:----|:----|:----|:----|:----|\n|w|搜索关键词|string|1|true|-|\n|p|页码|Integer|-|true|-|\n|n|每页显示条数|Integer|-|true|-|\n|format|格式|string|-|false|json 或  jsonp|\n|jsonpCallback|回调函数名称|string|-|false|-|\n\n返回结果\n```JSON\n{\n  \"code\": 0,\n  \"data\": {\n    \"keyword\": \"童话镇\",\n    \"priority\": 0,\n    \"qc\": [\n    ],\n    \"semantic\": {\n      \"curnum\": 0,\n      \"curpage\": 1,\n      \"list\": [\n      ],\n      \"totalnum\": 0\n    },\n    \"song\": {\n      \"curnum\": 1,\n      \"curpage\": 1,\n      \"list\": [\n        {\n          \"albumid\": 1632238,\n          \"albummid\": \"0044cHmg45iock\",\n          \"albumname\": \"童话镇\",\n          \"albumname_hilight\": \"<em>童话镇</em>\",\n          \"alertid\": 11,\n          \"belongCD\": 0,\n          \"cdIdx\": 1,\n          \"chinesesinger\": 0,\n          \"docid\": \"13175947714957339531\",\n          \"format\": \"qqhq;common;mp3common;wmacommon;crcommon\",\n          \"grp\": [\n          ],\n          \"interval\": 257,\n          \"isonly\": 0,\n          \"lyric\": \"\",\n          \"lyric_hilight\": \"\",\n          \"media_mid\": \"0041vb5D3WMtrl\",\n          \"msgid\": 0,\n          \"newStatus\": 2,\n          \"nt\": 3470509834,\n          \"pay\": {\n            \"payalbum\": 0,\n            \"payalbumprice\": 0,\n            \"paydownload\": 0,\n            \"payinfo\": 0,\n            \"payplay\": 0,\n            \"paytrackmouth\": 0,\n            \"paytrackprice\": 0\n          },\n          \"preview\": {\n            \"trybegin\": 63932,\n            \"tryend\": 91744,\n            \"trysize\": 445961\n          },\n          \"pubtime\": 1474992000,\n          \"pure\": 0,\n          \"singer\": [\n            {\n              \"id\": 1132319,\n              \"mid\": \"004AcS5d1l7cmb\",\n              \"name\": \"陈一发儿\",\n              \"name_hilight\": \"陈一发儿\"\n            }\n          ],\n          \"size128\": 4128376,\n          \"size320\": 10320651,\n          \"sizeape\": 0,\n          \"sizeflac\": 0,\n          \"sizeogg\": 5557836,\n          \"songid\": 108756031,\n          \"songmid\": \"0041vb5D3WMtrl\",\n          \"songname\": \"童话镇\",\n          \"songname_hilight\": \"<em>童话镇</em>\",\n          \"songurl\": \"http://y.qq.com/#type=song&id=108756031\",\n          \"strMediaMid\": \"0041vb5D3WMtrl\",\n          \"stream\": 8,\n          \"switch\": 79671,\n          \"t\": 0,\n          \"tag\": 12,\n          \"type\": 0,\n          \"ver\": 0,\n          \"vid\": \"v0024ryy91z\"\n        }\n      ],\n      \"totalnum\": 92\n    },\n    \"taglist\": [\n    ],\n    \"totaltime\": 0,\n    \"zhida\": {\n      \"chinesesinger\": 0,\n      \"type\": 0\n    }\n  },\n  \"message\": \"\",\n  \"notice\": \"\",\n  \"subcode\": 0,\n  \"time\": 1497430745,\n  \"tips\": \"\"\n}\n\n```\n\n\n###音乐图片获取规则\n\n    取字段  albumid=0044cHmg45iock\n    \n    图片访问规则：http://imgcache.qq.com/music/photo/mid_album_{尺寸}/{albumid倒数第二个字符}/{albumid倒数第一个字符}/{albumid}.jpg\n    \n    例：90*90		http://imgcache.qq.com/music/photo/mid_album_90/c/k/0044cHmg45iock.jpg\n    例：300*300		http://imgcache.qq.com/music/photo/mid_album_300/c/k/0044cHmg45iock.jpg\n    例：500*500		http://imgcache.qq.com/music/photo/mid_album_500/c/k/0044cHmg45iock.jpg\n    \n\n###音乐播放地址获取规则\n	\n	取字段 songid=108756031    tag=12\n	\n    播放地址规则： http://ws.stream.qqmusic.qq.com/{songid}.m4a?fromtag={tag}\n    \n    例：http://ws.stream.qqmusic.qq.com/108756031.m4a?fromtag=12\n    \n\n\n    \n    \n    \n    \n    \n    \n\n', '2', '0', '2017-06-15 11:35:07'), ('54', '1021', '111', '###酷狗音乐用户服务协议\n\n[服务协议:http://www.kugou.com/about/protocol.html](http://www.kugou.com/about/protocol.html) \n\n######请不要用于商业途径获利，仅供参考与技术交流分享 \n\n######API分析源站 http://www.kugou.com/\n\n\n###酷狗音乐查询\nURL：http://songsearch.kugou.com/song_search_v2?keyword=${关键词}&page=1&pagesize=10&userid=-1&clientver=&platform=WebFilter&tag=em&filter=2&iscorrection=1&privilege_filter=0&_=1497494089309\nHTTP请求方式：get\n\n添加头信息\n\n    Cookie:kg_mid=897e37889b6dde6cf903c17f8cf3c91b; Hm_lvt_aedee6983d4cfc62f509129360d6bb3d=1497494083; Hm_lpvt_aedee6983d4cfc62f509129360d6bb3d=1497497122\n    Host:songsearch.kugou.com\n    Referer:http://www.kugou.com/yy/html/search.html\n    User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\n\n**额外参数：**\n\n|参数|名称|参数类型|默认值|是否必须|备注|\n|:----|:----|:----|:----|:----|:----|\n|keyword|搜索关键词|string|1|true|-|\n|page|页码|Integer|-|true|-|\n|pagesize|每页显示条数|Integer|-|true|-|\n|callback|jsonp 回调函数名|string|-|false|-|\n|_|时间戳|long|-|false|13位|\n\n返回结果\n```JSON\n{\n  \"status\": 1,\n  \"error_code\": 0,\n  \"data\": {\n    \"page\": 1,\n    \"tab\": \"全部\",\n    \"lists\": [\n      {\n        \"SongName\": \"<em>童话镇</em>\",\n        \"OwnerCount\": 4092505,\n        \"MvType\": 2,\n        \"TopicRemark\": \"\",\n        \"SQFailProcess\": 0,\n        \"Source\": \"\",\n        \"Bitrate\": 128,\n        \"HQExtName\": \"mp3\",\n        \"SQFileSize\": 27948216,\n        \"ResFileSize\": 0,\n        \"Duration\": 257,\n        \"MvTrac\": 3,\n        \"SQDuration\": 258,\n        \"ExtName\": \"mp3\",\n        \"Auxiliary\": \"\",\n        \"SongLabel\": \"\",\n        \"Scid\": 23216520,\n        \"FailProcess\": 0,\n        \"SQBitrate\": 866,\n        \"HQBitrate\": 325,\n        \"Audioid\": 23216520,\n        \"HiFiQuality\": 2,\n        \"Grp\": {},\n        \"AlbumPrivilege\": 0,\n        \"TopicUrl\": \"\",\n        \"SuperFileHash\": \"\",\n        \"ASQPrivilege\": 0,\n        \"M4aSize\": 1061096,\n        \"AlbumName\": \"<em>童话镇</em>\",\n        \"Privilege\": 0,\n        \"ResBitrate\": 0,\n        \"HQFailProcess\": 0,\n        \"SQPayType\": 0,\n        \"HQPrice\": 0,\n        \"Type\": \"audio\",\n        \"SourceID\": 0,\n        \"FileName\": \"陈一发儿 - <em>童话镇</em>\",\n        \"ID\": \"e28898886c2390ae0540ea5b98859bb9\",\n        \"SuperFileSize\": 0,\n        \"QualityLevel\": 3,\n        \"SQFileHash\": \"1246CA3CE991E85FAE20BD7A35EAF336\",\n        \"A320Privilege\": 0,\n        \"HQPrivilege\": 0,\n        \"SuperBitrate\": 0,\n        \"SuperDuration\": 0,\n        \"AlbumID\": \"1918064\",\n        \"ResFileHash\": \"\",\n        \"PublishAge\": 255,\n        \"SuperExtName\": \"\",\n        \"HQFileHash\": \"F59E3587418C889D49A799164E8D87AE\",\n        \"HQPayType\": 0,\n        \"PayType\": 0,\n        \"mvTotal\": 1,\n        \"Accompany\": 1,\n        \"HQFileSize\": 10485560,\n        \"PkgPrice\": 0,\n        \"FileSize\": 4128292,\n        \"SQExtName\": \"flac\",\n        \"AudioCdn\": 100,\n        \"HQPkgPrice\": 0,\n        \"SQPrice\": 0,\n        \"ResDuration\": 0,\n        \"OldCpy\": 1,\n        \"Price\": 0,\n        \"Publish\": 1,\n        \"SingerName\": \"陈一发儿\",\n        \"SQPrivilege\": 0,\n        \"MvHash\": \"19081CFE9BD82EED1EFA57215279C5ED\",\n        \"SQPkgPrice\": 0,\n        \"HQDuration\": 258,\n        \"OtherName\": \"\",\n        \"HasAlbum\": 1,\n        \"MixSongID\": \"\",\n        \"FileHash\": \"ED35367BD830D24073CCE802C075C6AD\"\n      }\n    ],\n    \"chinesecount\": 3,\n    \"searchfull\": 1,\n    \"correctiontype\": 0,\n    \"subjecttype\": 0,\n    \"aggregation\": [\n      {\n        \"key\": \"DJ\",\n        \"count\": 0\n      },\n      {\n        \"key\": \"现场\",\n        \"count\": 0\n      },\n      {\n        \"key\": \"广场舞\",\n        \"count\": 0\n      },\n      {\n        \"key\": \"伴奏\",\n        \"count\": 0\n      },\n      {\n        \"key\": \"铃声\",\n        \"count\": 0\n      }\n    ],\n    \"allowerr\": 0,\n    \"correctionsubject\": \"\",\n    \"correctionforce\": 0,\n    \"total\": 199,\n    \"istagresult\": 0,\n    \"istag\": 0,\n    \"correctiontip\": \"\",\n    \"pagesize\": 1\n  }\n}\n\n```\n\n\n###获取音乐图片、歌词和播放地址\n\nURL: http://www.kugou.com/yy/index.php?r=play/getdata&hash=${音乐HASH}&album_id={唱片ID}&_=1497494411688\nHTTP请求方式：get\n\n添加头信息\n	\n    Cookie:kg_mid=897e37889b6dde6cf903c17f8cf3c91b; Hm_lvt_aedee6983d4cfc62f509129360d6bb3d=1497494083; Hm_lpvt_aedee6983d4cfc62f509129360d6bb3d=1497497239\n    Host:www.kugou.com\n    Pragma:no-cache\n    Referer:http://www.kugou.com/song/\n    User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\n    X-Requested-With:XMLHttpRequest\n\n**额外参数：**\n\n|参数|名称|参数类型|默认值|是否必须|备注|\n|:----|:----|:----|:----|:----|:----|\n|hash|搜索关键词|string|1|true|-|\n|album_id|页码|Integer|-|true|-|\n|_|时间戳|long|-|false|13位|\n\n例：http://www.kugou.com/yy/index.php?r=play/getdata&hash=1246CA3CE991E85FAE20BD7A35EAF336&album_id=1918064&_=1497494411688\n\nHASH来源查询接口\n\n	普通音乐 FileHash=ED35367BD830D24073CCE802C075C6AD\n	高音质音乐 HQFileHash=F59E3587418C889D49A799164E8D87AE\n    无损音乐 SQFileHash=1246CA3CE991E85FAE20BD7A35EAF336\n\n返回结果\n\n```JSON\n\n{\n  \"status\": 1,\n  \"err_code\": 0,\n  \"data\": {\n    \"hash\": \"F59E3587418C889D49A799164E8D87AE\",\n    \"timelength\": 258000,\n    \"filesize\": 10485560,\n    \"audio_name\": \"陈一发儿 - 童话镇\",\n    \"have_album\": 1,\n    \"album_name\": \"童话镇\",\n    \"album_id\": \"1918064\",\n    \"img\": \"http://imge.kugou.com/stdmusic/20161003/20161003150211820473.jpg\",\n    \"have_mv\": 1,\n    \"video_id\": \"620331\",\n    \"author_name\": \"陈一发儿\",\n    \"song_name\": \"童话镇\",\n    \"lyrics\": \"[00:00.73]童话镇 - 陈一发儿\\r\\n[00:01.50]词：竹君\\r\\n[00:01.64]曲：暗杠\\r\\n[00:01.79]编曲：暗杠\\r\\n[00:23.20]听说白雪公主在逃跑\\r\\n[00:26.60]小红帽在担心大灰狼\\r\\n[00:29.91]听说疯帽喜欢爱丽丝\\r\\n[00:33.33]丑小鸭会变成白天鹅\\r\\n[00:36.79]听说彼得潘总长不大\\r\\n[00:40.20]杰克他有竖琴和魔法\\r\\n[00:43.58]听说森林里有糖果屋\\r\\n[00:46.83]灰姑娘丢了心爱的玻璃鞋\\r\\n[00:50.64]只有睿智的河水知道\\r\\n[00:53.80]白雪是因为贪玩跑出了城堡\\r\\n[00:57.35]小红帽有件抑制自己\\r\\n[01:00.77]变成狼的大红袍\\r\\n[01:03.93]总有一条蜿蜒在童话镇里七彩的河\\r\\n[01:11.02]沾染魔法的乖张气息\\r\\n[01:14.56]却又在爱里曲折\\r\\n[01:17.93]川流不息扬起水花\\r\\n[01:20.93]又卷入一帘时光入水\\r\\n[01:24.72]让所有很久很久以前\\r\\n[01:28.24]都走到幸福结局的时刻\\r\\n[01:47.48]听说睡美人被埋藏\\r\\n[01:50.53]小人鱼在眺望金殿堂\\r\\n[01:53.85]听说阿波罗变成金乌\\r\\n[01:57.33]草原有奔跑的剑齿虎\\r\\n[02:00.77]听说匹诺曹总说着谎\\r\\n[02:04.31]侏儒怪拥有宝石满箱\\r\\n[02:07.81]听说悬崖有颗长生树\\r\\n[02:11.08]红鞋子不知疲倦地在跳舞\\r\\n[02:14.64]只有睿智的河水知道\\r\\n[02:17.85]睡美人逃避了生活的煎熬\\r\\n[02:21.34]小人鱼把阳光抹成眼影\\r\\n[02:24.74]投进泡沫的怀抱\\r\\n[02:27.81]总有一条蜿蜒在童话镇里七彩的河\\r\\n[02:35.27]沾染魔法的乖张气息\\r\\n[02:38.65]却又在爱里曲折\\r\\n[02:42.01]川流不息扬起水花\\r\\n[02:44.98]又卷入一帘时光入水\\r\\n[02:48.87]让所有很久很久以前\\r\\n[02:52.30]都走到幸福结局的时刻\\r\\n[02:55.57]总有一条蜿蜒在童话镇里梦幻的河\\r\\n[03:02.61]分隔了理想分隔现实\\r\\n[03:05.96]又在前方的山口汇合\\r\\n[03:09.36]川流不息扬起水花\\r\\n[03:12.44]又卷入一帘时光入水\\r\\n[03:16.25]让所有很久很久以前\\r\\n[03:19.66]都走到幸福结局的时刻\\r\\n[03:22.73]又陌生\\r\\n\",\n    \"author_id\": \"544892\",\n    \"privilege\": 0,\n    \"privilege2\": \"0\",\n    \"play_url\": \"http://fs.web.kugou.com/c599520fa6ad91c66e3280e836768796/5941f490/G079/M03/06/15/L5QEAFfrrY6AUmOVAJ__OAaBscw363.mp3\",\n    \"authors\": [\n      {\n        \"is_publish\": \"1\",\n        \"author_id\": \"544892\",\n        \"avatar\": \"20161222154900283.jpg\",\n        \"author_name\": \"陈一发儿\"\n      }\n    ],\n    \"bitrate\": 325\n  }\n}\n\n\n```\n\n', '2', '0', '2017-06-15 13:57:00'), ('55', '1018', '67', '# sessionStorage不能跨标签页解决方案\n\n------------\n\n现有的浏览器存储机制\n\nlocalStorage ：~5MB，数据永久保存直到用户手动删除\nsessionStorage ：~5MB，数据只在当前标签页有效\ncookie ：~4KB，可以设置成永久有效\nsession cookie ：~4KB，当用户关闭浏览器时删除（并非总能立即删除）\n安全的认证token保存\n\n一些重要的系统会要求当用户关闭标签页时会话立刻到期。\n\n为了达到这个目的，不仅绝对不应该使用cookies来保存任何敏感信息（例如认证token）。甚至session-cookies也无法满足要求，它在标签页关闭（甚至浏览器完全关闭）后还会持续存活一定时间。\n\n（任何时刻我们都不应该只使用cookies，它还有其他很多问题需要讨论，例如CSRF）\n\n这些问题就使得我们在保存认证token时应使用内存或sessionStorage。sessionStorage的好处是它允许跨多个页面保存数据，并且也支持浏览器刷新操作。这样用户就可以在多个页面之间跳转或刷新页面而保持登录状态。\n\nGood。我们将token保存在sessionStorage，并在每次请求服务器时将token放在请求头中来完成用户的身份认证。当用户关闭标签页，token会立即过期。\n\n但多标签页怎么办？\n\n即便是在单页面应用中也有一个很常见的情况，用户经常希望打开多个标签页。而此场景下将token保存在sessionStorage中将会带来很差的用户体验，每次开启一个标签页都会要求用户重新登录。没错，sessionStorage不支持跨标签页共享数据。\n\n利用localStorage事件来跨标签页共享sessionStorage\n\n我利用localStorage事件提出了一种解决方案。\n\n当用户新开一个标签页时，我们先来询问其它已经打开的标签页是不是有需要给我们共享的sessionStorage数据。如果有，现有的标签页会通过localStorage事件来传递数据到新打开的标签页中，我们只需要复制一份到本地sessionStorage即可。\n\n传递过来的sessionStorage绝对不会保存在localStorage，从localStorage事件将数据中复制并保存到sessionStorage，这个流程是在同一个调用中完成，没有中间状态。而且数据是对应事件携带的，并不在localStorage中。（译者注：作者意图解释这个方案的安全性）\n\n在线例子\n\n点击“Set the sessionStorage”，然后打开多个标签页，你会发现sessionStorage共享了。\n\n```javascript\n// 为了简单明了删除了对IE的支持\n(function(){\n\nif(!sessionStorage.length) {\n// 这个调用能触发目标事件，从而达到共享数据的目的\n localStorage.setItem(\'getSessionStorage\',Date.now());\n };\n\n// 该事件是核心\nwindow.addEventListener(\'storage\',function(event){\nif(event.key ==\'getSessionStorage\') {\n// 已存在的标签页会收到这个事件\n localStorage.setItem(\'sessionStorage\',JSON.stringify(sessionStorage));\n localStorage.removeItem(\'sessionStorage\');\n\n } elseif(event.key ==\'sessionStorage\'&& !sessionStorage.length) {\n// 新开启的标签页会收到这个事件\nvardata =JSON.parse(event.newValue),\n value;\n\nfor(keyindata) {\n sessionStorage.setItem(key, data[key]);\n }\n }\n });\n})();\n```\n（译者注：上面的代码是我从在线demo中截取的，原文中并无提到）\n\n接近完美\n\n我们现在拥有了一个几乎非常安全的方案来保存会话token在浏览器里，并支持良好的多标签页用户体验。现在当用户关闭标签页后能确保会话立即过期。难道不是么？\n\nchrome和firefox都支持当用户进行“重新打开关闭的标签页”或“撤销关闭标签页”时恢复sessionStorage。F**k！（译者注：作者原文用的是“Damn it!”，注意到那个叹号了吗？）\n\nsafari在这个问题上处理是正确的，它并不会恢复sessionStorag（只测试了上述这三个浏览器）。\n\n对用户而言，能够确定sessionStorag已经过期的方法是直接重新打开网站，而不是选择“重新打开关闭的标签页”。\n\n除非chrome和firefox能够解决这个bug。（但我预感开发组会称其为“特性”）\n\n即便存在这样的bug，使用sessionStorag依然要比session-cookies方案或其他方案要安全。如果我们希望得到一个更加完美的方案，我们就需要自己来实现一个内存的方案来代替sessionStorag。(onbeforeunload也能做到，但不是太可靠且每次刷新页面也会被清空。window.name也不错，但它太老了且也不支持跨域保护)\n\n跨标签页共享memoryStorage\n\n这应该是唯一一个真正安全的实现浏览器端保存认证token的方法了，并且要保证用户打开多个标签页不需要重新登录。\n\n关闭标签页，会话立即过期–这次是真真儿的。\n\n这个方案的缺点是， 当只有一个标签页时 ，浏览器刷新会导致用户重新登录。安全总是要付出点代价的，很明显这个缺点可能是致命的。\n\n在线例子\n\n设置一个memoryStorage，然后打开多个标签页，你会发现数据共享了。关闭所有标签页token会立即永久过期（memoryStorage其实就是一个javascript对象而已）。\n\n```javascript\n(function(){\n\nwindow.memoryStorage = {};\n\nfunctionisEmpty(o){\nfor(variino) {\nreturnfalse;\n }\nreturntrue;\n };\n\nif(isEmpty(memoryStorage)) {\n localStorage.setItem(\'getSessionStorage\',Date.now());\n };\n\nwindow.addEventListener(\'storage\',function(event){\nif(event.key ==\'getSessionStorage\') {\n localStorage.setItem(\'sessionStorage\',JSON.stringify(memoryStorage));\n localStorage.removeItem(\'sessionStorage\');\n\n } elseif(event.key ==\'sessionStorage\'&& isEmpty(memoryStorage)) {\nvardata =JSON.parse(event.newValue),\n value;\n\nfor(keyindata) {\n memoryStorage[key] = data[key];\n }\n }\n });\n})();\n\n```', '2', '0', '2017-06-15 15:00:53'), ('56', '1018', '69', '# React+Redux 同构应用开发\n2017-05-24 15:13:02 星期三\n</br>\n### 1. 背景\n> 随着众多React + Redux 项目在团队中落地，基于此模式的单向数据流应用受到了广泛的推崇。但是在项目开发过程中，尤其是复杂单页应用，JS文件的体积往往高达数百KB。相较于以往开发模式（Kissy、jQuery、Zepto…）几十KB的体积，极大地增加了页面首次加载的时间。PC端中，这些问题并不突出，但对于移动端，尤其是弱网环境下，会大大增加用户的等待时间，从用户体验上来说，是极不友好的。\n\n### 2.服务端渲染（Server Rendering）\n> React中提出了 虚拟DOM 的概念，虚拟DOM以对象树的形式保存在内存中，与真实DOM相映射，通过ReactDOM的Render方法，渲染到页面中，并维护DOM的创建、销毁、更新等过程，以最高的效率，得到相同的DOM结构。\n\n> 虚拟DOM 给页面带来了前所未有的性能提升，但它的精髓不仅局限于此，还给我们带来了另一个福利： 服务端渲染 。\n\n> 不同于ReactDOM.render将DOM结构渲染到页面，React中还提供了另外两个方法：ReactDOMServer.renderToString 和 ReactDOMServer.renderToStaticMarkup 。二者将虚拟DOM渲染为一段字符串，代表了一段完整的HTML结构。\n\n### 3.同构（Isomorphic）\n\n> 通过React提供的服务端渲染方法，我们可以在服务器上生成DOM结构，让用户尽早看到页面内容，但是一个能够work的页面不仅仅是DOM结构，还包括了各种事件响应、用户交互。那么意味着，在客户端上，还得执行一段JS代码绑定事件、处理异步交互，在React中，意味着整个页面的组件需要重新渲染一次，反而带来了额外的负担。\n\n> 因此，在服务端渲染中，有一个十分重要的概念， 同构(Isomorphic) ，在服务端和客户端中，使用完全一致的React组件，这样能够保证两个端中渲染出的DOM结构是完全一致的，而在这种情况下，客户端在渲染过程中，会判断已有的DOM结构是否和即将渲染出的结构相同，若相同，不重新渲染DOM结构，只是进行事件绑定。\n\n### 4.配合Redux\n> 上述 服务端渲染 帮我们完成了组件层面的同构问题，对于要使用何种数据流并没有约束，在本次实践中，使用了Redux模式，关于Redux服务端渲染，参看官方文档。其中最重要的一点就是，在服务端和客户端保持 store 一致。\n\nstore 的初始状态在Server端生成，为了保持两个端中store的一致，官方示例中通过在页面插入脚本的方式，写入store初始值到window：\n```javascript\nwindow.__INITIAL_STATE__ = ${JSON.stringify(initialState)}\n```\n此处输出initialState到页面中，是十分危险的，一定要注意XSS的防范。\nRedux推荐使用 serialize-javascript 序列化JS对象，这一点十分必要。\n\n### 5.实践\n> 要进行服务端渲染，一个node server必不可少，Koa、Express 都是流行的Node端Web框架，前者似乎更受开发者青睐。\n\n### 6.Koa\n> Server端使用 Koa。配合如 xtemplate，koa-jade之类的视图模板，能够快速完成HTML页面的渲染。关于Koa的使用，并不是本文的重点，在此不过多阐述，选择一个顺手可靠的框架即可。\n\n##### 目录结构\n├── app                         //服务端\n│   ├── controllers                     //控制器\n│   ├── routes                          //路由\n│   ├── service                         //接口\n│   └── views                       //视图\n├── assets\n├── bin                         \n├── build                           //构建，css、js\n├── client                      //客户端\n│   ├── actions\n│   ├── api\n│   ├── components\n│   ├── constants\n│   ├── containers\n│   ├── less\n│   ├── reducers\n│   └── store\n├── lib\n├── logs\n├── mock\n└── webpack                     //Webpack配置\n\n**其中，所有React组件和Redux 模块都放在 /client 目录下，该目录下存放着一个和我们日常开发React+Redux完全一致的APP。**\n\n### 7.配置 Koa\n> 我们的HTML页面不再通过静态服务器获取，而是通过Koa Server，配置一个新路由，作为页面的入口。使用xtemplate for Koa作为View层，在/app/routes中新建路由：\n\n```javascript\n\'use strict\';\n\nvar HomeController = require(\'../controllers/home\');\nvar router = new (require(\'koa-router\'))();\nrouter.get(\'/home.html\', HomeController.index);\nmodule.exports = router;\n```\n\n在 /app/controllers中新建控制器：\n```javascript\n\'use strict\';\n\nexports.index = function* () {\n\n    //do something\n\n    yield this.render(\'home\');\n\n};\n```\n\'home\', 对应 /app/views下的视图文件\n\n### 8.服务端ES6/7支持\n通常，在客户端代码中，我们的编程风格里使用了大量的ES6/7语法，如import， class 等，但在服务端，这些语言特性Node还不能完全支持，这就需要我们使用相关的插件，帮助服务端识别此类语法。\n\n> #### 引入babel-register\n> > babel-register 通过绑定 require函数的方式（require hook）,在 require jsx文件时，使用babel转换语法，因此，应该在任何 jsx 代码执行前，执行 require(\'babel-register\')(config)，同时通过配置项config，配置babel语法等级、插件等。具体配置方法可参看官方文档。> babel-register 通过绑定 require函数的方式（require hook）,在 require jsx文件时，使用babel转换语法，因此，应该在任何 jsx 代码执行前，执行 require(\'babel-register\')(config)，同时通过配置项config，配置babel语法等级、插件等。具体配置方法可参看官方文档。\n\n> #### 处理CSS/LESS文件处理CSS/LESS文件\n> > babel-register 帮助服务端识别特殊的js语法，但对 less/css 文件无能为力，庆幸的是，在一般情况下，服务端渲染不需要样式文件的参与，css文件只要引入到HTML文件中即可，因此，可以通过配置项，忽略所有 css/less 文件:babel-register 帮助服务端识别特殊的js语法，但对 less/css 文件无能为力，庆幸的是，在一般情况下，服务端渲染不需要样式文件的参与，css文件只要引入到HTML文件中即可，因此，可以通过配置项，忽略所有 css/less 文件:\n```javascript\nrequire(\"babel-register\")({\n  // Optional ignore regex - if any filenames **do** match this regex then they\n  // aren\'t compiled. ignore: /(.css|.less)$/, });\n```\n完成jsx语法支持，就可以引入React组件或APP，通过 renderToString 方法进行服务端渲染：\n\n```javascript\n\'use strict\';\n\nimport React from \'react\';\nimport { renderToString } from \'react-dom/server\';\nimport { createStore } from \'redux\';\nimport configureStore from \'../../client/store/configureStore\';\nimport { Provider } from \'react-redux\';\nimport App from \'../../client/containers/home\';\nexports.index = function* () {\n    //do something\n    // 生成store\n    const store = configureStore();\n    // 从store中获取state\n    const finalState = store.getState();\n    const html = renderToString(\n        <Provider store={store}>\n             <App />\n        </Provider>\n    );\n    //将生成的html结构插入模版中\n    yield this.render(\'home\', {html: html});\n};\n```\n\n### 9.使用CSS Modules\n通过 babel-register 能够使用babel解决jsx语法问题，对 css/less 只能进行忽略，但在使用了 CSS Modules 的情况下，服务端必须能够解析 less文件，才能得到转换后的类名，否者服务端渲染出的 HTML 结构和打包生成的客户端 css 文件中，类名无法对应。\n\n为了解决这个问题，需要一个额外的工具 webpack-isomorphic-tools，帮助识别less文件。\n> #### webpack-isomorphic-tools\n简单地说，webpack-isomorphic-tools，完成了两件事：\n1. 以webpack插件的形式，预编译less（不局限于less，还支持图片文件、字体文件等），将其转换为一个 assets.json 文件保存到项目目录下。\n1. require hook，所有less文件的引入，代理到生成的 JSON 文件中，匹配文件路径，返回一个预先编译好的 JSON 对象。\n</br>\n上述过程解决了服务端渲染中不能解析非js文件的痛点，让我们使用CSS Modules时欲罢不能的快感，在服务端得以延续。\n配置文件十分冗长，配置细节可查阅官方文档。这里需要注意的是，webpack-isomorphic-tools 的 require hook，是通过一个回调函数进行的：\n```javascript\nvar WebpackIsomorphicTools = require(\'webpack-isomorphic-tools\'); \nglobal.webpackIsomorphicTools = new WebpackIsomorphicTools(require(\'../webpack/webpack-isomorphic-config\'))\n    .development(__DEVELOPMENT__)\n    .server(rootDir, function () {\n        //回调\n        require(\'./app.js\'); //启动 server\n    });\n```\nwebpack-isomorphic-tools 启动时，会先等待指定目录下 assets.json 文件生成，只有该文件就绪后，require hook 才会进行，进而触发 server 回调，只有在此回调中执行的代码，才能保证进行了require hook。\n\n### 10.环境变量\n另一个在同构应用中的常见问题就是环境变量，客户端开发中，只需要判断链接、URL参数等，但在server端，并没有清晰的host概念，同一个Server可以在多个host下被访问。 那么，一些环境参数的判断，就要通过环境变量进行。\n\n在webpack中，使用 DefinePlugin 定义环境变量（其实就是global变量）：\n```javascript\nplugins: [\n    ...\n    new webpack.DefinePlugin({\n        \'__ENV__\': JSON.stringify(\'development\'),\n        __CLIENT__: true,\n        __SERVER__: false,\n        __DEVELOPMENT__: true,\n        __DEVTOOLS__: true\n    }),\n    ...\n]\n```\n配置了不同环境变量的 webpack 配置文件，打包得到的也只是固定JS文件，如果要和服务端上多个环境（dev、prod）一一对应，需要使用多个配置文件来完成，发布到不同环境时，使用对应环境下的配置。\n\n### 11.构建\n通过 gulp，使用不同的 webpack 配置进行打包，生成对应静态资源，发布到CDN即可。\n\n这里需要注意的是，合理使用环境变量，和webpack插件，可以大大减少js文件的体积：\n```javascript\ngulp.task(\"env:prod\", function () {\n    env({\n        BABEL_ENV: \'production\',\n        NODE_ENV: \'production\'\n    });\n    prodConfig.plugins = prodConfig.plugins.concat(\n        new webpack.DefinePlugin({\n            \'process.env\': {\n                NODE_ENV: JSON.stringify(\'production\')\n            },\n            \'NODE_ENV\': JSON.stringify(\'production\'),\n            \'__ENV__\': JSON.stringify(\'production\')\n        }),\n        new webpack.optimize.DedupePlugin(),\n        new webpack.optimize.OccurenceOrderPlugin(),\n        // Compresses javascript files\n        new webpack.optimize.UglifyJsPlugin({\n            compress: {\n                warnings: false\n            }\n        })\n    );\n});\n```\n\n通过gulp任务，设置环境变量为production，webpack 将不会把 React 中如PropTypes检查之类的非必需代码打包，同时能够避免babel引入开发环境下的插件。\n\nDedupePlugin 和 UglifyJsPlugin 两个webpack插件必不可少，前者帮我们去除重复引入的js代码，后者进行js混淆压缩。\n\n本次项目中，开发阶段的代码 4MB+ 最终被压缩到了 300KB，发布到CDN，浏览器以gzip格式加载，实际大小约为 100KB，即使对于移动端而言，也是一个可以接受的大小。', '2', '0', '2017-06-15 15:06:50'), ('57', '1018', '118', '#### 1. 默认的内外边距不同\n问题：\n各个浏览器默认的内外边距不同\n解决：\n*{margin:0;padding:0;}\n#### 2. 水平居中的问题\n问题：\n设置 text-align: center  \nie6-7文本居中，嵌套的块元素也会居中\nff /opera /safari /ie8文本会居中，嵌套块不会居中\n解决：\n块元素设置\n1、`margin-left:auto;margin-right:auto`\n2、`margin:0 auto;`\n3、`<div align=”center”></div>`\n#### 3. 垂直居中的问题\n问题：\n在浏览器中想要垂直居中，设置vertical-align:middle; 不起作用。例如：ie6下文本与文本输入框对不齐，需设置vertical-align:middle，但是文本框的内容不会垂直居中\n解决：\n给容器设置一个与其高度相同的行高\nline-height:与容器的height一样\n#### 4. 关于高度问题\n问题：\n如果是动态地添加内容，高度最好不要定义。浏览器可以自动伸缩，然而如果是静态的内容，高度最好定好。\n如果设定了高度，内容过多时，ie6下会自动增加高度、其他浏览器会超出边框\n解决：\n1.设置overflow:hidden;\n2.高度自增height:auto!important;height:100px;\n#### 5. IE6 默认的div高度\n问题：\nie6默认div高度为一个字体显示的高度，所在ie6下div的高度大于等于一个字的高度，因此在ie6下定义高度为1px的容器，显示的是一个字体的高度\n解决：\n为这个容器设置下列属性之一\n1、设置overflow:hidden;\n2、设置line-height:1px;\n3、设置zoom:0.08\n \n#### 6. IE6 最小高度(宽度)的问题\n问题：\nie6不支持min-height、min-width属性，默认height是最小高度，width是最小宽度。\n解决：\n    使用ie6不支持但其余浏览器支持的属性!important。\n设置属性min-height:200px; height:auto !important; height:200px;\n#### 7. td高度的问题\n问题：\ntable中td的宽度都不包含border的宽度，但是oprea和ff中td的高度包含了border的高度\n解决：\n       设置line-height和height一样。在ie中如果td中的没有内容，那么border将不会显示\n#### 8. div嵌套p时，出现空白行\n问题：\ndiv中显示<p>文本</p>，ff、oprea、Chrome：top和bottom都会出现空白行，但是在ie下不会出现空白行。\n解决：\n设置p的margin:0px，再设置div的padding-top和padding-bottom\n#### 9. IE6-7图片下面有空隙的问题\n问题：\n块元素中含有图片时，ie6-7中会出现图片下有空隙\n解决： \n1、在源代码中让</div>和<img>在同一行\n2、将图片转换为块级对象display:block;\n3、设置图片的垂直对齐方式 vertical-align:top/middle/bottom\n4、改变父对象的属性，如果父对象的宽、高固定，图片大小随父对象而定，那么可以对父元素设置： overflow:hidden;\n5、设置图片的浮动属性  float:left;\n#### 10. IE6双倍边距的问题\n问题：\nie6中设置浮动，同时又设置margin时，会出现双倍边距的问题\n例float:left;width:100px;margin:0 100px;\n解决：\n       设置display:inline;\n#### 11. IE6 width为奇数，右边多出1px的问题\n问题：\n父级元素采用相对定位，且宽度设置为奇数时，子元素采用绝对定位，在ie6中会出现右侧多出1像素\n解决：\n将宽度的奇数值改成偶数\n#### 12. IE6两个层之间3px的问题\n问题：\n       左边层采用浮动，右边没有采用浮动，这时在ie6中两层之间就会产生3像素的间距\n解决：\n1、右边层也采用浮动  float\n2、左边层添加属性 margin-right:-3px;\n#### 13. IE6 子元素绝对定位的问题\n问题：\n       父级元素使用padding后，子元素使用绝对定位，不能精确定位\n解决：\n       在子元素中设置  _left:-20px; _top:-1px;\n#### 14. 显示手型cursor:hand\n问题：\n      ie6/7/8、opera      都支持  \n 但是safari 、 ff 不支持\n解决：\n写成 cursor:pointer;  (所有浏览器都能识别)  \n#### 15. IE6-7 line-height失效的问题\n问题：\n      在ie中img与文字放一起时， line-height不起作用 \n解决：\n都设置成float\n#### 16. td自动换行的问题\n问题：\nTable宽度固定，td自动换行\n解决：\n设置Table的table-layout:fixed，td的word-wrap:break-word\n#### 17. 子容器浮动后，父容器扩展问题\n问题：\n子容器都float以后，父容器没有设定高度,父容器将不会扩展\n解决：\n只需要添加一个clear:both的div，代码如下：\n<div style=\"border:1px solid#333;width:204px\">\n    <divstyle=\"width:100px;border:1px solid #333; float:left; \">子容器a</div>\n    <divstyle=\"width:100px;border:1px solid #333; float:left;\">子容器b</div>\n    <divstyle=\"clear:both\"></div>\n</div>\n#### 18. 透明png图片会带背景色\n问题：\n在ie6下透明的png图片会带一个背景色\n解决：\nbackground-image: url(icon_home.png);\nbackground-repeat: no-repeat;\n_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'icon_home.png\');\n_background-image: none;\n#### 19. list-style-position默认值的问题\n问题：\nie下list-style-position默认为inside,  firefox默认为outside\n解决：\ncss中指定为outside即可解决兼容性问题\n \n#### 20. list-style-image准确定位的问题\n问题：\n       li前设置图片时，图片与其后的文字对齐问题\n解决：\n1、采用背景定位 和 字符缩进的方法\nbackground:url() no-repeat left center;text-index:16px;\n2、采用相对定位方法\nli 设置list-style:url();\nli的子元素position:relative;top:-5px;\n#### 21. ul标签默认值的问题\n问题：\n       ul标签在ff中默认是有padding值的,而在ie中只有margin有值\n解决：\n       定义ul{margin:0;padding:0;}就能解决大部分问题\n#### 22. IE中li指定高度后，出现排版错误\n问题：\n在ie下如果为li指定高度可能会出现排版错位\n解决：\n       设置line-height\n#### 23. ul或li浮动后，显示在div外\n问题：\ndiv中的ul或li设置float以后，都不在div中\n解决：\n必须在ul标签后加<div style=\"clear:both\"></div>来闭合外层div\n#### 24. ul浮动后，margin变大\n问题：\nul设置 float后，在ie中margin将变大\n解决：\n设置ul的display:inline，li的list-style-position:outside\n#### 25. li浮动后，margin变大\n问题：\nli设置 float后，在ie中margin将变大\n解决：\n设置li的display:inline\n#### 26. 嵌套使用ul、li的问题\n问题：\nie的bug，嵌套使用ul、li时，里层的li设置float以后，外层li不设置float, 里面的ul顶部和它外面的li总是有一段间距\n解决：\n设置里面的ul的zoom:1\n \n#### 27. IE6-7 li底部有3px的问题\n问题：\n       这个bug产生的充要条件是li的子元素浮动并且li设置了以下CSS属性之一：width、height、zoom、padding-top、padding-bottom、margin-top、margin-bottom。\n解决：\n1、div设置clear:left|both，这时li不能设置width、height、zoom。\n2、li设置float:left，这时li可以设置width、height、zoom。\n3、li设置clear:left|both，这时li不能设置width、height、zoom。\n4、IE6/IE7的这个Bug可以通过给li中的div设置vertical-align:top|middle|bottom解决。\n \n#### 28. IE6 垂直列表间隙的问题\n问题：\n       li中有a且设置display:block时，ie6中列表间会出现空隙\n解决：\n1、li中加display:inline;\n2、li使用float 然后 clear:both;\n3、给包含的文本末尾添加一个空格\n4、设置width\n \n#### 29. IE6 列表背景颜色失效的问题\n问题：\n当父元素设置position:relative;时，在ie6中第一个ul、ol、dl的背景颜色失效\n解决：\n       ul、ol、dl 都设置为position:relative;\n \n#### 30. IE6-7 列表背景颜色失效的问题2\n问题：\n做横向导航栏时，ul设置为float且有背景色，li设置为float。ie6-7背景颜色失效\n解决：\n很多ie的bug都可以通过触发layout来解决 ul添加属性\n1、height:1%;\n2、float:left;\n3、zoom:1;\n \n#### 31. 列表不能换行的问题\n问题：\n       li设置为浮动，后面的li紧随其后，不能换行\n解决：\n1、为这个ul定义合适的宽高\n2、给包含这个ul 的父div定义合适的宽高。\n \n#### 32. li中的内容以省略号显示\n问题：\nli中内容超过长度时，想以省略号显示， 此方法适用于ie6-7-8、opera、safari浏览器 \nff浏览器不支持\n解决：\n`li{width:200px;white-space:nowrap;text-overflow:ellipsis;\n-o-text-overflow:ellipsis; overflow:hidden; }`\n \n#### 33. 超链接访问过后hover样式不出现的问题\n问题：\n       点击超链接后，hover、active样式没有效果\n解决：\n       改变CSS属性的排列顺序: L-V-H-A\n \n#### 34. 禁用中文输入法的问题\n问题：\n       不能在输入框中输入汉字\n解决：\n只在ie系列和ff中有效\nime-mode:disabled    (但可以粘贴)\n禁用粘贴：\nonpaste=\"return false\"\n \n#### 35. 除去滚动条的问题\n问题：\n       隐藏滚动条\n解决：\n1、只有ie6-7支持`<body scroll=\"no\">`\n2、除ie6-7不支持 body{overflow:hidden}\n3、所有浏览器 html{overflow:hidden}\n \n#### 36. 让层显示在FLASH之上\n问题：\n       想让层的内容显示在flash上\n解决：\n把FLASH设置透明\n`1、<param name=\" wmode \" value=\"transparent\" />`\n`2、<param name=\"wmode\" value=\"opaque\"/>` \n#### 37. 去除链接虚线边框的问题\n问题：\n当点击超链接后，ie6/7/8  ff会出现虚线边框 ,而opera、safari没有虚线边框\n解决：\nie6/7中 设置为a {blr:expression_r(this.onFocus=this.blur()) }\nie8 和 ff 都不支持expression 在ie8 、ff中设置为  :focus { outline: none; }\n \n#### 38. css滤镜的问题\n问题：\n    css滤镜只在ie中有效，Firefox, Safari(WebKit), Opera只能够设置透明，它们不支持滤镜filter，无法实现图片切换中间变换的效果，只能通过透明度来设置。\n解决：\n       ff中设置透明度   -moz-opacity:0.10; opacity:0.6;\nie中只设置filter:alpha(opacity=50);时，ie6-7失效，还要设置\n1、zoom:1;  2、width:100%;\n \n#### 39. IE6背景闪烁的问题\n问题：\n       链接、按钮用CSS sprites作为背景，在ie6下会有背景图闪烁的现象。原因是:IE6没有将背景图缓存，每次触发hover的时候都会重新加载\n解决：\n可以用JavaScript设置ie6缓存这些图片：\ndocument.execCommand(\"BackgroundImageCache\",false,true);\n \n#### 40. 出现重复文字的问题\n问题：\n```html\n<div style=\"width:400px\">\n  <div style=\"float:left\"></div>\n  <!– _ –>\n  <div style=\"float:right;width:400px\">↓这就是多出来的那只猪</div>\n</div>\n```\n解决：\n1、  改变结构，不出现【一个容器包含2两个具有“float”样式的子容器】的结构。\n2、减小第二个容器的宽度，使父容器宽度减去第二个容器宽度的值大于3\n3、去掉所有的注释。\n4、修正注释的写法。<!--[if!IE]>这里是注释内容<![endif]-->\n5、在第二个容器后面加一个或者多个<divstyle=\"clear\"></div>来解决。\n#### 41. ff、chrome绝对定位无效\n问题：\n在IE给td设置position:relative，然后给它包含的一个容器使用position:absolute进行定位是有效的，但在FF和Chrome下却不可以。\n解决：\n设置td的display:block。\n \n#### 42. IE6 绝对定位的问题\n问题：\n```html\n<div style=\"position:relative;border:1px solid orange;text-align:center;\">\n<div style=\"position:absolute;top:0;left:0;\nbackground:#CCC;\">dovapour</div>\n<a href=\"#\" title=\"vapour的blog\">内容</a>\n</div>\n```\n解决：\nleft的定位错误问题\n1、给父层设置zoom:1触发layout。\n2、给父层设置宽度width\n \nbottom的定位错误问题\n1、给父层设置zoom:1触发layout。\n2、给父层设置高度height\n \n#### 43. 子容器宽度大于父容器宽度时，内容超出\n问题：\n子DIV的宽度和父DIV的宽度都已经定义，在IE6中如果其子DIV的宽度大于父DIV的宽度，父DIV的宽度将会被扩展，在其他浏览器中父DIV的宽度将不会扩展，子DIV将超出父DIV\n解决：\n设置overflow:hidden，子DIV将不会超出父DIV。\n#### 44. float的div闭合的问题\n问题：\n例如：\n`<div id=”floatA” ><div id=”floatB” ><div id=”NOTfloatC” >`\n这里的NOTfloatC并不希望继续平移，而是希望往下排。(其中floatA、floatB的属性已经设置为float:left;)  \n这段代码在IE中毫无问题，问题出在其他浏览器中。原因是NOTfloatC并非float标签，必须将float标签闭合。\n解决：\n在 <#div class=”floatB”> <#div class=”NOTfloatC”>之间加上 <#div class=”clear”>这个div一定要注意位置，而且必须与两个具有float属性的div同级，之间不能存在嵌套关系，否则会产生异常。并且将clear这种样式定义为为如下即可：.clear{ clear:both;}\n \n#### 45. 单选框、复选框与后面的文字对不齐\n问题：\n     单选框、复选框与后面的文字对不齐。\n解决：\n```css\n.align{font-size:12px;}\n.align input{ display:block; float:left;}\n.align label{ display:block; float:left;padding-top:3px; *padding-top:5px;}\n```', '2', '0', '2017-06-15 15:17:49'), ('58', '1018', '119', '###### 1.使用虚拟DOM作为其不同的实现。同时可以由服务器node.js渲染，从而不需要过重的浏览器DOM支持。\n \n###### 2.虚拟DOM:在浏览器端用javascript实现了一套DOM API。用react开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，react都会重新构建整个DOM树，然后将当前整个DOM树和上一次的进行对比，得到区别后，仅仅将需要变化的部分进行实际浏览器的DOM树更新。从而使程序员只需要关心数据整体，两次数据之间的UI如何变化，就交给框架去做。\n \n###### 3. React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=\"text/jsx\" 。 其次，React 提供两个库： react.js 和 JSXTransformer.js ，它们必须首先加载。其中，JSXTransformer.js 的作用是将 JSX 语法转为 JavaScript 语法。这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。\n \n### 4.一个最基本的react组件\n```javascript\nvar Greet = React.createClass({\n	render:function(){\n		return <h1>Hello {this.props.name}</h1>;\n	}\n});\nReact.render(\n	<Greet name=\"Jack\" />,\n	document.getElementById(\'container\')\n);\n```\n###### 有几点需要注意：\n\n 1）获取属性的值用的是this.props.属性名\n\n 2）创建的组件名称首字母必须大写。\n\n 3）为元素添加css的class时，要用className。\n\n 4）组件的style属性的设置方式也值得注意，要写成style={{width: this.state.witdh}}。这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。\n\n \n\n \n\n### 5.组件状态\n###### react将组件看做一个状态机，一旦组件的状态发生改变，react就会触发重新渲染UI(自动调用this.render)。通过this.state.XX来定义和设置用户自定义的状态。而getInitialState函数则是在组件初始化时执行，返回null或一个对象。例：\n\n```javascript\nvar InputState = React.createClass({\n\n            getInitialState:function(){\n\n                return {enable:false};\n\n            },\n\n            handleClick:function(event){\n\n                this.setState({enable:!this.state.enable});\n\n            },\n\n            render:function(){\n\n                return (\n\n                    <p>\n\n                        <input type=\"text\" disabled={this.state.enable} />\n\n                        <button onClick={this.handleClick}>Change State</button>\n\n                    </p>\n\n                );\n\n            }\n\n        });\n```\n\n 这里值得注意的几点如下：\n\n 1）getInitialState函数必须有返回值，可以是NULL或者一个对象。\n\n 2）访问state的方法是this.state.属性名。\n\n 3）变量用{}包裹，不需要再加双引号。\n\n \n\n### 6.react组件的生命周期有3个\n\nMounting：已插入真实 DOM\nUpdating：正在被重新渲染\nUnmounting：已移出真实 DOM\n\n每个状态都有两种处理函数，will在进入状态前执行，did在进入之后执行，共五种处理函数：\n\n```javascript\ncomponentWillMount()\n\ncomponentDidMount()\n\ncomponentWillUpdate(object nextProps, object nextState)\n\ncomponentDidUpdate(object prevProps, object prevState)\n\ncomponentWillUnmount()\n```\n\n此外，react还提供2种特殊状态的处理函数：\ncomponentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用\nshouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用\n\n###  7.this.props \n对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点7.this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点\n\n这里需要注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。\n\nReact 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考\n\nhttps://facebook.github.io/react/docs/top-level-api.html#react.children\n\n \n\n#### 8.组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。\n\n组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求\n\n```javascript\nvar MyTitle = React.createClass({\n	propTypes:{\n		title: React.PropTypes.string.isRequired,},\n\n	render:function(){return<h1>{this.props.title}</h1>;}});\n```\n\n这样，就规定了MyTitle的title属性是必须的，且类型为字符串。如果不符合要求，控制台就会报错。\n\n更多的PropTypes设置，可以查看官方文档。\n\n此外，getDefaultProps 方法可以用来设置组件属性的默认值。\n\n```javascript\ngetDefaultProps :function(){return{\n      title :\'Hello World\'};},\n```\n\n#### 9.组件并不是真实的DOM节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM 。\n\n但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性\n```javascript\nvar MyComponent = React.createClass({\n  handleClick:function(){\n    this.refs.myTextInput.focus();},\n  render:function(){return(<div><input type=\"text\" ref=\"myTextInput\"/><input type=\"button\" value=\"Focus the text input\" onClick={this.handleClick}/></div>);}});\n```\n文本输入框有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性。\n\n##### 10.组件的构造规则跟函数或者对象的构造规则有异曲同工之妙，最大的共同点就是单一功能原则，即一个组件应该尽量只做一件事情，如果它的功能逐渐扩大就需要被拆分为更小的子组件。\n\n### 11.判断数据是否是state的方法：\n（1）是否是从父级通过props传入的？如果是，可能不是state。\n（2）是否会随着时间改变？如果不是，可能不是state。\n（3）能根据组件中其它state数据或者props计算出来吗？如果是，就不是state。\n\n### 12.如何判断哪些组件应该拥有哪些state？\n\n###### 13.常用的通知React 数据变化的方法是调用 setState(data, callback) 。这个方法会合并（merge） data 到 this.state，并重新渲染组件。渲染完成后，调用可选的callback 回调。大部分情况下不需要提供 callback ，因为 React 会负责把界面更新到最新状态。尝试把尽可能多的组件无状态化。 这样做能隔离 state，把它放到最合理的地方，也能减少冗余并，同时易于解释程序运作过程。常用的模式是创建多个只负责渲染数据的无状态（stateless）组件，在它们的上层创建一个有状态（stateful）组件并把它的状态通过 props 传给子级。这个有状态的组件封装了所有用户的交互逻辑，而这些无状态组件则负责声明式地渲染数据。\n\n###### 15.如果子级要在多个渲染阶段保持自己的特征和状态，在这种情况下，你可以通过给子级设置惟一标识的 key 来区分。当 React 校正带有 key 的子级时，它会确保它们被重新排序（而不是破坏）或者删除（而不是重用）。 务必把 key 添加到子级数组里组件本身上，而不是每个子级内部最外层 HTML 上。\n \n###### 16.有时候为了控制性能，需要在数据变化后不更新界面，这种情况下，可以重写shouldComponetUpdate()方法使其返回false来让react跳过对子树的处理。\n\n注： 如果在数据变化时让 shouldComponentUpdate() 返回 false，React 就不能保证用户界面同步 。当使用它的时候一定确保你清楚到底做了什么，并且只在遇到明显性能问题的时候才使用它。不要低估 JavaScript 的速度，DOM 操作通常才是慢的原因。\n\n17. 传递Props的技巧，如果想把传入组件的全部props复制到对应的HTML元素上，\n`<a {...this.props}>`\n即可。有时候不需要传递所有属性，可使用\n` var { checked, ...other } = this.props; `\n再调用other即代表除了checked以外所有的props,而checked就是this,props.checked，可以直接使用，多个属性可以用逗号隔开。如果不使用 JSX，可以使用一些库来实现相同效果。Underscore 提供 _.omit 来过滤属性， _.extend 复制属性到新的对象。P60\n\n```javascript\nvar FancyCheckbox = React.createClass(\n \n\n    render: function() {\n \n\n        var checked = this.props.checked;\n \n\n        var other = _.omit(this.props, \'checked\');\n \n\n        var fancyClass = checked ? \'FancyChecked\' : \'FancyUnchecked\';\n \n\n        return (\n \n\n            React.DOM.div(_.extend({}, other, { className: fancyClass }))\n \n\n        );\n \n\n    }\n \n\n});\n```\n\n###### 18.propTypes的用法，见P52，限制props的类型。也可以限制children的个数。\n \n###### 19.有时一些复杂的组件需要公用一些功能，类似跨切面关注点，react里使用mixins来解决这类问题。\n\n例如： 一个组件需要定期更新。用 setInterval() 做很容易，但当不需要它的时候取消定时器来节省内存是非常重要的。\n\n\n###### 20.设置了 value 的 是一个受限组件。 对于受限的 ，渲染出来的 HTML 元素始终保持 value属性的值。要想改变就需要使用onChange事件。如果既想给组件赋一个初始值，又想反应用户对组件值的改变，可以设置defaultValue,同理，类型为radio 、 checkbox 的 支持 defaultChecked 属性，支持 defaultValue 属性.\n\n###### 21.React中`<select>`元素设置选中使用value属性，而不是option的select属性。\n \n###### 22.为了和浏览器交互，有时候需要对DOM节点的引用，使用refs和getDOMNode()即可，注意只有在组件已经放进了DOM中时，此方法才有用。\n \n23.组件的生命周期\nReact组件的生命周期主要包括 挂载、更新和移除 三个部分。\n挂载期函数： \n（1）getInitialState(): object 在组件被挂载之前调用。状态化的组件应该实现这个方法，返回初始的state数据。\n\n（2）componentWillMount() 在挂载发生之前立即被调用。\n（3）componentDidMount() 在挂载结束之后马上被调用。需要DOM节点的初始化操作应该放在这里。\n\n更新期函数：\n（1）componentWillReceiveProps(object nextProps) 当一个挂载的组件接收到新的props的时候被调用。该方法应该用于比较this.props 和 nextProps ，然后使用 this.setState() 来改变state。\n（2）shouldComponentUpdate(object nextProps, object nextState): boolean 当组件做出是否要更新DOM决定的时候被调用。实现该函数，优化 this.props 和 nextProps ，以及 this.state 和 nextState 的比较，如果不需要React更新DOM，则返回false。\n（3）componentWillUpdate(object nextProps, object nextState) 在更新发生之前被调用。你可以在这里调用 this.setState()。\n（4）componentDidUpdate(object prevProps, object prevState) 在更新发生之后调用。\n\n移除期函数：\n（1）componentWillUnmount() 在组件移除和销毁之前被调用。清理工作应该放在这里。\n\n### 25. Immutable-js\nimmutable-js提供了通过结构性共享一成不变持久化集合。让我们看看这些性能：\n\n• 不可变的：一旦创建，集合不能在另一个时间点改变。\n\n• 持久性：新的集合可以由从早先的集合和突变结合创建。在创建新的集合后，原来集合仍然有效。\n\n• 结构共享：使用新的集合创建为与对原始集合大致相同的结构，减少了拷贝的最低限度，以实现空间效率和可接受的性能。如果新的集合等于原始的集合，则通常会返回原来的集合。\n\n不变性使得跟踪更改方便;而变化将总是产生在新的对象，所以我们只需要检查的已经改变参考对象。\n\n即原始的对象是不变的，每当对原始数据进行改变，会创建一个新的对象。\n\n例：\n```javascript\nvar SomeRecord = Immutable.Record({ foo: null });\nvar x = new SomeRecord({ foo: \'bar\' });\nvar y = x.set(\'foo\', \'baz\');\nx === y; // false\n```\n\n### 26.  React API\n```javascript\n（1）React.createClass  不再赘述。\n（2）React.createElement:\n	ReactElement createElement(\n	string/ReactClass type,\n	[object props],\n	[children ...]\n	)\n```\n创建并返回一个新的指定类型的 ReactElement。type 参数可以是一个 html 标签名字字符串（例如，“div”，“span”，等等），或者是 ReactClass （通过 React.createClass 创建的）。\n（3）React.createFactory：\n`	factoryFunction createFactory(\n	string/ReactClass type\n	)`\n 返回一个生成指定类型 ReactElements 的函数。比如 React.createElement，type 参数可以是一个 html 标签名字字符串（例如，“div”，“span”，等等），或者是 ReactClass 。\n（4） boolean unmountComponentAtNode(DOMElement container)\n从 DOM 中移除已经挂载的 React 组件，清除相应的事件处理器和 state。如果在 container 内没有组件挂 载，这个函数将什么都不做。如果组件成功移除，则返回 true ；如果没有组件被移除，则返回 false 。\n(5）string renderToString(ReactElement element)\n把组件渲染成原始的 HTML 字符串。该方法应该仅在服务器端使用。React 将会返回一个 HTML 字符串。你可以在服务器端用此方法生成 HTML，然后将这些标记发送给客户端，这样可以获得更快的页面加载速度，并且有利于搜索引擎抓取页面，方便做 SEO。\n（6） string renderToStaticMarkup(ReactElement element)\n 和 renderToString 类似，除了不创建额外的 DOM 属性，例如 data-react-id ，因为这些属性仅在 React 内部使用。如果你想用 React 做一个简单的静态页面生成器，这是很有用的，因为丢掉额外的属性能够节省很多字节。\n（7）React.isValidElement\nboolean isValidElement(* object)判断对象是否是一个 ReactElement。\n（8）initializeTouchEvents(boolean shouldUseTouch)\n 配置 React 的事件系统，使 React 能处理移动设备的触摸（ touch ）事件。\n（9）React.ChildrenReact.Children\n React.Children 为处理 this.props.children 这个封闭的数据结构提供了有用的工具。\n\n### 27.ReactComponent\n React 组件实例在渲染的时候创建。这些实例在接下来的渲染中被重复使用，可以在组件方法中通过 this 访问。唯一一种在 React 之外获取 React 组件实例句柄的方式就是保存 React.render 的返回值。在其它组件内，可以使用 refs 得到相同的结果。\n（1）setState(object nextState[, function callback]))\n 合并 nextState 和当前 state。这是在事件处理函数中和请求回调函数中触发 UI 更新的主要方法。另外，也支持可选的回调函数，该函数在 setState 执行完毕并且组件重新渲染完成之后调用。\n注：setState() 不会立刻改变 this.state ，而是创建一个即将处理的 state 转变。在调用该方法之后获取 this.state 的值可能会得到现有的值，而不是最新设置的值。   \n（2）replaceState(object nextState[, function callback])类似于 setState()，但是删除之前所有已存在的 state 键，这些键都不在 nextState 中。\n（3）forceUpdate([function callback])\n如果 render() 方法从 this.props 或者 this.state 之外的地方读取数据，你需要通过调用 forceUpdate() 告诉 React 什么时候需要再次运行 render()。如果直接改变了 this.state ，也需要调用 forceUpdate()。\n注：应该尽量避免使用forceUpdate的情况。\n（4）bool isMounted()\n如果组件渲染到了 DOM 中， isMounted() 返回 true。可以使用该方法保证 setState() 和 forceUpdate() 在异步场景下的调用不会出错。\n\n###### 28.render() 函数应该是纯粹的，也就是说该函数不修改组件 state，每次调用都返回相同的结果，不读写 DOM 信息，也不和浏览器交互（例如通过使用 setTimeout ）。如果需要和浏览器交互，在 componentDidMount()中或者其它生命周期方法中做这件事。保持 render() 纯粹，可以使服务器端渲染更加切实可行，也使组件更容易被理解。\n\n### 29.object statics\nstatics 对象允许你定义静态的方法，这些静态的方法可以在组件类上调用。\n\n### 30. React 也提供了一些 DOM 里面不存在的属性。\n • key ：可选的唯一的标识器。当组件在 渲染 过程中被各种打乱的时候，由于差异检测逻辑，可能会被销毁后重新创建。给组件绑定一个 key，可以持续确保组件还存在 DOM 中。 \n • ref：参考这里 (页 0)。\n • dangerouslySetInnerHTML ：提供插入纯 HTML 字符串的功能，主要为了能和生成 DOM 字符串的库整合。\n\n### 31.React的渲染策略\n\n（1）若前后两个节点元素或者组件的类型不同，React会直接把他们当做不同的子树，甚至不会尝试计算出该渲染什么，直接从DOM中移除之前的节点，然后插入新的节点。\n\n（2）比较两个DOM节点的时候，查看两者的属性，然后找出变化的属性。\n\n（3）对于自定义组件，React决定2个自定义组件是相同的，利用新组件上的所有属性，然后再之前的组件实例上调用componetWill(Did)ReceiveProps()。现在，之前的组件的render(0被调用，然后差异算法重新比较新的状态和上一次的状态。\n\n（4）为了完成子级更新，React同时遍历两个子级列表，当发现差异的时候，就产生一次DOM修改。        \n\n在开始处插入元素比较麻烦。React 发现两个节点都是 span，因此直接修改已有 span 的文本内容，然后在后面插入一个新的 span 节点。\n\n```javascript\nrenderA:<div><span>first</span></div>\nrenderB:<div><span>secon</span><span>first</span></div>\n=> [replaceAttribute textContent \'second\'], [insertNode <span>first</span>]\n```\n\n为了解决这个问题，引入了一个可选的属性keys。如果指定了一个键值，React 就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为O(n)。\n\n注：键值只需要在兄弟节点中唯一，而不是全局唯一。\n\n### 32.行内样式：\n```javascript\nvar divStyle = {\n	color: \'white\',\n	backgroundImage: \'url(\' + imgUrl + \')\',\n	WebkitTransition: \'all\', // 注意这里的首字母\'W\'是大写\n	msTransition: \'all\' // \'ms\'是唯一一个首字母需要小写的浏览器前缀\n};\n\nReact.render(Hello World!, mountNode);\n```\n\n33.通常，一个组件的子代（this.props.children）是一个组件的数组，即为数组类型，但是当只有一个子代的时候，this.props.children是一个单独的组件，而不是数组形式，这样就减少了数组的占用。\n\n34.getInitialState里的props是一个反模式。详情见P118。\n\n35.给DOM元素绑定React未提供的事件，比如想共用react和jquery的时候，在componentDidMount中 调用  \n\ncomponent.addEventListener(\'xxx\', this.handleResize) 绑定事件，在componentWillUnmount中removeEventListener()取消绑定。\n\n36.在 componentDidMount 时加载数据。当加载成功，将数据存储在 state 中，触发 render 来更新你的 UI。\n当执行同步请求的响应时，在更新 state 前， 一定要先通过 this.isMounted() 来检测组件的状态是否还是 mounted。', '2', '0', '2017-06-16 10:33:47');
INSERT INTO `note_detail` VALUES ('59', '1018', '120', '### 一、HTML 模板\n\n使用 React 的网页源码，结构大致如下。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      // ** Our code goes here! **\n    </script>\n  </body>\n</html>\n```\n上面代码有两个地方需要注意。首先，最后一个 `<script>` 标签的 type 属性为 `text/babel` 。这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 `type=\"text/babel\"` 。\n其次，上面代码一共用了三个库： react.js 、react-dom.js 和 Browser.js ，它们必须首先加载。其中，react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。\n\n`$ babel src --out-dir build`\n\n上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录。\n\n## 二、ReactDOM.render()\n\nReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。\n\n```javascript\nReactDOM.render(\n  <h1>Hello, world!</h1>,\n  document.getElementById(\'example\')\n);\n```\n上面代码将一个 h1 标题，插入 example 节点（查看 demo01），运行结果如下。\n\n### 三、JSX 语法\n\n上一节的代码， HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写（查看 Demo02 ）。\n```javascript\nvar names = [\'Alice\', \'Emily\', \'Kate\'];\n\nReactDOM.render(\n  <div>\n  {\n    names.map(function (name) {\n      return <div>Hello, {name}!</div>\n    })\n  }\n  </div>,\n  document.getElementById(\'example\')\n);\n```\n上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 < 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。上面代码的运行结果如下。\n\nJSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员（查看 demo03 ）。\n```javascript\nvar arr = [\n  <h1>Hello world!</h1>,\n  <h2>React is awesome</h2>,\n];\nReactDOM.render(\n  <div>{arr}</div>,\n  document.getElementById(\'example\')\n);\n```\n上面代码的arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板，运行结果如下。\n\n##四、组件\n\nReact 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类（查看 demo04）。\n\n```javascript\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <h1>Hello {this.props.name}</h1>;\n  }\n});\n\nReactDOM.render(\n  <HelloMessage name=\"John\" />,\n  document.getElementById(\'example\')\n);\n```\n\n上面代码中，变量 HelloMessage 就是一个组件类。模板插入 `<HelloMessage />` 时，会自动生成 HelloMessage 的一个实例（下文的\"组件\"都指组件类的实例）。所有组件类都必须有自己的 render 方法，用于输出组件。\n注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。\n\n```javascript\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <h1>\n      Hello {this.props.name}\n    </h1><p>\n      some text\n    </p>;\n  }\n});\n```\n上面代码会报错，因为HelloMessage组件包含了两个顶层标签：h1和p。\n组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 <HelloMessage name=\"John\"> ，就是 HelloMessage 组件加入一个 name 属性，值为 John。组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。上面代码的运行结果如下。\n\n添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。\n\n### 五、this.props.children\n\nthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点（查看 demo05）。\n```javascript\nvar NotesList = React.createClass({\n  render: function() {\n    return (\n      <ol>\n      {\n        React.Children.map(this.props.children, function (child) {\n          return <li>{child}</li>;\n        })\n      }\n      </ol>\n    );\n  }\n});\n\nReactDOM.render(\n  <NotesList>\n    <span>hello</span>\n    <span>world</span>\n  </NotesList>,\n  document.body\n);\n```\n上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取，运行结果如下。\n\n这里需要注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。\nReact 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考官方文档。\n\n### 六、PropTypes\n\n组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。\n组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求（查看 demo06）。\n\n```javascript\nvar MyTitle = React.createClass({\n  propTypes: {\n    title: React.PropTypes.string.isRequired,\n  },\n\n  render: function() {\n     return <h1> {this.props.title} </h1>;\n   }\n});\n```\n\n上面的Mytitle组件有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。现在，我们设置 title 属性的值是一个数值。\n```javascript\nvar data = 123;\n\nReactDOM.render(\n  <MyTitle title={data} />,\n  document.body\n);\n```\n这样一来，title属性就通不过验证了。控制台会显示一行错误信息。\n\nWarning: Failed propType: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`.\n更多的PropTypes设置，可以查看官方文档。\n此外，getDefaultProps 方法可以用来设置组件属性的默认值。\n```javascript\nvar MyTitle = React.createClass({\n  getDefaultProps : function () {\n    return {\n      title : \'Hello World\'\n    };\n  },\n\n  render: function() {\n     return <h1> {this.props.title} </h1>;\n   }\n});\n\nReactDOM.render(\n  <MyTitle />,\n  document.body\n);\n```\n上面代码会输出\"Hello World\"。\n\n### 七、获取真实的DOM节点\n\n组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。\n但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性（查看 demo07 ）。\n```javascript\nvar MyComponent = React.createClass({\n  handleClick: function() {\n    this.refs.myTextInput.focus();\n  },\n  render: function() {\n    return (\n      <div>\n        <input type=\"text\" ref=\"myTextInput\" />\n        <input type=\"button\" value=\"Focus the text input\" onClick={this.handleClick} />\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <MyComponent />,\n  document.getElementById(\'example\')\n);\n```\n上面代码中，组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。\n需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。\nReact 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等，完整的事件清单请查看官方文档。\n\n### 八、this.state\n\n组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI （查看 demo08 ）。\n```javascript\nvar LikeButton = React.createClass({\n  getInitialState: function() {\n    return {liked: false};\n  },\n  handleClick: function(event) {\n    this.setState({liked: !this.state.liked});\n  },\n  render: function() {\n    var text = this.state.liked ? \'like\' : \'haven\\\'t liked\';\n    return (\n      <p onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </p>\n    );\n  }\n});\n\nReactDOM.render(\n  <LikeButton />,\n  document.getElementById(\'example\')\n);\n```\n上面代码是一个 LikeButton 组件，它的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。\n由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。\n九、表单\n\n用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取（查看 demo9 ）。\n\n```javascript\nvar Input = React.createClass({\n  getInitialState: function() {\n    return {value: \'Hello!\'};\n  },\n  handleChange: function(event) {\n    this.setState({value: event.target.value});\n  },\n  render: function () {\n    var value = this.state.value;\n    return (\n      <div>\n        <input type=\"text\" value={value} onChange={this.handleChange} />\n        <p>{value}</p>\n      </div>\n    );\n  }\n});\nReactDOM.render(<Input/>, document.body);\n```\n\n上面代码中，文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况，更多介绍请参考官方文档。\n\n### 十、组件的生命周期\n\n组件的生命周期分成三个状态：\nMounting：已插入真实 DOM\nUpdating：正在被重新渲染\nUnmounting：已移出真实 DOM\nReact 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。\n```javascript\ncomponentWillMount()\ncomponentDidMount()\ncomponentWillUpdate(object nextProps, object nextState)\ncomponentDidUpdate(object prevProps, object prevState)\ncomponentWillUnmount()\n```\n此外，React 还提供两种特殊状态的处理函数。\ncomponentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用\nshouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用\n这些方法的详细说明，可以参考官方文档。下面是一个例子（查看 demo10 ）。\n\n```javascript\nvar Hello = React.createClass({\n  getInitialState: function () {\n    return {\n      opacity: 1.0\n    };\n  },\n\n  componentDidMount: function () {\n    this.timer = setInterval(function () {\n      var opacity = this.state.opacity;\n      opacity -= .05;\n      if (opacity < 0.1) {\n        opacity = 1.0;\n      }\n      this.setState({\n        opacity: opacity\n      });\n    }.bind(this), 100);\n  },\n\n  render: function () {\n    return (\n      <div style={{opacity: this.state.opacity}}>\n        Hello {this.props.name}\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <Hello name=\"world\"/>,\n  document.body\n);\n```\n\n上面代码在hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。\n另外，组件的style属性的设置方式也值得注意，不能写成\n\n`style=\"opacity:{this.state.opacity};\"`\n而要写成\n\n`style={{opacity: this.state.opacity}}`\n这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。\n\n### 十一、Ajax\n\n组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI （查看 demo11 ）。\n\n```javascript\nvar UserGist = React.createClass({\n  getInitialState: function() {\n    return {\n      username: \'\',\n      lastGistUrl: \'\'\n    };\n  },\n\n  componentDidMount: function() {\n    $.get(this.props.source, function(result) {\n      var lastGist = result[0];\n      if (this.isMounted()) {\n        this.setState({\n          username: lastGist.owner.login,\n          lastGistUrl: lastGist.html_url\n        });\n      }\n    }.bind(this));\n  },\n\n  render: function() {\n    return (\n      <div>\n        {this.state.username}\'s last gist is\n        <a href={this.state.lastGistUrl}>here</a>.\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <UserGist source=\"https://api.github.com/users/octocat/gists\" />,\n  document.body\n);\n```\n\n上面代码使用 jQuery 完成 Ajax 请求，这是为了便于说明。React 本身没有任何依赖，完全可以不用jQuery，而使用其他库。\n我们甚至可以把一个Promise对象传入组件，请看Demo12。\n\n```javascript\nReactDOM.render(\n  <RepoList\n    promise={$.getJSON(\'https://api.github.com/search/repositories?q=javascript&sort=stars\')}\n  />,\n  document.body\n);\n```\n\n上面代码从Github的API抓取数据，然后将Promise对象作为属性，传给RepoList组件。\n如果Promise对象正在抓取数据（pending状态），组件显示\"正在加载\"；如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。\n```javascript\nvar RepoList = React.createClass({\n  getInitialState: function() {\n    return { loading: true, error: null, data: null};\n  },\n\n  componentDidMount() {\n    this.props.promise.then(\n      value => this.setState({loading: false, data: value}),\n      error => this.setState({loading: false, error: error}));\n  },\n\n  render: function() {\n    if (this.state.loading) {\n      return <span>Loading...</span>;\n    }\n    else if (this.state.error !== null) {\n      return <span>Error: {this.state.error.message}</span>;\n    }\n    else {\n      var repos = this.state.data.items;\n      var repoList = repos.map(function (repo) {\n        return (\n          <li>\n            <a href={repo.html_url}>{repo.name}</a> ({repo.stargazers_count} stars) <br/> {repo.description}\n          </li>\n        );\n      });\n      return (\n        <main>\n          <h1>Most Popular JavaScript Projects in Github</h1>\n          <ol>{repoList}</ol>\n        </main>\n      );\n    }\n  }\n});\n```\n### 十二、参考链接\n\nReact\'s official site\nReact\'s official examples\nReact (Virtual) DOM Terminology, by Sebastian Markbåge\nThe React Quick Start Guide, by Jack Callister\nLearning React.js: Getting Started and Concepts, by Ken Wheeler\nGetting started with React, by Ryan Clark\nReact JS Tutorial and Guide to the Gotchas, by Justin Deal\nReact Primer, by Binary Muse\njQuery versus React.js thinking, by zigomir', '2', '0', '2017-06-16 10:57:54'), ('60', '1022', '121', '```shell\n克隆项目到本地\ngit clone git@gitlab.love.tv:cxx/push-go.git	-- 克隆项目，需先配置好ssh的公钥\ngit status	-- 查看当前分支情况\n\n切换分支\ngit checkout dev	-- 切换工作分支，默认为主分支master\n\n拉取远程代码到本地\ngit pull	-- 下拉主分支数据\ngit pull origin master	-- 下拉指定分支数据，master 为分支名称，\n\n提交更新的代码\ngit add -A	-- 向本地仓库添加所有更新或添加的代码\ngit commit -m \"信息\"	-- 向本地仓库提交刚刚 git add 操作的代码\ngit push origin master	-- 向远程仓库提交刚刚提交的本地仓库代码\n```', '2', '0', '2017-06-16 15:19:31'), ('61', '1', '123', '### mac配置Intellij IDEA的Spark运行环境\n\n[TOC]\n\n文档撰写于2017-06-19\n\n#### 序\n> 配置\n- macOs Sierra 10.12.4\n- Intellij IDEA 2017\n- Scala插件2017.1.19\n\n#### 安装插件\n> ##### 方法一：IDEA直接安装\n![](http://img.qiqinote.com/2017/6/23/a82ecdac460d43e7be64c8b0965aa6a8.png)\n>> ps: 此方法安装很大机率会安装失败\n\n> ##### 方法二：手动安装\n>> 1. 浏览器进入JetBrains的scala插件页面：https://plugins.jetbrains.com/plugin/1347-scala\n>> 2. 下载插件后本地有个zip包，解压\n>> 3. 找到Intellij IDEA在应用程序的安装包，右击`显示包内容`->`plugins`\n>> 4. 将刚解压的文件夹拷贝到该目录下\n![](http://img.qiqinote.com/2017/6/23/4679500999b342b494f643dc264753e9.png)\n>\n> 安装成功！\n> 重启Intellij IDEA，新建项目即可看到scala\n![](http://img.qiqinote.com/2017/6/23/99b13787cd9744a8aa7105215af3b76b.png)\n\n#### 创建maven的scala项目\n> 1. 按照正常流程创建好maven项目\n> 2. 新建好maven项目，打开`Project Structure`(快捷键`⌘;`)\n> 3. 在`Global Libaries`->`+`添加`Scala SDK`\n> 4. 完成！\n![](http://img.qiqinote.com/2017/6/23/5965d40a3e314572a82665397f88f04a.png)', '2', '0', '2017-06-19 16:39:55'), ('62', '1', '125', '\n2017年\n\n06-03  11:27-17:08\n\n04-15  11:24-\n04-08  10:40-18:55\n\n03-25  11:07-16:55\n03-11  11:23-19:34\n03-04  11:02-17:11\n\n02-25  11:46 - 18:13\n02-18  12:47 - 18:10\n\n01-21  09:52 - \n01-21  13:59 - 17:19\n01-14  10:50 - 16:19\n\n2016年\n\n12-24  10:37 - 20:15\n12-17  12:33 - 19:09\n12-10  11:02 - 18:22\n12-03  10:49 - 16:22\n\n\n11-19\n11-12\n11-05 11:16 - 19:44\n \n\n10-29 10:14 - 18:51\n\n\n09-24  09:59 - 15:47\n09-11  13:52 - 19:53\n09-04  13:18 - 18:50\n09-03  10:30 - 19:24\n\n\n08-20  \n08-14 \n08-13  \n08-06  11:04 - 18:42\n\n07-30  12:49 - 17:09\n07-24  14:09 - 18:29\n07-16  11:13 - \n07-09  10:46 - 14:48\n07-02  10:52 - 17:42\n\n06-18  10:30 - 16:30\n06-05  13:20 -\n06-04  10:45 - 17:00', '2', '0', '2017-06-19 17:54:28'), ('63', '1', '124', '京ICP备17034644\n备案密码：WYS655\n审核通过日期：2017-06-19 13:51:32\n\n【工信部备案系统】工业和信息化部网站备案系统-短信通知：尊敬的用户邹凡奇，您的ICP备案申请已通过审核，备案/许可证编号为：京ICP备17034644号，备案密码为：WYS655，审核通过日期：2017-06-19 13:51:32。请牢记和妥善保管您的备案号、备案密码，备案密码将是以后变更备案信息的重要依据。', '2', '0', '2017-06-19 17:55:38'), ('64', '1', '126', '```\n小象学院 http://www.chinahadoop.cn fly1004 / huwei123\nhttps://mp.weixin.qq.com/\nboiiod1314@163.com\nhuwei123\n```\n```\n47.93.255.190/mysql\nZOU~!@%^&*fanqi123\n```\n```\n酷狗帐户：mydskf@live.cn\n其它大部分：vankizou@163.com\n第三方登录：大部分QQ（594198658）\n手机号：13552145052\n```\n```\n雪芳阿里云：zxf15010243488 abc18255313101\n```\n\n```\n金金\n36062219910309581X\n```', '2', '0', '2017-06-20 13:50:54'), ('65', '1', '128', '\n#### 程序依赖\n- mysql\n- redis\n- ImageMagick\n\n#### nginx配置\n\n##### `/etc/nginx/conf.d/vanki_www.conf`\n```\nupstream vanki_www{\n        #ip_hash;\n    server localhost:8181;\n}\nserver {\n    listen  80;\n    server_name www.qiqinote.com qiqinote.com www.zoufanqi.com zoufanqi.com\n    charset utf-8;\n\n    location ~ ^/(WEB-INF)/ {\n           deny all;\n    }\n    location ~ \\.(flv|gif|jpg|jpeg|png|bmp|ico|css|js|txt)$ {\n        root /data/tomcat/www/webapps/ROOT/;\n        expires 6d;\n    }\n    location / {\n       proxy_pass  http://vanki_www;\n        proxy_set_header    X-Real-IP  $remote_addr;\n        proxy_set_header    Host       $host;\n        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n        proxy_buffer_size 4k;\n        proxy_buffers 4 32k;\n        proxy_busy_buffers_size 64k;\n        proxy_temp_file_write_size 64k;\n        proxy_max_temp_file_size 512m;\n    }\n    #location ~ \\.(flv|gif|jpg|jpeg|png|bmp|ico|css|js|txt)$ {\n     #   root /data/tomcat/www/webapps/ROOT/;\n      #  expires 6d;\n    #}\n    error_page  404 403              /data/nginx/404.html;\n    error_page   500 502 503 504  /data/nginx/50x.html;\n    access_log  /data/nginx/log/vanki_www.log ;\n}\n```\n\n##### `/etc/nginx/conf.d/vanki_img.conf`\n```\nserver {\n    listen       80; 	\n    server_name img.qiqinote.com;\n    charset utf-8;\n\n    location / {\n        root   /data/tomcat/image/;\n        index  login.htmls index.html index.shtml index.jsp index.htm index.php;\n        expires 30d;\n    }\n    location ~ \\.(flv|gif|jpg|jpeg|png|bmp|ico|css|js|txt)$ {\n            root /data/tomcat/image/;\n            expires 6d;\n    }\n    error_page  404 403              /data/nginx/404.html;\n\n    # redirect server error pages to the static page /50x.html\n    error_page   500 502 503 504  /data/nginx/50x.html;\n    access_log  /data/nginx/log/vanki_img.log ;\n}\n```\n\n#### 数据库备份\n```\n20 02 * * * (sh /data/tools/backup_vanki_db.sh > /var/log/backup_vanki_db.log 2>&1&)\n```\n```\n#!/bin/sh\nmysqldump -uvanki -p\'密码\' vanki --lock-all-tables | gzip > /data/backup/mysql/vanki/vanki.`date +%d`.sql.gz\n```\n\n#### 同步\n> 服务器\n\n```\n# /etc/rsyncd: configuration file for rsync daemon mode\n\n# See rsyncd.conf man page for more options.\n\n# configuration example:\n\n# uid = nobody\n# gid = nobody\n# use chroot = yes\n# max connections = 4\n# pid file = /var/run/rsyncd.pid\n# exclude = lost+found/\n# transfer logging = yes\n# timeout = 900\n# ignore nonreadable = yes\n# dont compress   = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2\n\n# [ftp]\n#        path = /home/ftp\n#        comment = ftp export area\n\nuid = 0\ngid = 0\nmax connections = 10\ntimeout = 6000\nuse chroot = no\nread only = yes\npid file=/var/run/rsyncd.pid\n\nlog file=/var/log/rsyncd.log\n#hosts allow=*\n\n[mysql]\npath=/data/backup/mysql/\n\n[image]\npath=/data/tomcat/image/\n```\n\n> 本地\n\n```\nrsync-mysql.sh：\n#!/bin/sh\nrsync -avzSrtopg --partial  --bwlimit=5000 47.93.255.190::mysql/vanki/ ./mysql\n\nrsync-image.sh：\n#!/bin/sh\nrsync -avzSrtopg --partial  --bwlimit=5000 47.93.255.190::image/ ./image\n```', '2', '0', '2017-06-23 11:04:49'), ('66', '1', '129', '![](http://img.qiqinote.com/2017/6/23/7afe2e3872f74d62ba1ae072e47865cf.png)', '2', '0', '2017-06-23 16:44:29'), ('67', '1', '130', '### rsync的基本使用\n\n[TOC]\n\n#### 安装\n##### linux安装\n```\n# yum install rsync\n```\n##### mac安装\n```\n# brew install rsync\n```\n\n#### 服务器配置\n```\n# vi /etc/rsyncd.conf\n添加：\n\nuid=0\ngid=0\nmax connections=200\ntimeout=6000\nuse chroot=no\nread only=yes\npid file=/var/run/rsyncd.pid\n\nlog file=/var/log/rsyncd.log\n\n# 允许连接的主机。1、多个以“,”分隔；2、“0”配置全部，如:1.1.1.0；3、* 表示所有；4、默认为所有\nhosts allow=1.1.1.1		\n\n[backup]	# 名称\npath=/data/backup/\n\n[backup2]	# 名称\npath=/data/backup2/\n```\nps: 官方配置文档：https://www.samba.org/ftp/rsync/rsyncd.conf.html\n\n> 启动服务\n```\nrsync --daemon\n```\n\n#### 客户端连接\n```\n# rsync -avzSrtopg --partial  --bwlimit=下载限速(KB) 服务器IP::backup2/ /本地/目录	\n# 请注意：连接服务器端时，请确保服务器的端口对该客户端公开。默认端口为：873\n```', '2', '0', '2017-06-23 17:25:09'), ('68', '1', '131', '\n\n#### hosts\n```\n10.211.55.8     node1\n10.211.55.9     node2\n10.211.55.10    node3\n```\n\n#### 服务器节点分配\n> \n||zookeeper|nameNode|JournalNode|ZKFC|dataNode|ResourceManager|NodeManager|\n|-\n|node1|√|√|√|√|√|√|√|\n|node2|√|√|√|√|√| |√|\n|node3|√| |√| |√| |√|\n\n#### 软件安装目录\n```\n/data/softs/\n```', '2', '0', '2017-06-26 14:40:53'), ('69', '110', '122', '\n\n我实现了一种机制可以利用浏览器提供的sessionStorage或memoryStorageStorage的固有的安全性来实现用户身份认证，并且可以保证用户不需要每次新开一个标签页都重新登录。\n\n现有的浏览器存储机制\n\n- localStorage ：~5MB，数据永久保存直到用户手动删除\n- sessionStorage ：~5MB，数据只在当前标签页有效\n- cookie ：~4KB，可以设置成永久有效\n- session cookie ：~4KB，当用户关闭浏览器时删除（并非总能立即删除）\n安全的认证token保存\n\n一些重要的系统会要求当用户关闭标签页时会话立刻到期。\n\n为了达到这个目的，不仅绝对不应该使用cookies来保存任何敏感信息（例如认证token）。甚至session-cookies也无法满足要求，它在标签页关闭（甚至浏览器完全关闭）后还会持续存活一定时间。\n\n（任何时刻我们都不应该只使用cookies，它还有其他很多问题需要讨论，例如CSRF）\n\n这些问题就使得我们在保存认证token时应使用内存或sessionStorage。sessionStorage的好处是它允许跨多个页面保存数据，并且也支持浏览器刷新操作。这样用户就可以在多个页面之间跳转或刷新页面而保持登录状态。\n\nGood。我们将token保存在sessionStorage，并在每次请求服务器时将token放在请求头中来完成用户的身份认证。当用户关闭标签页，token会立即过期。\n\n但多标签页怎么办？\n\n即便是在单页面应用中也有一个很常见的情况，用户经常希望打开多个标签页。而此场景下将token保存在sessionStorage中将会带来很差的用户体验，每次开启一个标签页都会要求用户重新登录。没错，sessionStorage不支持跨标签页共享数据。\n\n利用localStorage事件来跨标签页共享sessionStorage\n\n我利用localStorage事件提出了一种解决方案。\n\n当用户新开一个标签页时，我们先来询问其它已经打开的标签页是不是有需要给我们共享的sessionStorage数据。如果有，现有的标签页会通过localStorage事件来传递数据到新打开的标签页中，我们只需要复制一份到本地sessionStorage即可。\n\n传递过来的sessionStorage绝对不会保存在localStorage，从localStorage事件将数据中复制并保存到sessionStorage，这个流程是在同一个调用中完成，没有中间状态。而且数据是对应事件携带的，并不在localStorage中。（译者注：作者意图解释这个方案的安全性）\n\n在线例子\n\nhttps://blog.guya.net/security/browser_session/memoryStorage.html\n\n点击“Set the sessionStorage”，然后打开多个标签页，你会发现sessionStorage共享了。\n\n```\n// 为了简单明了删除了对IE的支持\n(function(){\n\nif(!sessionStorage.length) {\n// 这个调用能触发目标事件，从而达到共享数据的目的\n localStorage.setItem(\'getSessionStorage\',Date.now());\n };\n\n// 该事件是核心\nwindow.addEventListener(\'storage\',function(event){\nif(event.key ==\'getSessionStorage\') {\n// 已存在的标签页会收到这个事件\n localStorage.setItem(\'sessionStorage\',JSON.stringify(sessionStorage));\n localStorage.removeItem(\'sessionStorage\');\n\n } elseif(event.key ==\'sessionStorage\'&& !sessionStorage.length) {\n// 新开启的标签页会收到这个事件\nvardata =JSON.parse(event.newValue),\n value;\n\nfor(keyindata) {\n sessionStorage.setItem(key, data[key]);\n }\n }\n });\n})();\n（译者注：上面的代码是我从在线demo中截取的，原文中并无提到）\n```\n\n接近完美\n\n我们现在拥有了一个几乎非常安全的方案来保存会话token在浏览器里，并支持良好的多标签页用户体验。现在当用户关闭标签页后能确保会话立即过期。难道不是么？\n\nchrome和firefox都支持当用户进行“重新打开关闭的标签页”或“撤销关闭标签页”时恢复sessionStorage。F**k！（译者注：作者原文用的是“Damn it!”，注意到那个叹号了吗？）\n\nsafari在这个问题上处理是正确的，它并不会恢复sessionStorag（只测试了上述这三个浏览器）。\n\n对用户而言，能够确定sessionStorag已经过期的方法是直接重新打开网站，而不是选择“重新打开关闭的标签页”。\n\n除非chrome和firefox能够解决这个bug。（但我预感开发组会称其为“特性”）\n\n即便存在这样的bug，使用sessionStorag依然要比session-cookies方案或其他方案要安全。如果我们希望得到一个更加完美的方案，我们就需要自己来实现一个内存的方案来代替sessionStorag。(onbeforeunload也能做到，但不是太可靠且每次刷新页面也会被清空。window.name也不错，但它太老了且也不支持跨域保护)\n\n跨标签页共享memoryStorage\n\n这应该是唯一一个真正安全的实现浏览器端保存认证token的方法了，并且要保证用户打开多个标签页不需要重新登录。\n\n关闭标签页，会话立即过期–这次是真真儿的。\n\n这个方案的缺点是， 当只有一个标签页时 ，浏览器刷新会导致用户重新登录。安全总是要付出点代价的，很明显这个缺点可能是致命的。\n\n在线例子\n\nhttps://blog.guya.net/security/browser_session/memoryStorage.html\n\n设置一个memoryStorage，然后打开多个标签页，你会发现数据共享了。关闭所有标签页token会立即永久过期（memoryStorage其实就是一个javascript对象而已）。\n```\n(function(){\n\nwindow.memoryStorage = {};\n\nfunctionisEmpty(o){\nfor(variino) {\nreturnfalse;\n }\nreturntrue;\n };\n\nif(isEmpty(memoryStorage)) {\n localStorage.setItem(\'getSessionStorage\',Date.now());\n };\n\nwindow.addEventListener(\'storage\',function(event){\nif(event.key ==\'getSessionStorage\') {\n localStorage.setItem(\'sessionStorage\',JSON.stringify(memoryStorage));\n localStorage.removeItem(\'sessionStorage\');\n\n } elseif(event.key ==\'sessionStorage\'&& isEmpty(memoryStorage)) {\nvardata =JSON.parse(event.newValue),\n value;\n\nfor(keyindata) {\n memoryStorage[key] = data[key];\n }\n }\n });\n})();\n```', '2', '0', '2017-06-26 14:56:34'), ('70', '110', '132', 'AMD 模块\n\nAMD（异步模块定义，Asynchronous Module Definition）格式总体的目标是为现在的开发者提供一个可用的模块化 JavaScript 的解决方案。\n\nAMD 模块格式本身是一个关于如何定义模块的提案，在这种定义下模块和依赖项都能够异步地进行加载。它有很多独特的优势，包括天生的异步及高度灵活等特性，这些特性能够解除常见的代码与模块标识间的那种紧密耦合。目前它已经被很多项目所接纳，包括jQuery（1.7）。\n\nRequireJS\n\nRequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守AMD规范。\n\njQuery 对AMD的支持\n\njQuery 1.7 开始支持将 jQuery 注册为一个AMD异步模块。有很多兼容的脚本加载器（包括 RequireJS 和 curl）都可以用一个异步模块格式来加载模块，这也就表示不需要太多 hack 就能让一切运行起来。可以看看jQuery 1.7 中的源码：\n```\n[js] view plaincopy\n// Expose jQuery as an AMD module, but only for AMD loaders that  \n// understand the issues with loading multiple versions of jQuery  \n// in a page that all might call define(). The loader will indicate  \n// they have special allowances for multiple jQuery versions by  \n// specifying define.amd.jQuery = true. Register as a named module,  \n// since jQuery can be concatenated with other files that may use define,  \n// but not use a proper concatenation script that understands anonymous  \n// AMD modules. A named AMD is safest and most robust way to register.  \n// Lowercase jquery is used because AMD module names are derived from  \n// file names, and jQuery is normally delivered in a lowercase file name.  \nif ( typeof define === \"function\" && define.amd && define.amd.jQuery ) {  \n define( \"jquery\", [], function () { return jQuery; } );  \n}  \n```\n\n其工作的原理是，所使用的脚本加载器通过指定一个属性，即 define.amd.jQuery 为 true，来标明自己可以支持多个 jQuery 版本。如果有兴趣了解特定的实现细节的话，我们可以将 jQuery 注册为一个具名模块，因为可能会有这样的风险，即它可能被与其它使用了 AMD 的 define() 方法的文件拼合在一起，而没有使用一个合适的、理解匿名 AMD 模块定义的拼合脚本。\n\n**高版本的jQuery （1.11.1） 去掉了define.amd.jQuery判断：**\n```\n[js] view plaincopy\nif ( typeof define === \"function\" && define.amd ) {  \n define( \"jquery\", [], function() {  \n  return jQuery;  \n });  \n}  \n```\n\nRequire.js中使用jQuery\n\nRequire.js中使用jQuery非常方便，简单配置就可以了，例如：\n\n**[js] view plaincopy**\n// 简单的配置  \n```\nrequire.config({  \n  \n    // RequireJS 通过一个相对的路径 baseUrl来加载所有代码。baseUrl通常被设置成data-main属性指定脚本的同级目录。  \n    baseUrl: \"./js\",  \n  \n    // 第三方脚本模块的别名,jquery比libs/jquery-1.11.1.min.js简洁明了；  \n    paths: {  \n  \n        \"jquery\": \"libs/jquery-1.11.1.min.js\"  \n  \n    }  \n  \n});\n```\n  \n**// 开始使用jQuery 模块**\n```\nrequire([\"jquery\"], function ($) {  \n  \n    //你的代码  \n    //这里直接可以使用jquery的方法，比如：$( \"#result\" ).html( \"Hello World!\" );  \n  \n});  \n```\n\nRequire.js中使用jQuery 插件\n\n虽然jQuery的支持AMD的API， 这并不意味着jQuery插件也是和AMD兼容的。\n\n**一般的jQuery 插件格式：**\n```\n[js] view plaincopy\n(function ($) {  \n    $.fn.myPlugin = function () {  \n        //你自己的插件代码  \n    };  \n})(jQuery);  \n```\n**不过我们稍微修改一下就可以使用Require.js加载一个jQuery插件：**\n```\n[js] view plaincopy\n;(function (factory) {  \n    if (typeof define === \"function\" && define.amd) {  \n        // AMD模式  \n        define([ \"jquery\" ], factory);  \n    } else {  \n        // 全局模式  \n        factory(jQuery);  \n    }  \n}(function ($) {  \n    $.fn.jqueryPlugin = function () {  \n        //插件代码  \n    };  \n}));  \n\n```\nRequire.js中使用jQuery UI组件\n\nRequire.js中使用jQuery UI组件也类似的，只要改造一下jQuery Widget Factory 代码就可以了，并且感觉jQuery UI的依赖关系加载就可以了。例如：\n```\n[js] view plaincopy\n(function (widgetFactory) {  \n  \n    if (typeof define === \"function\" && define.amd) {  \n        // AMD模式  \n        define(\"jquery.ui.widget\", [\"jquery\"], function () {  \n  \n            widgetFactory(window.jQuery);  \n  \n        });  \n    } else {  \n        // 全局模式  \n        widgetFactory(window.jQuery);  \n    }  \n}  \n(function ($, undefined) {  \n  \n    // jQuery Widget Factory 代码  \n  \n}));  \n```', '2', '0', '2017-06-26 15:01:42'), ('71', '110', '133', '入门\n\n编写一个jQuery插件开始于给jQuery.fn加入新的功能属性，此处添加的对象属性的名称就是你插件的名称：\n\njs 代码:\n```\njQuery.fn.myPlugin = function(){\n  //你自己的插件代码\n};\n```\n用户非常喜欢的$符号哪里去了？ 它仍然存在，但是，为了避免和其他JavaScript库冲突，我们最好将jQuery传递给一个自我执行的封闭程序，jQuery在此程序中映射为$符号，这样可以避免$号被其他库覆写。\n\njs 代码:\n```\n(function ($) {\n    $.fn.myPlugin = function () {\n        //你自己的插件代码\n    };\n})(jQuery);\n```\n在这个封闭程序中，我们可以无限制的使用$符号来表示jQuery函数。\n\n环境\n\n现在，我们可以开始编写实际的插件代码。 但是，在这之前，我们必须得对插件所处的环境有个概念。 在插件的范围里， this关键字代表了这个插件将要执行的jQuery对象， 这里容易产生一个普遍的误区，因为在其他包含callback的jQuery函数中，this关键字代表了原生的DOM元素。这常常会导致开发者误将this关键字无谓的包在jQuery中，如下所示。\n\njs 代码:\n```\n(function ($) {\n    $.fn.myPlugin = function () {\n \n        //此处没有必要将this包在$号中如$(this)，因为this已经是一个jQuery对象。\n        //$(this)等同于 $($(\'#element\'));\n \n        this.fadeIn(\'normal\', function () {\n \n            //此处callback函数中this关键字代表一个DOM元素\n \n        });\n \n    };\n})(jQuery);\n \n$(\'#element\').myPlugin();\n```\n基础知识\n\n现在，我们理解了jQuery插件的基础知识，让我们写一个插件，做一些事情。\n\njs 代码:\n```\n(function ($) {\n \n    $.fn.maxHeight = function () {\n \n        var max = 0;\n \n        this.each(function () {\n            max = Math.max(max, $(this).height());\n        });\n \n        return max;\n    };\n})(jQuery);\n ```\nvar tallest = $(\'div\').maxHeight(); //返回高度最大的div元素的高度\n这是一个简单的插件，利用.height()返回页面中高度最大的div元素的高度。\n\n维护Chainability\n\n很多时候，一个插件的意图仅仅是以某种方式修改收集的元素，并把它们传递给链中的下一个方法。 这是jQuery的设计之美，是jQuery如此受欢迎的原因之一。 因此，要保持一个插件的chainability，你必须确保你的插件返回this关键字。\n\njs 代码:\n```\n(function ($) {\n \n    $.fn.lockDimensions = function (type) {\n \n        return this.each(function () {\n \n            var $this = $(this);\n \n            if (!type || type == \'width\') {\n                $this.width($this.width());\n            }\n \n            if (!type || type == \'height\') {\n                $this.height($this.height());\n            }\n \n        });\n \n    };\n})(jQuery);\n$(\'div\').lockDimensions(\'width\').CSS(\'color\', \'red\');\n```\n由于插件返回this关键字，它保持了chainability，这样jQuery收集的元素可以继续被jQuery方法如.css控制。 因此，如果你的插件不返回固有的价值，你应该总是在其作用范围内返回this关键字。 此外，你可能会推断出，传递给插件的参数将会在插件的作用范围内被传递。 因此，在前面的例子，字符串’width’变成了插件的类型参数。\n\n默认值和选项\n\n对于比较复杂的和提供了许多选项可定制的的插件，最好有一个当插件被调用的时候可以被拓展的默认设置(通过使用$.extend)。 因此，相对于调用一个有大量参数的插件，你可以调用一个对象参数，包含你了你想覆写的设置。\n\njs 代码:\n```\n(function ($) {\n \n    $.fn.tooltip = function (options) {\n \n        //创建一些默认值，拓展任何被提供的选项\n        var settings = $.extend({\n            \'location\': \'top\',\n            \'background-color\': \'blue\'\n        }, options);\n \n        return this.each(function () {\n \n            // Tooltip插件代码\n \n        });\n \n    };\n})(jQuery);\n$(\'div\').tooltip({\n    \'location\': \'left\'\n});\n```\n在这个例子中，调用tooltip插件时覆写了默认设置中的location选项，background-color选项保持默认值，所以最终被调用的设定值为：\n\njs 代码:\n```\n{\n    \'location\': \'left\',\n    \'background-color\': \'blue\'\n}\n```\n这是一个很灵活的方式，提供一个高度可配置的插件，而无需开发人员定义所有可用的选项。\n\n命名空间\n\n正确命名空间你的插件是插件开发的一个非常重要的一部分。 正确的命名空间，可以保证你的插件将有一个非常低的机会被其他插件或同一页上的其他代码覆盖。 命名空间也使得你的生活作为一个插件开发人员更容易，因为它可以帮助你更好地跟踪你的方法，事件和数据。\n\n插件方法\n\n在任何情况下，一个单独的插件不应该在jQuery.fnjQuery.fn对象里有多个命名空间。\n\njs 代码:\n```\n(function ($) {\n \n    $.fn.tooltip = function (options) {\n        // this\n    };\n    $.fn.tooltipShow = function () {\n        // is\n    };\n    $.fn.tooltipHide = function () {\n        // bad\n    };\n    $.fn.tooltipUpdate = function (content) {\n        // !!!\n    };\n \n})(jQuery);\n```\n这是不被鼓励的，因为它$.fn使$.fn命名空间混乱。 为了解决这个问题，你应该收集对象文本中的所有插件的方法，通过传递该方法的字符串名称给插件以调用它们。\n\njs 代码:\n```\n(function ($) {\n \n    var methods = {\n        init: function (options) {\n            // this\n        },\n        show: function () {\n            // is\n        },\n        hide: function () {\n            // good\n        },\n        update: function (content) {\n            // !!!\n        }\n    };\n \n    $.fn.tooltip = function (method) {\n \n        // 方法调用\n        if (methods[method]) {\n            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if (typeof method === \'object\' || !method) {\n            return methods.init.apply(this, arguments);\n        } else {\n            $.error(\'Method\' + method + \'does not exist on jQuery.tooltip\');\n        }\n \n    };\n \n})(jQuery);\n//调用init方法\n$(\'div\').tooltip();\n \n//调用init方法\n$(\'div\').tooltip({\n    foo: \'bar\'\n});\n \n// 调用hide方法\n$(\'div\').tooltip(\'hide\');\n \n//调用Update方法\n$(\'div\').tooltip(\'update\', \'This is the new tooltip content!\');\n```\n这种类型的插件架构允许您封装所有的方法在父包中，通过传递该方法的字符串名称和额外的此方法需要的参数来调用它们。 这种方法的封装和架构类型是jQuery插件社区的标准，它被无数的插件在使用，包括jQueryUI中的插件和widgets。\n\n事件\n\n一个鲜为人知bind方法的功能即允许绑定事件命名空间。 如果你的插件绑定一个事件，一个很好的做法是赋予此事件命名空间。 通过这种方式，当你在解除绑定的时候不会干扰其他可能已经绑定的同一类型事件。   你可以通过追加命名空间到你需要绑定的的事件通过 ‘.<namespace>’。\n\njs 代码:\n```\n(function ($) {\n \n    var methods = {\n        init: function (options) {\n \n            return this.each(function () {\n                $(window).bind(\'resize.tooltip\', methods.reposition);\n            });\n \n        },\n        destroy: function () {\n \n            return this.each(function () {\n                $(window).unbind(\'.tooltip\');\n            })\n \n        },\n        reposition: function () {\n            //...\n        },\n        show: function () {\n            //...\n        },\n        hide: function () {\n            //...\n        },\n        update: function (content) {\n            //...\n        }\n    };\n \n    $.fn.tooltip = function (method) {\n \n        if (methods[method]) {\n            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if (typeof method === \'object\' || !method) {\n            return methods.init.apply(this, arguments);\n        } else {\n            $.error(\'Method \' + method + \' does not exist on jQuery.tooltip\');\n        }\n    };\n \n})(jQuery);\n \n$(\'#fun\').tooltip();\n//一段时间之后... ...\n$(\'#fun\').tooltip(\'destroy\');\n```\n在这个例子中，当tooltip通过init方法初始化时，它将reposition方法绑定到resize事件并给reposition非那方法赋予命名空间通过追加.tooltip。 稍后， 当开发人员需要销毁tooltip的时候，我们可以同时解除其中reposition方法和resize事件的绑定，通过传递reposition的命名空间给插件。 这使我们能够安全地解除事件的绑定并不会影响到此插件之外的绑定。\n\n数据\n\n通常在插件开发的时候，你可能需要记录或者检查你的插件是否已经被初始化给了一个元素。 使用jQuery的data方法是一个很好的基于元素的记录变量的途径。尽管如此，相对于记录大量的不同名字的分离的data,  使用一个单独的对象保存所有变量，并通过一个单独的命名空间读取这个对象不失为一个更好的方法。\n\njs 代码:\n```\n(function ($) {\n \n    var methods = {\n        init: function (options) {\n \n            return this.each(function () {\n \n                var $this = $(this),\n                    data = $this.data(\'tooltip\'),\n                    tooltip = $(\'<div />\', {\n                        text: $this.attr(\'title\')\n                    });\n \n                // If the plugin hasn\'t been initialized yet\n                if (!data) {\n \n                    /*\n                     Do more setup stuff here\n                     */\n \n                    $(this).data(\'tooltip\', {\n                        target: $this,\n                        tooltip: tooltip\n                    });\n \n                }\n            });\n        },\n        destroy: function () {\n \n            return this.each(function () {\n \n                var $this = $(this),\n                    data = $this.data(\'tooltip\');\n \n                // Namespacing FTW\n                $(window).unbind(\'.tooltip\');\n                data.tooltip.remove();\n                $this.removeData(\'tooltip\');\n \n            })\n \n        },\n        reposition: function () {\n            // ...\n        },\n        show: function () {\n            // ...\n        },\n        hide: function () {\n            // ...\n        },\n        update: function (content) {\n            // ...\n        }\n    };\n \n    $.fn.tooltip = function (method) {\n \n        if (methods[method]) {\n            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if (typeof method === \'object\' || !method) {\n            return methods.init.apply(this, arguments);\n        } else {\n            $.error(\'Method \' + method + \' does not exist on jQuery.tooltip\');\n        }\n \n    };\n \n})(jQuery);\n```\n将数据通过命名空间封装在一个对象中，可以更容易的从一个集中的位置读取所有插件的属性。\n\n总结和最佳做法\n\n编写jQuery插件允许你做出库，将最有用的功能集成到可重用的代码，可以节省开发者的时间，使开发更高效。 开发jQuery插件时，要牢记：\n\n始终包裹在一个封闭的插件：\njs 代码:\n```\n(function($) {\n/* plugin goes here */\n})(jQuery);\n```\n** 编写jquery插件注意事项：**\n- 不要冗余包裹this关键字在插件的功能范围内\n- 除非插件返回特定值，否则总是返回this关键字来维持chainability 。\n- 传递一个可拓展的默认对象参数而不是大量的参数给插件。\n- 不要在一个插件中多次命名不同方法。\n- 始终命名空间的方法，事件和数据。\n', '2', '0', '2017-06-26 15:08:02'), ('72', '1', '134', '### DAG优化\n\nDAGScheduler被称为有向无环图，它是Spark提交Job时对其内的算子操作的一个优化。当其遇到宽依赖时，因为宽依赖往往意味着一个shuffler，所以spark会自动切分一个Stage，将这个流水线上的窄依赖划分到该Stage中。\n\n- 窄依赖：生成的RDD中每个partition只依赖于父RDD(s) 固定的partition\n- 宽依赖：生成的RDD的每一个partition都依赖于父 RDD(s) 所有partitions\n\n> \n![](http://img.qiqinote.com/2017/6/27/1bffd25252144ef687a44a4e46d9bcf1.png)\n\n> - 上图整体为一个DAG\n> - A->B为一个宽依赖，所以A自动切分一个Stage\n> - C->D->F->G，C->D->F为窄依赖，F->G为宽依赖，所以把C、D、F划分成一个Stage。同理下面几条线也是一样\n> - C->D->F这条线划分一个task，因为是窄依赖，所以数据都在C这个源头对应的partition中处理，从而减少数据传输，做到优化。同理，下面几条窄依赖线也会生成对应partition的task', '2', '0', '2017-06-27 12:41:56'), ('73', '1', '135', '\n## centos-Kafka-0.11.0.0集群配置\n\n[TOC]\n\n```\nKafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消费。\n```\n![](http://img.qiqinote.com/2017/6/29/fc788c0f60d6440abaab58b90a99e76c.jpg)\n\n### 序\n- #### 环境与依赖\n> - jdk1.7+\n> - [zookeeper集群](http://www.qiqinote.com/note/22.html)\n> - Kafka-0.11.0.0\n\n- #### 服务器节点\n> - `/etc/hosts`配置\n>>> \n>>\n```\n1.1.1.1 node1\n1.1.1.1 node2\n1.1.1.1 node3\n```\n\n\nps：本文档不对zookeeper集群作详述，详见：[zookeeper集群搭建](http://www.qiqinote.com/note/22.html)\n\n### 1. 下载Kafka\n官网下载引导页：http://kafka.apache.org/downloads\nps：如果要对接spark，则需对应scala使用版本，避免不必要错误\n```\nwget http://mirrors.tuna.tsinghua.edu.cn/apache/kafka/0.11.0.0/kafka_2.11-0.11.0.0.tgz\ntar -zxvf kafka_2.11-0.11.0.0.tgz\nmv kafka_2.11-0.11.0.0 <安装目录>\n```\n\n### 2. 修改配置文件`conf/server.properties`\n> 修改所有kafka节点下该文件\n\n```\nbroker.id=<数字>		-- 每个节点该值不能相同\nlog.dirs=/data/kafka/data\n\n#在 log.retention.hours=168 下面新增下面三项\nmessage.max.byte=5242880\ndefault.replication.factor=2\nreplica.fetch.max.bytes=5242880\n\n# zookeeper集群，也可直接用IP\nzookeeper.connect=node1:2181,node2:2181,node3:2181\n```\n\n### 3. 启动集群\n**ps：需先启动zookeeper集群**\n> 1. 创建`log.dirs`存放数据目录，与集群日志目录\n```\nmkdir -p /data/kafka/{data,logs}\n```\n> 2. 在`kafka安装目录`下执行\n```\nnohup bin/kafka-server-start.sh config/server.properties >> /data/kafka/logs/kafka.log 2>&1&\n```\n>> 可以生成shell脚本，方便以后执行\n>\n> 3. 查看集群是否正常启动\n>> - 输入命令`jps`，可以看到`12345 Kafka`\n>> - `tail -n 200 /data/kafka/logs/kafka.log`无错误信息，并且信息中`Cluster ID`一致\n![](http://img.qiqinote.com/2017/6/29/e85fc812bc354fb0baea3e90e8f12069.png)\n\n### 4. 配置监控\n- 下载地址：https://github.com/quantifind/KafkaOffsetMonitor/releases/\n如：https://github.com/quantifind/KafkaOffsetMonitor/releases/download/v0.2.1/KafkaOffsetMonitor-assembly-0.2.1.jar\n- 启动 jar 包\n```\njava -Xms512M -Xmx512M -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -cp KafkaOffsetMonitor-assembly-0.2.1.jar com.quantifind.kafka.offsetapp.OffsetGetterWeb --zk node1:2181,node2:2181,node3:2181 --refresh 5.minutes --port 8086 --retain 1.day\n```\n- 浏览器访问（注意防火墙）：http://IP:8086\n\n### 常用操作\n> - 启动集群\n```\nnohup bin/kafka-server-start.sh config/server.properties >> /data/kafka/logs/kafka.log 2>&1&\n```\n> - 关闭集群\n```\nbin/kafka-server-stop.sh config/server.properties\n```\n> - 列出所有Topic\n```\nbin/kafka-topics.sh --list --zookeeper node1:2181,node2:2181,node3:2181\n```\n> - 模拟发送消息\n```\nbin/kafka-console-producer.sh --broker-list node1:9092,node2:9092,node3:9092 --topic test\n```\n> - 模拟接收消息\n```\nbin/kafka-console-consumer.sh --zookeeper node1:2181,node2:2181,node3:2181 --from-beginning --topic test\n```', '2', '0', '2017-06-27 13:33:30'), ('74', '1', '136', '## centos-Flume1.7.0\n\n[TOC]\n\n### 序\n#### 基本概念\nFlume是一个分布式的、可靠的、高可用的海量日志采集、聚合和传输的系统。\n> 数据流模型\n>> \n- Event：消息的基本单位，由 headers 和 body 组成\n- Agent：JVM进程，负责将外部来源产生的消息转发到外部的目的地\n>>> - Source：从外部来源读入Event，并写Channel。\n>>> - Channel：Event暂存组件，Source写入后，Event将会一起码保存，直到被Sink成功消费\n>>> - Sink：从Channel读入Event，并写入目的地\n>>\n>> \n![](http://img.qiqinote.com/2017/6/27/ba720fea195d4c67a07fcbf48009a83e.png)\n>>> &uarr;&uarr;&uarr; 数据流单机模型\n>>\n![](http://img.qiqinote.com/2017/6/27/440a2ced096242718fa56584dcfac0b0.png)\n>>> &uarr;&uarr;&uarr; 多channel数据流模型，一个source可以多个channel，但sink与channel为一一对应\n>>\n![](http://img.qiqinote.com/2017/6/28/ed4c3e976c9c48aa9609d2af59e5af61.png)\n\n#### 依赖环境\n> \n- [apache-flume-1.7.0-bin.tar.gz](https://mirrors.tuna.tsinghua.edu.cn/apache/flume/1.7.0/apache-flume-1.7.0-bin.tar.gz)\n- JDK1.7或以上（flume是用java写的，所以需要jdk的支持）\n\n#### 官网信息\n> \n- flume官网：http://flume.apache.org/\n- flume下载地址：http://flume.apache.org/download.html\n- flume使用帮助官方文档：http://flume.apache.org/FlumeUserGuide.html\n- flume JAVA API：http://flume.apache.org/releases/content/1.7.0/apidocs/index.html\n- flume源码git地址：https://github.com/apache/flume\n\n### conf配置文件基础配置\n> 官网：http://flume.apache.org/FlumeUserGuide.html\n配置文件需放置在`<FLUME_HOME>/conf`下，名称可自定义，如：`flume.conf`\n\n- 定义single flow\n\n```properties\n# List the sources, sinks and channels for the agent\n<Agent>.sources = <Source1>\n<Agent>.sinks = <Sink1> <Sink2>\n<Agent>.channels = <Channel1> <Channel2>\n\n# set channel for source\n<Agent>.sources.<Source>.channels = <Channel1> <Channel2> ...\n\n# set channel for sink\n<Agent>.sinks.<Sink>.channel = <Channel1>\n```\n> 注：一个source可以有多个channel，但一个sink只能有一个channel\n\n- 配置组件属性\n\n```properties\n# properties for sources\n<Agent>.sources.<Source>.<someProperty> = <someValue>\n\n# properties for channels\n<Agent>.channel.<Channel>.<someProperty> = <someValue>\n\n# properties for sinks\n<Agent>.sources.<sink>.<somePropertiey> = <someValue>\n```\n> 注：source、channel、sink均需要设定一个type属性，来表示组件的类型。\n可配置内置的type名称，如netcat、memory、hdfs\n（源码请参考：SourceType.java、ChannelType.java、SinkType.java）\n\n- 启动一个agent\n\n```\nbin/flume-ng agent -n <Agent> -c conf -f conf/flume-conf.properties.template\n```\n\n### 案例一：Flume单机版简单例子\n	目的：输入字符串打印到控制台\n- 下载安装Flume\n\n```shell\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/flume/1.7.0/apache-flume-1.7.0-bin.tar.gz\ntar -zxvf apache-flume-1.7.0-bin.tar.gz\nmv apache-flume-1.7.0-bin <安装目录>\ncd <安装目录>/apache-flume-1.7.0-bin/\nvi conf/flume-single.conf	# 在flume下的conf目录新建一个 <文件名>.conf文件\n```\n- `conf/flume-single.conf`文件配置\n\n```\na1.sources = r\na1.sinks = k\na1.channels = c\n\n# 指定source输出channel与sink获取数据的channel\na1.sources.r.channels = c\na1.sinks.k.channel = c\n\n# 指定source参数，type必须指定，对应type的有些参数也是必须的，具体参考文章下面组件\na1.sources.r.type = netcat\na1.sources.r.bind = localhost\na1.sources.r.port = 4444\n\n# 指定channel参数，type为必须\na1.channels.c.type = memory\n\n# 指定sink参数，type为必须\na1.sinks.k1.type = logger\n```\n\n- 运行并输出结果\n> 1. 启动Flume\n```\nbin/flume-ng agent --conf conf --conf-file conf/flume-single.conf --name a1 -Dflume.root.logger=INFO,console\n```\n> 2. 此时当前shell阻塞，单开一个窗口\n```\ntelnet localhost 4444\n```\n![](http://img.qiqinote.com/2017/6/28/2526b188ccb547628c74dcbb008e61f4.png)\n![](http://img.qiqinote.com/2017/6/28/580c7d5268de4023b2ada0679e3641e6.png)\n\n### 案例二：Flume收集日志输出到Kafka\n	目的：获取追加到日志文件中的日志数据，并将数据发送到kafka\n采用的组件：[tailDir Source](http://flume.apache.org/FlumeUserGuide.html#taildir-source) -> [file Channel](http://flume.apache.org/FlumeUserGuide.html#file-channel) -> [kafka Sink](http://flume.apache.org/FlumeUserGuide.html#kafka-sink)\n**ps：本案例需提前安装运行好kafka或[《kafka集群》](http://www.qiqinote.com/note/135.html)**\n\n- 下载安装Flume\n\n```shell\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/flume/1.7.0/apache-flume-1.7.0-bin.tar.gz\ntar -zxvf apache-flume-1.7.0-bin.tar.gz\nmv apache-flume-1.7.0-bin <安装目录>\ncd <安装目录>/apache-flume-1.7.0-bin/\nvi conf/flume.conf	# 在flume下的conf目录新建一个*.conf文件\n```\n- `conf/flume.conf`文件配置\n\n```\na1.sources = r1\na1.sinks = k1\na1.channels = c1\n\na1.sources.r1.channels = c1\na1.sinks.k1.channel = c1\n\na1.sources.r1.type = taildir\na1.sources.r1.positionFile = ~/.flume/taildir_position.json\na1.sources.r1.filegroups = f1\na1.sources.r1.filegroups.f1 = /data/log/flume/.*\\\\.log\na1.sources.r1.batchSize = 100\na1.sources.r1.idleTimeout = 12000\n\na1.channels.c1.type = file\na1.channels.c1.checkpointDir = /data/log/flume/file-channel/checkpoint\na1.channels.c1.dataDirs = /data/log/flume/file-channel/data\n\na1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink\na1.sinks.k1.kafka.topic = testTopic\na1.sinks.k1.kafka.bootstrap.servers = node1:9092,node2:9092,node3:9092\na1.sinks.k1.kafka.flumeBatchSize = 20\na1.sinks.k1.kafka.producer.acks = 1\na1.sinks.k1.kafka.producer.linger.ms = 1\na1.sinks.ki.kafka.producer.compression.type = snappy\n```\n> 部分参数释义：\n> \n|组件|type|参数|释义|\n|-\n|sources|taildir|positionFile|索引元数据文件，默认：~/.flume/taildir_position.json|\n|sources|taildir|filegroups|相当于文件夹路径变量，多个以空格隔开|\n|sources|taildir|filegroups.<上面配置变量>|文件路径，文件名可以正则|\n|sources|taildir|batchSize|一次获取最大行数数据，默认：100|\n|sources|taildir|idleTimeout|没有新追加数据文件休眠时间，毫秒，默认：12000|\n|||||\n|channels|file|checkpointDir|channel检查点目录，默认：~/.flume/file-channel/checkpoint|\n|channels|file|dataDirs|保存数据目录，默认：~/.flume/file-channel/data|\n\n- 运行并输出结果\n\n```\nbin/flume-ng agent -n a1 -c conf -f conf/flume.conf &\necho \"test\" >> /data/log/flume/a.log	# 在/data/log/flume/ 下新建 a.log，再在a.log文件中追加数据\n\n# 此时数据已传输到kafka中，启动kafka消费客户端，即可查看追加的数据\n<kafka安装目录>/bin/kafka-console-consumer.sh --zookeeper node1:2181,node2:2181,node3:2181 --from-beginning --topic testTopic\n```\n\n### 常用Flume组件\n> 官方文档：https://cwiki.apache.org/confluence/display/FLUME/Getting+Started\n> 官方各组件配置Demo与参数信息文档：http://flume.apache.org/FlumeUserGuide.html\n\n#### [Sources](http://flume.apache.org/FlumeUserGuide.html#flume-sources)\n|Source类型|type|用途|\n|-\n|Avro Source|avro|启动一个Avro Server，可与上一级Agent连接|\n|Thrift Source|thrift|启动一个Thrift Server，可与上一级Agent连接|\n|Exec Source|exec|执行unix command，获取标准输出，如tail -F|\n|JMS Source|jms|从JMS源读取数据|\n|Spooling Directory Source|spooldir|监听目录下的新增文件|\n|Taildir Source|taildir|监听目录下文件每行数据的变化（子目录下文件不会监听）|\n|Kafka Source|org.apache.flume.source.kafka,KafkaSource|读取Kafka数据|\n|NetCat Source|netcat|启动一个SocketServer|\n|HTTP Source|http|启动一个HttpServer|\n|Syslog Sources|syslogtcp、multiport_syslogtcp、syslogudp|读取Syglog|\n|Scribe Source|org.apache.flume.source.scribe.ScribeSource|启动一个ScribeServer|\n\n#### [Channels](http://flume.apache.org/FlumeUserGuide.html#flume-channels)\n|Channel类型|type|用途|\n|-\n|Memory Channel|memory|内存存储，agent挂掉数据丢失|\n|JDBC Channel|jdbc|通过JDBC存储至DB，默认Derby|\n|Kafka Channel|org.apache.flume.channel.kafka.KafkaChannel|存储至Kafka|\n|File Channel|file|存储至本地文件|\n|Spillable Memory Channel|SPILLABLEMEMORY|先写内存，内存满写磁盘|\n\n#### [Sinks](http://flume.apache.org/FlumeUserGuide.html#flume-sinks)\n|Sink类型|type|用途|\n|-\n|HDFS Sink|hdfs|写入HDFS|\n|Hive Sink|hive|写入Hive|\n|Logger Sink|logger|输出至Log|\n|Avro Sink|avro|发送至Avro Server，可与下一级Agent连接|\n|Thrift Sink|thrift|发送至Thrift Server，可与下一级Agent连接|\n|File Roll Sink|file_roll|写入本地文件|\n|Null Sink|null|丢弃消息|\n|HBaseSinks|hbase|写入Hbase|\n|ElasticSearchSink|org.apache.flume.sink.elasticsearch.ElasticSearchSink|写入ElasticSearch|\n|Kafka Sink|org.apache.flume.sink.kafka.KafkaSink|写入Kafka|\n', '2', '0', '2017-06-27 16:29:32'), ('75', '1', '138', 'sdfsdfsdf', '2', '0', '2017-07-04 15:55:30'), ('76', '1', '139', '## Jedis常用操作\n\n[TOC]\n\n### Java用Jedis连接redis\n- pom.xml\n```\n<dependency>\n	<groupId>redis.clients</groupId>\n	<artifactId>jedis</artifactId>\n	<version>2.9.0</version>\n</dependency>\n```\n- 创建连接\n```java\nJedisPool pool = new JedisPool(new GenericObjectPoolConfig(), \"localhost\", 6379, 30000, \"requirepass\");\nJedis jedis = pool.getResource();\n// TODO jedis 操作\njedis.close();\npool.close();\n```\n\n### Jedis常用操作\n#### 键操作\n|||\n|-:\n|新增键值对|`jedis.set(\"key\", \"value\")`|\n|删除键与值|`jedis.del(\"key\")`|\n|清空数据|`jedis.flushDB()`|\n|判断某个键是否存在|`jedis.exists(\"key\")`|\n|系统中所有的键如下|`jedis.keys(\"*\")`|\n|设置键key的过期时间为5s|`jedis.expire(\"key\", 5)`|\n|查看键key的剩余生存时间|`jedis.ttl(\"key\")`|\n|移除键key的生存时间|`jedis.persist(\"key\")`|\n|查看键key的剩余生存时间|`jedis.ttl(\"key\")`|\n|查看键key所存储的值的类型|`jedis.type(\"key\")`|\n\n#### 字符串\n|||\n|-:\n|增加数据|`jedis.set(\"key\", \"value\")`|\n|增加多个键值对|`jedis.mset(\"key1\",\"value1\",\"key2\",\"value2\",\"key3\",\"value3\")`|\n|新增键值对，若已存在则忽略|`jedis.setnx(\"key\", \"value\")`|\n|新增键值对并设置有效时间5s|`jedis.setex(\"key\", 5, \"value\")`|\n|在key后面加入值|`jedis.append(\"key\", \"appendValue\")`|\n|修改key|`jedis.set(\"key\", \"value2\")`|\n|删除键|`jedis.del(\"key\")`|\n|删除多个键值对|`jedis.del(new String[]{\"key1\",\"key2\"})`|\n|获取键|`jedis.get(\"key2\")`|\n|获取多个键值对|`jedis.mget(\"key1\",\"key2\",\"key3\")`|\n|获取原值，更新为新值|`jedis.getSet(\"key\", \"getOldSetNew\")`|\n|截取对应key的value字符串|`jedis.getrange(\"key2\", 2, 4)` 索引起始0，超过len自动取到字符最后|\n\n#### 整型\n|||\n|-:\n|添加整数|`jedis.set(\"key\", \"100\")`|\n|key值加1|`jedis.incr(\"key\")`|\n|key值减1|`jedis.decr(\"key\")`|\n|key值加5|`jedis.incrBy(\"key\", 5)`|\n|key值减5|`jedis.decrBy(\"key\", 5)`|\n\n#### 列表（list）\n|||\n|-:\n|添加一个list|`jedis.lpush(\"list\", \"value1\", \"value1\",\"value2\", \"value3\")`|\n|修改指定下标内容|`jedis.lset(\"list\", 1, \"updateValue\")`|\n|删除指定元素个数|`jedis.lrange(\"list\", 2, \"value1\")` 删除2个value1，当第二个参数=0 删除所有|\n|删除区间元素|`jedis.ltrim(\"list\", 0, 3)`|\n|左出栈|`jedis.lpop(\"list\")`|\n|右出栈|`jedis.lpush(\"list\")`|\n|获取list内容|`jedis.lrange(\"list\", 0, -1)` -1 获取到最后一个元素，-2 获取到倒数第2个元素...|\n|获取区间内容|`jedis.lrange(\"list\", 0, 2)` 获取索引0到索引2共3个元素，超过list总数返回起始到list结尾值|\n|获取列表长度|`jedis.llen(\"list\")`|\n|获取指定下标内容|`jedis.lindex(\"list\", 1)`|\n\n#### 集合（set）\n|||\n|-:\n|添加一个set|`jedis.sadd(\"set\", \"value1\", \"value2\", \"value3\")`|\n|删除元素|`jedis.srem(\"set\", \"value1\", \"value2\")`|\n|删除v1，存入v2|`jedis.smove(\"set\", \"v1\", \"v2\")`|\n|移除集合中的一个元素|`jedis.spop(\"set\")`|\n|获取所有元素|`jedis.smembers(\"set\")`|\n|获取元素总数|`jedis.scard(\"set\")`|\n|判断元素是否存在|`jedis.sismember(\"set\", \"value1\")`|\n|取交集|`jedis.sinter(\"set1\", \"set2\")`|\n|取并集|`jedis.sunion(\"set1\", \"set2\")`|\n|取差集|`jedis.sdiff(\"set1\", \"set2\")` set1中有，set2中没有|\n\n#### 有序集合（zset）\n|||\n|-:\n|添加值|`jedis.zadd(\"zset\", 3.0, \"e1\")`|\n|删除元素|`jedis.zrem(\"zset\", \"e1\")`|\n|获取所有元素|`jedis.zrange(\"zset\", 0, -1)`|\n|获取指定分数元素|`jedis.zrangeByScore(\"zset\", 0, 100)`|\n|获取元素分数|`jedis.zscore(\"zset\", \"e1\")`|\n|获取元素排名|`jedis.zrank(\"zset\", \"e1\")`|\n|获取所有元素数量|`jedis.zcard(\"zset\")`|\n|获取指定分数元素数量|`jedis.count(\"zset\", 1, 100)`|\n|指定元素分值加5|`jedis.zincrby(\"zset\", 5, \"e1\")`|\n\n#### 散列（hashMap）\n|||\n|-:\n|添加值|`jedis.hmset(\"hash\", map)`|\n|添加值|`jedis.hset(\"hash\", \"key1\", \"value1\")`|\n|值加5|`jedis.hincrBy(\"hash\", \"key1\", 5)` key1的值之前为空则插入5，若不为空则值必须为整数，否则报错|\n|删除多个键值对|`jedis.hdel(\"hash\", \"key1\", \"key2\")`|\n|获取所有键值对，返回Map|`jedis.hgetAll(\"hash\")`|\n|获取所有keys，返回Set|`jedis.hkeys(\"hash\")`|\n|获取所有values，返回List|`jedis.hvals(\"hash\")`|\n|获取指定键的值，返回List|`jedis.hmget(\"hash\", \"key1\", \"key2\")`|\n|获取键值对数量|`jedis.hlen(\"hash\")`|\n|判断键是否存在|`jedis.hexists(\"hast\", \"key1\")`|\n', '2', '0', '2017-07-06 15:45:13'), ('77', '1', '140', '## centos-基于Hadoop的HBase1.3.1完全分布式搭建（HA）\n\n[TOC]\n\n### 序\n> - 依赖\n>> - jdk1.7+\n>> - ssh（需做免密登录，在配置hadoop集群时会做）\n>> - zookeeper集群（在配置hadoop集群时会做）\n>> - [hadoop集群](http://www.qiqinote.com/note/112.html)\n>> - hbase-1.3.1\n>> 本文不对hadoop集群搭建作详述，具体请参考：[hadoop2.7.3完全分布式搭建](http://www.qiqinote.com/note/112.html)\n>>\n>> HBase各版本与Hadoop各版本兼容情况：\n![](http://img.qiqinote.com/2017/7/7/bec7da2632af49c49a88f2d8df510692.png)\n>> \n>>\n>> 目前最新版：2.0.0-alpha-1，由于不是稳定版，所以选择1.3.x，本人hadoop集群版本是2.7.3，所以hadoop与hbase版本是兼容的\n>\n> - 节点信息\n>\n|节点|HMaster|HRegionServer|\n|:-:|:-:|:-:|\n|node1|√| |\n|node2|√|√|\n|node3| |√|\n|node4| |√|\n>> 建议：RegionServer数据会存入HDFS，所以最好是将RegionServer与Hadoop的DataNode对应\n\n### 配置节点hosts\n> `vi /etc/hosts`\n```\n1.1.1.1		node1\n1.1.1.2		node2\n1.1.1.3		node3\n1.1.1.4		node4\n```\n\n### 下载安装\n- 下载\nhbase下载引导页：http://www.apache.org/dyn/closer.cgi/hbase/\n本文章用到的hbase版本文件：\nhttp://apache.fayea.com/hbase/1.3.1/hbase-1.3.1-bin.tar.gz\n\n- 解压安装\n```\ntar -zxvf hbase-1.3.1-bin.tar.gz\nmv hbase-1.3.1 <安装目录>\n```\n\n### 文件配置\n#### 1. `conf/hbase-env.sh` 配置环境信息\n> 修改或添加以下内容：\n```\nexport HBASE_OPTS=\"$HBASE_OPTS -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode\"\nexport JAVA_HOME=/usr/local/jdk1.7.0_79\nexport HBASE_MANAGES_ZK=false	# 关闭自带的zk，用自己配置的zk集群\nexport HADOOP_HOME=/data/softs/hadoop-2.7.3\nexport HBASE_LOG_DIR=/data/hbase/logs\n```\n> 注意：若有节点不是hadoop集群中节点，则需将hadoop集群任意一台的软件配置拷贝到`HADOOP_HOME`对应目录\n\n#### 2. `conf/hbase-site.xml` 配置HBase信息\n> \n```\n<configuration>\n	<property>\n		<name>hbase.rootdir</name>\n		<!-- hadoopHA：nameservices为hadoop配置文件hdfs-site.xml中的dfs.nameservices参数一致，hadoop没做HA：nameserver:port -->\n		<value>hdfs://nameservers/hbase</value>\n	</property>\n	<property>\n		<name>hbase.cluster.distributed</name>\n		<value>true</value>\n	</property>\n	<property>\n		<name>hbase.master</name>\n		<value>16000</value>\n	</property>\n	<property>\n		<name>hbase.zookeeper.quorum</name> <!-- zookeeper集群节点，端口在下一个参数指定 -->\n		<value>zk1,zk2,zk3</value>\n	</property>\n	<property>\n		<name>hbase.zookeeper.property.clientPort</name>\n		<value>2181</value>\n	</property>\n	<property>\n		<name>hbase.zookeeper.property.dataDir</name>\n		<value>/data/hbase/zookeeper</value>\n	</property>\n	<property>\n		<name>hbase.tmp.dir</name>\n		<value>/data/hbase/tmp</value>\n	</property>\n	<property>\n   　　　<name>hbase.coprocessor.user.region.classes</name>　　<!-- 开启Coprocessor -->\n   　　　<value>org.apache.hadoop.hbase.coprocessor.AggregateImplementation</value>\n 　　</property>\n　　 <property>\n　　　 　<name>hbase.superuser</name>\n		<!-- 超级用户。这里需注意：若本地需调试，比如写程序，那么本地用户名需加进来，否则没有操作权限 -->\n		<value>hbase,root,hadoop,vanki</value>\n	</property>\n	<property>\n		<name>hbase.security.authorization</name>\n		<value>true</value>\n	</property>\n	<property>\n		<name>hbase.coprocessor.master.classes</name>\n		<value>org.apache.hadoop.hbase.security.access.AccessController</value>\n	</property>\n	<property>\n		<name>hbase.coprocessor.region.classes</name> \n		<value>org.apache.hadoop.hbase.security.token.TokenProvider,org.apache.hadoop.hbase.security.access.AccessController</value>\n	</property>\n</configuration>\n```\n> 其它请访问官网：http://hbase.apache.org/book.html 或 http://abloz.com/hbase/book.html\n\n#### 3. `conf/regionservers` 配置ResionServers\n> RegionServer因为数据是存HDFS上的，所以节点最好是与Hadoop的DataNode放一起\n```\nnode2\nnode3\nnode4\n```\n\n#### 4. 将配置好的HBase打包拷贝到其它节点\n```\ntar -zcvf hbase-ok.tar.gz hbase-1.3.1	# 打包\nscp hbase-ok.tar.gz root@node1:/path/to/installDir	# 远程拷贝\n\ntar -zxvf hbase-ok.tar.gz	# 解压\n```\n\n### 启动集群\n1. `bin/stop-hbase.sh`\n> 各节点配置都是一样的，执行该命令的节点就是`HMaster`\n\n2. `bin/hbase-daemon.sh start master`\n> 启动备`HMaster`，可以有多个\n\n3. `jps`\n> 查看节点启动情况，`HMaster` `HRegionServer`\n\n4. 浏览器访问：`http://HMasterNode:16010`\n> 访问主节点（备也行），即可看到HBase相关信息，端口号为默认\n\n5. 浏览器访问HDFS，可查看到 hbase 创建的文件\n![](http://img.qiqinote.com/2017/7/7/c4884321d3e143aabfe8655f47d73a2d.png)', '2', '0', '2017-07-06 17:11:27'), ('78', '1018', '141', '微信内置浏览器的JsAPI\n\n之前有写过几篇关于微信内置浏览器（WebView）中特有的Javascript API（Javascript Interface）的文章，不过随着微信官方的调整，部分API已经不能直接使用，比如类似直接分享到朋友圈 WeixinJSBridge.invoke(\'shareTimeline\',data,callback) 这样的功能，直接调用，会得到一个访问拒绝的response。后来重新调研了下，整理出来了一个WeixinAPI的Javascript类库，分享出来，如果你对微信公众平台开发感兴趣，应该对你有用。\n/**!\n * 微信内置浏览器的Javascript API，功能包括：\n *\n * 1、分享到微信朋友圈\n * 2、分享给微信好友\n * 3、分享到腾讯微博\n * 4、隐藏/显示右上角的菜单入口\n * 5、隐藏/显示底部浏览器工具栏\n * 6、获取当前的网络状态\n * 7、调起微信客户端的图片播放组件\n *\n * @author zhaoxianlie(http://www.baidufe.com)\n */\nvar WeixinApi = (function () { \n \n    /* 这里省略了一堆代码……下面直接看调用接口 */ \n    return {\n        ready           :wxJsBridgeReady,\n        shareToTimeline :weixinShareTimeline,\n        shareToWeibo    :weixinShareWeibo,\n        shareToFriend   :weixinSendAppMessage,\n        showOptionMenu  :showOptionMenu,\n        hideOptionMenu  :hideOptionMenu,\n        showToolbar     :showToolbar,\n        hideToolbar     :hideToolbar,\n        getNetworkType  :getNetworkType,\n        imagePreview    :imagePreview\n    };    \n \n});\n下面，我们先来看一下这些API都应该怎么使用，先从最简单的入手。\n\n1、假如我希望一打开网页后，就隐藏掉右上角的PopUp菜单入口，并且隐藏掉浏览器下方的工具栏，同时还要获得当前的网络状态，那么，我们的代码可以这样来写：\n// 所有功能必须包含在 WeixinApi.ready 中进行\nWeixinApi.ready(function(Api){\n    // 隐藏右上角popup菜单入口\n    Api.hideOptionMenu();\n \n    // 隐藏浏览器下方的工具栏\n    Api.hideToolbar();\n \n    // 获取网络状态\n    Api.getNetworkType(function(network){\n        // 拿到 network 以后，做任何你想做的事\n    });\n});\n如示例代码中的注释所示，所有的功能执行必须放在 WeixinApi.ready 方法中执行，就好比你用jQuery的时候，通常都需要使用 jQuery(document).ready(function(){ }) 一样。为什么要这样做？相信不用我解释大家都能明白，因为我们必须要保证在执行这些方法的时候，WeixinJsBridge API已经被加入到WebView上了！\n\n2、再来看一个有关分享的例子，假如用户在阅读我的文章（或在使用我的产品）的过程中，发现它很有意思或有价值，一般都会将其收藏或分享（给好友、朋友圈、微博等）出去，那现在我就希望能监测到用户的分享行为，比如：自定义用户可分享的内容、甚至是在用户分享之、分享被取消、分享失败、分享成功、以及整个分享操作过程结束，我们都去做点儿什么。那么，这个代码我们可以这样来写：\n// 所有功能必须包含在 WeixinApi.ready 中进行\nWeixinApi.ready(function(Api){\n \n    // 微信分享的数据\n    var wxData = {\n        \"imgUrl\":\'http://www.baidufe.com/fe/blog/static/img/weixin-qrcode-2.jpg\',\n        \"link\":\'http://www.baidufe.com\',\n        \"desc\":\'大家好，我是Alien，Web前端&Android客户端码农，喜欢技术上的瞎倒腾！欢迎多交流\',\n        \"title\":\"大家好，我是赵先烈\"\n    };\n \n    // 分享的回调\n    var wxCallbacks = {\n        // 分享操作开始之前\n        ready:function () {\n            // 你可以在这里对分享的数据进行重组\n        },\n        // 分享被用户自动取消\n        cancel:function (resp) {\n            // 你可以在你的页面上给用户一个小Tip，为什么要取消呢？\n        },\n        // 分享失败了\n        fail:function (resp) {\n            // 分享失败了，是不是可以告诉用户：不要紧，可能是网络问题，一会儿再试试？\n        },\n        // 分享成功\n        confirm:function (resp) {\n            // 分享成功了，我们是不是可以做一些分享统计呢？\n        },\n        // 整个分享过程结束\n        all:function (resp) {\n            // 如果你做的是一个鼓励用户进行分享的产品，在这里是不是可以给用户一些反馈了？\n        }\n    };\n \n    // 用户点开右上角popup菜单后，点击分享给好友，会执行下面这个代码\n    Api.shareToFriend(wxData, wxCallbacks);\n \n    // 点击分享到朋友圈，会执行下面这个代码\n    Api.shareToTimeline(wxData, wxCallbacks);\n \n    // 点击分享到腾讯微博，会执行下面这个代码\n    Api.shareToWeibo(wxData, wxCallbacks);\n});\n\n3、当然，如果你的业务需求相当复杂，比如，你的产品就是一个微信网页游戏（类似“2048数字游戏微信版”），你希望用户分享出去的数据是一个网页截屏、或者需要将用户当前的游戏状态回传到服务器动态生成可分享的内容；那么这种情况我们又该怎么做呢？来看下面这个示例代码吧：\n// 所有功能必须包含在 WeixinApi.ready 中进行\nWeixinApi.ready(function(Api){\n \n    // 分享的回调\n    var wxCallbacks = {\n        // 分享过程需要异步执行\n        async : true,\n        // 分享操作开始之前\n        ready:function () {\n            var self = this;\n            // 假设你需要在这里发一个 ajax 请求去获取分享数据\n            $.post(yourServerUrl,yourPostData,function(responseData){\n                // 可以解析reponseData得到wxData\n                var wxData = responseData;\n                // 调用dataLoaded方法，会自动触发分享操作\n                // 注意，当且仅当 async为true时，wxCallbacks.dataLoaded才会被初始化，并调用\n                self.dataLoaded(wxData);\n            });\n        }\n        /* cancel、fail、confirm、all 方法同示例2，此处略掉 */\n    };\n \n    // 用户点开右上角popup菜单后，点击分享给好友，会执行下面这个代码\n    Api.shareToFriend({}, wxCallbacks);\n});\n唯一的区别就是在wxCallbacks中，增加了配置项async为true，表示这个分享过程是异步调用的，其实就是指的ready方法异步执行，在这种情况下，我们需要在ready方法中显式地调用wxCallbacks的dataLoaded方法，以保证分享过程能继续往下执行。也许你会发现，这个wxCallbacks中，根本就没有配置dataLoaded方法啊！是的，当async为true时，WeixinApi中我会自动对其进行初始化，dataLoaded方法需要一个参数，表示需要分享出去的数据！\n\n4、当然，如果你非要去配置dataLoaded方法，也是没有问题的，你的配置也会被执行，不会被覆盖，执行顺序是：用户配置优先。\n\n上面是直接给出使用方法，也许你现在开始关心每个方法的参数列表是什么样的了？我们以分享到朋友圈的方法为例，来看看参数都有哪些配置项：\n/**\n * 分享到微信朋友圈\n * @param       {Object}    data       待分享的信息\n * @p-config    {String}    appId      公众平台的appId（服务号可用）\n * @p-config    {String}    imageUrl   图片地址\n * @p-config    {String}    link       链接地址\n * @p-config    {String}    desc       描述\n * @p-config    {String}    title      分享的标题\n *\n * @param       {Object}    callbacks  相关回调方法\n * @p-config    {Boolean}   async                   ready方法是否需要异步执行，默认false\n * @p-config    {Function}  ready(argv)             就绪状态\n * @p-config    {Function}  dataLoaded(data)        数据加载完成后调用，async为true时有用\n * @p-config    {Function}  cancel(resp)    取消\n * @p-config    {Function}  fail(resp)      失败\n * @p-config    {Function}  confirm(resp)   成功\n * @p-config    {Function}  all(resp)       无论成功失败都会执行的回调\n */\nWeixinApi.shareToTimeline(data,callbacks);\n分享给微信好友以及分享到腾讯微博的参数列表都一样，这里就不罗列了。\n\n5、如果你的文章中有很多图片，那么，点击图片直接调起微信客户端自带的图片播放组件，那必然是一件好事；对此，你可以这样来做：\n// 调起微信客户端的图片播放组件进行播放\n```javascript\nWeixinApi.ready(function(Api){\n    var srcList = [];\n    $.each($(\'img\'),function(i,item){\n       if(item.src) {\n           srcList.push(item.src);\n           $(item).click(function(e){\n               // 通过这个API就能直接调起微信客户端的图片播放组件了\n               Api.imagePreview(this.src,srcList);\n           });\n       }\n    });\n});\n```\n就这么一段儿简单的代码，一切都搞定了！不过，需要指出的是，Api.imagePreview的参数是会进行强检测的：\n/**\n * 调起微信Native的图片播放组件。\n * 这里必须对参数进行强检测，如果参数不合法，直接会导致微信客户端crash\n *\n * @param {String} curSrc 当前播放的图片地址\n * @param {Array} srcList 图片地址列表\n */\nfunction imagePreview(curSrc,srcList) ;', '2', '0', '2017-07-06 17:24:16'), ('79', '1', '143', '```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\nLicensed to the Apache Software Foundation (ASF) under one\nor more contributor license agreements.  See the NOTICE file\ndistributed with this work for additional information\nregarding copyright ownership.  The ASF licenses this file\nto you under the Apache License, Version 2.0 (the\n\"License\"); you may not use this file except in compliance\nwith the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied.  See the License for the\nspecific language governing permissions and limitations\nunder the License.\n-->\n\n<!--\n | This is the configuration file for Maven. It can be specified at two levels:\n |\n |  1. User Level. This settings.xml file provides configuration for a single user, \n |                 and is normally provided in ${user.home}/.m2/settings.xml.\n |\n |                 NOTE: This location can be overridden with the CLI option:\n |\n |                 -s /path/to/user/settings.xml\n |\n |  2. Global Level. This settings.xml file provides configuration for all Maven\n |                 users on a machine (assuming they\'re all using the same Maven\n |                 installation). It\'s normally provided in \n |                 ${maven.home}/conf/settings.xml.\n |\n |                 NOTE: This location can be overridden with the CLI option:\n |\n |                 -gs /path/to/global/settings.xml\n |\n | The sections in this sample file are intended to give you a running start at\n | getting the most out of your Maven installation. Where appropriate, the default\n | values (values used when the setting is not specified) are provided.\n |\n |-->\n<settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\">\n    <!-- localRepository\n     | The path to the local repository maven will use to store artifacts.\n     |\n     | Default: ~/.m2/repository\n    <localRepository>/path/to/local/repo</localRepository>\n    -->\n\n    <!-- interactiveMode\n     | This will determine whether maven prompts you when it needs input. If set to false,\n     | maven will use a sensible default value, perhaps based on some other setting, for\n     | the parameter in question.\n     |\n     | Default: true\n    <interactiveMode>true</interactiveMode>\n    -->\n\n    <!-- offline\n     | Determines whether maven should attempt to connect to the network when executing a build.\n     | This will have an effect on artifact downloads, artifact deployment, and others.\n     |\n     | Default: false\n    <offline>false</offline>\n    -->\n\n    <!-- pluginGroups\n     | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.\n     | when invoking a command line like \"mvn prefix:goal\". Maven will automatically add the group identifiers\n     | \"org.apache.maven.plugins\" and \"org.codehaus.mojo\" if these are not already contained in the list.\n     |-->\n    <pluginGroups>\n        <!-- pluginGroup\n         | Specifies a further group identifier to use for plugin lookup.\n        <pluginGroup>com.your.plugins</pluginGroup>\n        -->\n    </pluginGroups>\n\n    <!-- proxies\n     | This is a list of proxies which can be used on this machine to connect to the network.\n     | Unless otherwise specified (by system property or command-line switch), the first proxy\n     | specification in this list marked as active will be used.\n     |-->\n    <proxies>\n        <!-- proxy\n         | Specification for one proxy, to be used in connecting to the network.\n         |\n        <proxy>\n          <id>optional</id>\n          <active>true</active>\n          <protocol>http</protocol>\n          <username>proxyuser</username>\n          <password>proxypass</password>\n          <host>proxy.host.net</host>\n          <port>80</port>\n          <nonProxyHosts>local.net|some.host.com</nonProxyHosts>\n        </proxy>\n        -->\n    </proxies>\n\n    <!-- servers\n     | This is a list of authentication profiles, keyed by the server-id used within the system.\n     | Authentication profiles can be used whenever maven must make a connection to a remote server.\n     |-->\n    <servers>\n        <!-- server\n         | Specifies the authentication information to use when connecting to a particular server, identified by\n         | a unique name within the system (referred to by the \'id\' attribute below).\n         |\n         | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are\n         |       used together.\n         |\n        <server>\n          <id>deploymentRepo</id>\n          <username>repouser</username>\n          <password>repopwd</password>\n        </server>\n        -->\n\n        <!-- Another sample, using keys to authenticate.\n        <server>\n          <id>siteServer</id>\n          <privateKey>/path/to/private/key</privateKey>\n          <passphrase>optional; leave empty if not used.</passphrase>\n        </server>\n        -->\n    </servers>\n\n    <!-- mirrors\n     | This is a list of mirrors to be used in downloading artifacts from remote repositories.\n     |\n     | It works like this: a POM may declare a repository to use in resolving certain artifacts.\n     | However, this repository may have problems with heavy traffic at times, so people have mirrored\n     | it to several places.\n     |\n     | That repository definition will have a unique id, so we can create a mirror reference for that\n     | repository, to be used as an alternate download site. The mirror site will be the preferred\n     | server for that repository.\n     |-->\n    <mirrors>\n        <!-- mirror\n         | Specifies a repository mirror site to use instead of a given repository. The repository that\n         | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used\n         | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.\n         |\n        <mirror>\n          <id>mirrorId</id>\n          <mirrorOf>repositoryId</mirrorOf>\n          <name>Human Readable Name for this Mirror.</name>\n          <url>http://my.repository.com/repo/path</url>\n        </mirror>\n         -->\n        <mirror>\n            <id>osc-maven-repo</id>\n            <!--<mirrorOf>*</mirrorOf>-->\n            <mirrorOf>public</mirrorOf>\n            <name>osc-maven-repo</name>\n            <url>http://maven.oschina.net/content/groups/public/</url>\n        </mirror>\n    </mirrors>\n\n    <!-- profiles\n     | This is a list of profiles which can be activated in a variety of ways, and which can modify\n     | the build process. Profiles provided in the settings.xml are intended to provide local machine-\n     | specific paths and repository locations which allow the build to work in the local environment.\n     |\n     | For example, if you have an integration testing plugin - like cactus - that needs to know where\n     | your Tomcat instance is installed, you can provide a variable here such that the variable is\n     | dereferenced during the build process to configure the cactus plugin.\n     |\n     | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles\n     | section of this document (settings.xml) - will be discussed later. Another way essentially\n     | relies on the detection of a system property, either matching a particular value for the property,\n     | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a\n     | value of \'1.4\' might activate a profile when the build is executed on a JDK version of \'1.4.2_07\'.\n     | Finally, the list of active profiles can be specified directly from the command line.\n     |\n     | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact\n     |       repositories, plugin repositories, and free-form properties to be used as configuration\n     |       variables for plugins in the POM.\n     |\n     |-->\n    <profiles>\n        <!-- profile\n         | Specifies a set of introductions to the build process, to be activated using one or more of the\n         | mechanisms described above. For inheritance purposes, and to activate profiles via <activatedProfiles/>\n         | or the command line, profiles have to have an ID that is unique.\n         |\n         | An encouraged best practice for profile identification is to use a consistent naming convention\n         | for profiles, such as \'env-dev\', \'env-test\', \'env-production\', \'user-jdcasey\', \'user-brett\', etc.\n         | This will make it more intuitive to understand what the set of introduced profiles is attempting\n         | to accomplish, particularly when you only have a list of profile id\'s for debug.\n         |\n         | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.\n        <profile>\n          <id>jdk-1.4</id>\n\n          <activation>\n            <jdk>1.4</jdk>\n          </activation>\n\n          <repositories>\n            <repository>\n              <id>jdk14</id>\n              <name>Repository for JDK 1.4 builds</name>\n              <url>http://www.myhost.com/maven/jdk14</url>\n              <layout>default</layout>\n              <snapshotPolicy>always</snapshotPolicy>\n            </repository>\n          </repositories>\n        </profile>\n        -->\n\n        <!--\n         | Here is another profile, activated by the system property \'target-env\' with a value of \'dev\',\n         | which provides a specific path to the Tomcat instance. To use this, your plugin configuration\n         | might hypothetically look like:\n         |\n         | ...\n         | <plugin>\n         |   <groupId>org.myco.myplugins</groupId>\n         |   <artifactId>myplugin</artifactId>\n         |\n         |   <configuration>\n         |     <tomcatLocation>${tomcatPath}</tomcatLocation>\n         |   </configuration>\n         | </plugin>\n         | ...\n         |\n         | NOTE: If you just wanted to inject this configuration whenever someone set \'target-env\' to\n         |       anything, you could just leave off the <value/> inside the activation-property.\n         |\n        <profile>\n          <id>env-dev</id>\n\n          <activation>\n            <property>\n              <name>target-env</name>\n              <value>dev</value>\n            </property>\n          </activation>\n\n          <properties>\n            <tomcatPath>/path/to/tomcat/instance</tomcatPath>\n          </properties>\n        </profile>\n        -->\n        <profile>\n            <id>jdk-1.7</id>\n            <activation>\n                <jdk>1.7</jdk>\n            </activation>\n            <repositories>\n                <repository>\n                    <id>local-repo</id>\n                    <name>local-repo</name>\n                    <url>http://maven.oschina.net/content/groups/public/</url>\n                    <releases>\n                        <enabled>true</enabled>\n                    </releases>\n                    <snapshots>\n                        <enabled>false</enabled>\n                    </snapshots>\n                </repository>\n            </repositories>\n            <pluginRepositories>\n                <pluginRepository>\n                    <id>osc-maven-repo</id>\n                    <name>osc-maven-repo</name>\n                    <url>http://maven.oschina.net/content/groups/public/</url>\n                    <releases>\n                        <enabled>true</enabled>\n                    </releases>\n                    <snapshots>\n                        <enabled>false</enabled>\n                    </snapshots>\n                </pluginRepository>\n            </pluginRepositories>\n        </profile>\n    </profiles>\n\n    <!-- activeProfiles\n     | List of profiles that are active for all builds.\n     |\n    <activeProfiles>\n      <activeProfile>alwaysActiveProfile</activeProfile>\n      <activeProfile>anotherAlwaysActiveProfile</activeProfile>\n    </activeProfiles>\n    -->\n</settings>\n\n```', '2', '0', '2017-07-11 10:22:47');
INSERT INTO `note_detail` VALUES ('80', '1000', '75', 'q23esdgchfcghfgyh', '2', '0', '2017-07-12 14:22:49'), ('81', '1000', '146', '# xxx笔记\n\n[TOC]\n\n## 2\n> ***hahha***\n>> sldkfsdf\n\n\n```\npublic class Teset {\n	public static void main(String[] args) {\n	\n	}\n}\n```\n\n\n<div style=\"height: 100px; width: 200px; background-color:red\">\n<a href=\"http://www.baidu.com/\" target=\"_blank\">baidu</a>\n</div>\n\n[sdfsdf](http://www.baidu.com)\n\n\n------------\n\n- [ ] sdfd\n\n~~fgfgh~~\n\n> ~~dfgdfg~~\n\n### 2.1\nsdsdfsdf\n\n- 123\n- 234\n\n1. sdlfsdf\n2. sdlfksdf\n\n<table>\n	<tr><td>sdfsdf</td></tr>\n</table>\n\n|标题1|标题2|\n|:-:|-:|\n|c1|c2|\n\n![](http://img.qiqinote.com/2017/7/12/2c24f15f53c54ca7b7cde679a7043aad.jpg)\n\n### 2.2\n> sldkfjsdf\n\n## xx 22\n\n### 3\n#### 4\n##### 5\n###### 6\n\n', '2', '0', '2017-07-12 14:24:49'), ('82', '1', '145', '## Kotlin\n\n[TOC]\n\n### 基础语法\n\n#### Hello World!\n```\nfun main(args: Array<String>) {\n    println(\"Hello World!\")\n}\n```\n\n#### 基本类型\n|类型|字节|\n|-\n|Double|64|\n|Float|32|\n|Long|64|\n|Int|32|\n|Short|16|\n|Byte|8|\n\n#### 函数定义\n```\n有返回值函数：\nfun sum(a: Int, b: Int = 0): Int {	// b默认值为0\n    return a + b\n}\n或\nfun sum(a: Int, b: Int = 0) = a + b\n\n无返回值函数：\nfun printSum(a: Int, b: Int): Unit = println(\"a 加 b 的值为：${a + b}\")\n或\nfun printSum(a: Int, b: Int) = println(\"a 加 b 的值为：${a + b}\")\n```\n\n#### 变量\n> - val：只读变量，即只能赋值一次\n>\n```\nval a:Int			// 定义只读变量，但不赋值，此时只读变量必须明确类型\nval b: Int = 10	  // 明确类型的只读变量\nval c = 20		   // 自动推算只读变量类型\na = 30			   // 只读变量赋值\na = 40			   // 错误，已赋值的只读变量不可再赋值\n```\n> - var：可变变量\n>\n```\nvar a = 1\na += 2\n```\n\n#### 注释\n```\n// 我是一个行注释\n\n/* 我是一个多行的\n   块注释。 */\n\n/*\n	我是一个多行块注释\n	/*\n		我是一个多行嵌套块注释\n	*/\n*/\n```\n\n#### 字符串及模板\n> - 字符串模板\n>\n```\nvar a = 1\nval s1 = \"a的值为：$a\"  // 模板的简单引用\na = 2\nval s2 = \"${s1.replace(\"的值\", \"曾经的值\")}, 现在的值为：$a\"    // 模板任意表达式引用\n```\n> - 多行字符串\n>\n```\nval multiLineStr = \"\"\"\n        我是一个有\n        很多\n        很多\n        很多\n        行的字符串。\n        \"我是双引号的内容\"\n        \'我是单引号的内容\'\n        内部不支持反斜杠(\\)转义，需要这样：${\'$\'}88（88美刀）\n    \"\"\"\n```\n\n#### 判断\n> - if...else...\n>\n```\nfun maxOf(a: Int, b: Int): Int {\n    if (a > b) {\n        return a\n    } else {\n        return b\n    }\n}\n或\nfun maxOf2(a: Int, b: Int) = if (a > b) a else b\n函数间：\nval a = 1\nprintln(if (a == 1) \"返回值1\" else \"返回值2\") // 输出：返回值1\n```\n> - when\n>\n>> - when 当 if...else... 用\n>>\n```\nval x:Any = \"你猜\"\nwhen {\n	x is String -> println(\"x是一个字符串，值为：$x\")\n	x is Int -> println(\"x是一个整数，值为：$x\")\n	else -> println(\"x既不是字符串也不是整数，我也不知道它是什么\")\n}\n```\n>> - when 当 switch...case... 用\n>>\n```\n// when 会依次执行，匹配一个成功后直接返回\nval x = 3\nwhen (x) {\n	1 -> println(\"x == 1\")\n	2 -> {\n		println(\"x == 2\")\n	}\n	3,4,5 -> println(\"x是3，4，5中的一个\")\n	in 10..20 -> println(\"x是10到20之间的一个\")\n	!in 30..40 -> println(\"x不是30到40之间的一个\")\n	else -> println(\"x不是1，也不是2\")\n}\n```\n>> - when 用于函数\n>>\n```\nfun whenFun(x: Any) = when (x) {\n    is String -> \"x是一个字符串, 长度为：${x.length}\"\n    else -> \"x不是一个字符串\"\n}\n```\n\n#### 循环\n> - for...in\n>\n```\nval items = listOf<Int?>(1, 2, 3, null, 5)\nfor (item in items) {\n	println(\"循环值：$item\")\n}\nfor (index in items.indices) {\n	println(\"循环索引：$index\")\n	println(\"循环索引获取值：${items[index]}\")\n}\n```\n> - while 与 do...while\n>\n```\nval items = listOf<Int?>(1, 2, 3, null, 5)\nvar index = 0\nwhile (index < items.size) {\n	println(\"索引：$index，值：${items[index]}\")\n	index++\n}\nindex = 0\ndo {\n	println(\"索引：$index，值：${items[index]}\")\n	index++\n} while (index < items.size)\n```\n\n#### null安全\n> - \"?\" 允许null 与 \"as?\" 安全的类型转换\n>\n```\n/**\n * kotlin 默认是不允许使用null，若需要引用需在变量后加\"?\"\n */\nfun parseInt(str: String): Int? {\n    return str as? Int\n}\n```\n> - \"?.\" 空安全\n```\nval a: String? = null	// 变量a为允许null\nprintln(a?.length)	   // 所以调用属性需用\"?.\"。当a=null，返回null，当a!=null，返回length\nprintln(a!!.length)	  // 与上等价，区别在于上面返回null，\"!!\"在值为空时抛出异常：kotlin.KotlinNullPointerException\n```\n> - \"?:\" Elvis操作符\n>\n```\nval a = null\nval b = a ?: \"a值为空后调用块\"\n```\n\n#### 类型检查与自动转换\n```\nval a: Any = \"hello\"	// Any为任意类型\nprintln(a is String)    // true\nprintln(a !is String)   // false\nprintln(if (a is String) a.length else -1)  // 前面用了\"is\" 判断后就自动转换为String(如果是)，之后就可直接调用String 相应方法\n```\n\n#### 区间\n> - 检测某个值是否在区间\n>\n```\n// 数值\nval a = 10\nval b = 9\nif (a in 1..b + 1) {\n	println(\"${a}值在1到${b+1}之间\")\n}\n// 数组\nval items = listOf<String>(\"item1\", \"item2\")\nprintln(\"item\" in items)	 // false\nprintln(\"item1\" in items)	// true\n// 字符\nval str = \"abc\"\nprintln(\"bc\" in str)    // true\nprintln(\"aa\" in str)    // false\n```\n> - 区间输出\n>\n```\nfor (i in 1 until 4) print(i)   // 输出：123\nfor (i in 1..4) print(i)    	// 输出：1234\nfor (i in 4..1) print(i)    	// 什么都不输出\nfor (i in 4 downTo 1) print(i)  // 输出：4321\nfor (i in 1..4 step 2) print(i)         // 输出：13\nfor (i in 4 downTo 1 step 2) print(i)   // 输出：42\n```\n\n### 附\n参考：http://www.kotlincn.net/docs/reference/', '2', '0', '2017-07-12 15:05:35'), ('83', '1', '148', '[TOC]\n\n##### 生兔子\n> 有一对兔子，从出生后第3个月起每个月都生一对兔子。小兔子第3个月起又生小小兔子。假如兔子都不死，问每个月的兔子总数是多少？\n```java\npublic static void main(String[] args) {\n	for (int i = 1; i <= 20; i++)\n	System.out.printf(r(i) + \" \");\n}\npublic static int r(int x) {\n	if (x == 1 || x == 2) return 1;\n	else return r(x - 1) + r(x - 2);\n}\n```\n> 输出结果：\n```\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 \n```\n\n##### 素数（质数）\n> 输出 1 - 100 之间所有素数\n```java\npublic static void main(String[] args) {\n	for (int i = 1; i < 100; i++)\n		if (isSuShu(i))\n			System.out.printf(i + \" \");\n}\npublic static boolean isSuShu(int x) {\n	double half = Math.sqrt(x); // 素数只需循环判断前一半值即可\n	for (int i = 2; i <= half; i++)\n		if (x % i == 0) return false;	// 与循环值求余\n	return true;\n}\n```\n> 输出结果：\n```\n1 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 \n```\n\n##### 水仙花数\n> 打印出所有水仙花数。\"水仙花数\"是指一个三位数，其各位数的立方和等于该数本身。例如：153 = 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3。\n```java\npublic static void main(String[] args) {\n	for (int i = 100; i <= 999; i++) {\n		int a = i / 100;		// 百位的数值\n		int b = (i % 100) / 10; // 十位的数值\n		int c = i % 10;		 // 个位的数值\n		if (i == (Math.pow(a, 3) + Math.pow(b, 3) + Math.pow(c, 3)))\n		System.out.printf(i + \" \");\n	}\n}\n```\n> 输出结果：\n```\n153 370 371 407 \n```', '2', '0', '2017-07-25 14:24:55'), ('84', '1', '151', 'https://github.com/getlantern/forum/issues/833', '2', '0', '2017-07-25 17:08:53'), ('85', '1', '153', '- 查看历史操作\n\n```\n# history\n\n查看时间\n# export HISTTIMEFORMAT=\'%F %T \'\n# history\n```\n\n- 查看本机公网ip\n\n```\n# curl ifconfig.me\n```\n\n- 查看已启用的某程序信息\n\n```\n# ps -ef | grep tomcat\n# ps -aux | grep tomcat\n```\n\n- 查看端口映射\n\n```\n# netstat -apn | grep 8080\n```', '2', '0', '2017-07-27 10:06:40'), ('86', '1005', '155', '[TOC]\n# 前言\n跟着王者归来再次学习下，很多还是停留在表层，没有实质性的突破，能在项目中胜任，做些应用开发就行，岁月是杀猪刀，而有为者大多是年轻之辈。笔者没有太高追求，也不追求高艰难，只要一份工作养活自己，解决温饱足矣。\n# goto语句\n很多包括笔者读书以来，大多说不要用goto，破坏程序结构，有的直接禁用。我认为goto其实也没那么坏，只要不滥用就行，用在合适的地方就行。很多开源的代码里或多或少会用到goto，反而能使结构清晰。\n\ngoto语句大多用在跳出函数之前做些清扫工作。直接看代码：\n\n```c\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <sys/stat.h>\n    	/* 转换函数，如果成功则返回0，失败返回-1 */\n    int convert(void)\n    {\n    	FILE *fp;\n    	struct stat statbuf;	/* 文件状态的存储结构 */\n    	char *p, *q;\n    	int n;\n    	int res = -1;		/* 函数的返回值 */\n    \n    	if (stat(\"text.txt\", &statbuf) == -1)  { /* 得到文件状态，得到文件的大小 */\n    		perror(\"fail to get stat\");\n    		return res;\n    	}\n    \n    	fp = fopen(\"text.txt\", \"rb\"); /* 打开文件失败，还没有分配到资源，直接退出 */\n    	if (fp == NULL) {\n    		perror(\"fail to open\");\n    		return res;\n    	}\n    	\n    	/* 动态分配保存文件内容的缓冲区，如果失败需要关闭上一个fopen打开的文件，跳转到\n    	err1 */\n    	p = (char *)malloc(sizeof(char) * (statbuf.st_size + 1));\n    	if (p == NULL) {\n    		perror(\"fail to malloc\");\n    		goto err1;\n    	}\n    	\n    	/* 读取文件内容，如果失败，则需要释放动态分配的缓冲区，并且关闭打开的文件，跳转到\n    	err2 */\n    	n = fread(p, sizeof(char), statbuf.st_size, fp);\n    	if (n == -1) { /* 当输出字符数等于-1的时候，程序出错 */\n    		perror(\"fail to read\");\n    		goto err2;\n    	}\n    	*(p + n) = \'\\0\'; /* 设置结束标志\'v\\0\' */\n    	\n    	q = p;\n    	while (*q != \' \\0\') { /* 处理文件内容，将小写字符转换为大写字符输出 */\n    		if(\'a\' >= *q && *q <= \'z\')\n    			*q += 32; /* 大小写进行转换 */\n    		printf(\"%c\",*q);\n    		q++;\n    	}\n    	\n    	res = 0; /* 执行到此，一切正常，返回0 */\n    err2:\n    	free(p);				/* 释放动态分配的缓冲区 */\n    err1:\n    	fclose(fp);				/* 关闭打开的文件 */\n    \n    	return res;\n    }\n    \n    int main(void)\n    {\n    	if (convert( ) == -1)	/* 调用convert函数，如果出错则输出出错信息 */\n    		printf(\"fail to convert\\n\");\n    \n    	return 0;\n    }\n```\n    \n具体代码怎么编译运行，请参考此书。注意跳转逻辑，一般标号出现的顺序和跳转的顺序相反，视具体情况和写法而定。如上例子，先出现跳转到err1，再出现跳转到err2，则末尾标号出现为先err2,再err1\n\n# 分支结构\n即if () ... else ...结构，如果满足条件，就怎么样，不满足又怎么样，书中介绍了goto 实现跳转，只是加深理解，不推荐。\n# 短路计算\n一般针对&&和|| ，即表达式1&&表达式2，表达式1||表达式2 .对于&&的情况，只要表达式1为false，不再进行表达式2的计算。只有在为真的情况下才会继续判断表达式2.    对于||的情况，只要表达式1为真，则不再往下进行，只有在非真情况下才进行表达式2的判断。\n# 循环结构\n三种结构:while ();do ... while (); for (;;)\n# switch语句\n该语句结构如下：\n```\nswitch (t) {\ncase con1:\n	break;\ncase con2:\n	break;\ndefault:\n	...\n}\n```\nswitch 中条件只能式整数或者字符，谁满足条件谁执行，直到遇到break 跳出执行，没有满足条件的执行default默认分之.\n# 优化控制结构\n## 使用移位替换程序中的加减法\n程序中加减法操作应该是最快的操作，它们所消耗的时间大致为加减法1个时钟周期，乘法大概5到6个时钟周期，除法大概要50个时钟周期。移位的执行指令和加减法的差不多，所以，程序中，乘除法如果能用移位操作替换的尽量采用移位操作。\n## 常量折叠\n形如这样的代码：a = a + 10*5 + 17\n常量折叠后变成这样 a = a + 67\n\n需不需要折叠视具体情况而定。有时不折叠有利于代码理解和维护，如果折叠了，请给予详尽的注释，方便代码理解维护。\n\n## 使用数学公式\n如例子：计算1到n之间的，比如计算1到100的整数和。\n如果不用公式，采用累加会进行100次循环相加；\n如果用公式，n*(n + 1) / 2 就能直接算出结果，显然会比不用公式效率高。\n## 存储问题\n变量保存在内存之中，相当于cpu内部的寄存器操作，访问内存所消耗时间式比较大的，减少内存访问是提高程序运行效率的方法之一。\n例如：x = x + 1 和  x += 1\nx = x + 1: 执行过程分为三步，1.找左边x的内存单元的地址，2.找右边x的内存单元地址，3.计算x+1的值存储在变量x中。\nx += 1: 编译器只会获取一次x的内存单元地址，然后计算值存储到x中。\n## 分支优化-改变判断顺序\n基本原则是按概率大小，从大到小进行判断，这样能减少总的判断次数。\n## 分支优化-使用switch语句\n在合适的时候，用switch语句替代能减少些判断。\n## 循环优化-一次性计算\n在循环中有些计算是多次不变的，称为一次性计算。一次性计算在循环执行期间不改变计算的结果，在循环外计算表达式和在循环内执行的效果是一样的。对于这样的一次性计算应该放在循环外面。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2', '0', '2017-07-27 17:56:54'), ('87', '1', '158', 'http://note.youdao.com/share/?id=5204a4214e9065bfbb66a5032437a225&type=note#/', '2', '0', '2017-07-31 10:09:33'), ('88', '1', '159', '注意点：\n- 工具类中异常日志用slf，具体自行斟酌\n- 工具类中的Base64编码解码每个项目可能用的都不一样，具体自行斟酌\n\n```\n<dependency>\n	<groupId>org.slf4j</groupId>\n	<artifactId>slf4j-api</artifactId>\n	<version>1.5.8</version>\n</dependency>\n<dependency>\n<groupId>org.slf4j</groupId>\n	<artifactId>slf4j-log4j12</artifactId>\n	<version>1.5.8</version>\n</dependency>\n<dependency>\n<groupId>log4j</groupId>\n	<artifactId>log4j</artifactId>\n	<version>1.2.14</version>\n</dependency>\n```\n\n```\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.SecureRandom;\n\n/*\n * AES对称加密和解密\n */\npublic class AESUtil {\n    private static final Logger LOG = LoggerFactory.getLogger(AESUtil.class);\n    private static final String ALGORITHM = \"AES\";\n    private static final String CHARSET = \"UTF-8\";\n\n    /**\n     * AES加密\n     *\n     * @param password\n     * @param text\n     *\n     * @return 加密好的Base64文本\n     *\n     * @throws Exception\n     */\n    public static String encrypt(String password, String text) {\n        if (password == null || text == null) return null;\n        try {\n            KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM);// 创建AES的Key生产者\n\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            random.setSeed(password.getBytes());\n            keyGen.init(128, random);\n\n            SecretKey secretKey = keyGen.generateKey();\n            byte[] enCodeFormat = secretKey.getEncoded();\n            SecretKeySpec key = new SecretKeySpec(enCodeFormat, ALGORITHM);\n\n            Cipher cipher = Cipher.getInstance(ALGORITHM);\n            byte[] byteContent = text.getBytes(CHARSET);\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            byte[] result = cipher.doFinal(byteContent);\n\n            return Base64Util.encode(result);\n        } catch (Exception e) {\n            LOG.error(ExceptionUtil.getAllExceptionMessages(e));\n        }\n        return null;\n    }\n\n    /**\n     * AES解密\n     *\n     * @param password\n     * @param base64Text 需要解密的Base64\n     *\n     * @return\n     *\n     * @throws Exception\n     */\n    public static String decrypt(String password, String base64Text) {\n        if (password == null || base64Text == null) return null;\n        try {\n            KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM);\n\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            random.setSeed(password.getBytes());\n            keyGen.init(128, random);\n\n            SecretKey secretKey = keyGen.generateKey();\n            byte[] enCodeFormat = secretKey.getEncoded();\n            SecretKeySpec key = new SecretKeySpec(enCodeFormat, ALGORITHM);\n\n            Cipher cipher = Cipher.getInstance(ALGORITHM);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] result = cipher.doFinal(Base64Util.decode(base64Text));\n\n            return new String(result);\n        } catch (Exception e) {\n            LOG.error(ExceptionUtil.getAllExceptionMessages(e));\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        String str = \"4353465tihkj我alsdjflsjdflksjdfklasjdklxjcv,.mn,\";\n\n        long t1 = System.currentTimeMillis();\n        String a = AESUtil.encrypt(\"123\", str);\n        long t2 = System.currentTimeMillis();\n\n        String b = AESUtil.decrypt(\"123\", a);\n        long t3 = System.currentTimeMillis();\n\n        System.out.println(\"加密时间：\" + (t2 - t1));\n        System.out.println(\"解密时间：\" + (t3 - t2));\n\n        System.out.println();\n        System.out.println(b);\n    }\n\n}\n```', '2', '0', '2017-08-03 10:43:37'), ('89', '1', '160', '注意点：\n- 工具类中的异常日志用的是slf，具体自行斟酌\n- 工具类中用的Base64编码解码请自行斟酌\n\n```\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-api</artifactId>\n    <version>1.5.8</version>\n</dependency>\n<dependency>\n	<groupId>org.slf4j</groupId>\n    <artifactId>slf4j-log4j12</artifactId>\n    <version>1.5.8</version>\n</dependency>\n<dependency>\n	<groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.14</version>\n</dependency>\n\n<dependency>\n	<groupId>org.bouncycastle</groupId>\n	<artifactId>bcprov-jdk15on</artifactId>\n	<version>1.57</version>\n</dependency>\n```\n```\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.crypto.Cipher;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.Provider;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created by vanki on 2017/8/1.\n */\npublic class RSAUtil {\n    private static final Logger LOG = LoggerFactory.getLogger(RSAUtil.class);\n    private static final String ALGORITHM = \"RSA\";\n    private static final int KEY_SIZE = 1024;\n    private static final Provider DEFAULT_PROVIDER = new BouncyCastleProvider();    // 安全服务提供者\n\n    private static KeyFactory keyFactory;\n\n    static {\n        try {\n            keyFactory = KeyFactory.getInstance(ALGORITHM, DEFAULT_PROVIDER);\n        } catch (Exception e) {\n            LOG.error(ExceptionUtil.getAllExceptionMessages(e));\n        }\n    }\n\n	public static void main(String[] args) throws Exception {\n//        System.out.println(getKeyPair());\n        Map<String, String> keyPair = getKeyPair();\n\n//        String s = \"你好啊啊世纪东方拉斯科阿克萨减肥啦啦开发商离开房间库拉索激发了卡萨解放路卡萨丁解放路卡视角法拉盛捡垃圾福利卡就开了房间啊索拉卡大家是打发打发了快速减肥了；啊可是积分卡积分卢卡申科房间奥尔九分裤立卡京顺路看风景阿斯利康大家发了卡视角福利卡谁借我咖喱快到家陆金所的福利卡了开发IE就拿了拉结法兰琳卡手动阀拉卡拉是否；克拉克没打算vmalsdmflkasmdflalkjekf垃圾分类卡涉及到开饭啦束带结发发垃圾的福利卡建档立卡放假啊圣诞快乐两地分居\";\n        String s = \"克萨减肥啦啦开发商离开房间库拉索激发了卡萨abcdefghijklmnopqrstuvwxyz1234567890123456789012345678q萨解放路卡萨丁解放路卡视rstuvwxyz1234567890123456789012345678901234567800\";\n        System.out.println(\"原文长度：\" + s.length());\n        System.out.println(\"原文字节长度：\" + s.getBytes().length);\n\n        String clientEn = encrypt(getPublicKey(keyPair.get(\"publicKey\")), s);\n        System.out.println(\"加密密文：\" + clientEn);\n        System.out.println(\"加密密文长度：\" + clientEn.length());\n        String d1 = decrypt(getPrivateKey(keyPair.get(\"privateKey\")), clientEn);\n        System.out.println(\"解密明文：\" + d1);\n        System.out.println(\"解密明文长度：\" + d1.length());\n    }\n\n    /**\n     * 获取一对rsa公钥和私钥\n     *\n     * @return\n     *\n     * @throws Exception\n     */\n    private static Map<String, String> getKeyPair() throws Exception {\n        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM, DEFAULT_PROVIDER);\n        keyPairGenerator.initialize(KEY_SIZE);\n        KeyPair keyPair = keyPairGenerator.genKeyPair();\n\n        Map<String, String> keyPairBase64Map = new HashMap<>();\n        keyPairBase64Map.put(\"privateKey\", Base64Util.encode(keyPair.getPrivate().getEncoded()));\n        keyPairBase64Map.put(\"publicKey\", Base64Util.encode(keyPair.getPublic().getEncoded()));\n\n        return keyPairBase64Map;\n    }\n\n    /**\n     * 获取私钥\n     *\n     * @param base64PrivateKey\n     *\n     * @return\n     */\n    public static RSAPrivateKey getPrivateKey(String base64PrivateKey) {\n        if (base64PrivateKey == null) return null;\n        try {\n            PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(Base64Util.decode(base64PrivateKey));\n            RSAPrivateKey privateKey = (RSAPrivateKey) keyFactory.generatePrivate(pkcs8EncodedKeySpec);\n            return privateKey;\n        } catch (Exception e) {\n            LOG.error(ExceptionUtil.getAllExceptionMessages(e));\n        }\n        return null;\n    }\n\n    /**\n     * 获取公钥\n     *\n     * @param base64PublicKey\n     *\n     * @return\n     */\n    public static RSAPublicKey getPublicKey(String base64PublicKey) {\n        if (base64PublicKey == null) return null;\n        try {\n            X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(Base64Util.decode(base64PublicKey));\n            RSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(x509EncodedKeySpec);\n            return publicKey;\n        } catch (Exception e) {\n            LOG.error(ExceptionUtil.getAllExceptionMessages(e));\n        }\n        return null;\n    }\n\n    /**\n     * 公钥加密\n     *\n     * @param publicKey\n     * @param text\n     *\n     * @return\n     */\n    public static String encrypt(RSAPublicKey publicKey, String text) {\n        if (publicKey == null || text == null) return null;\n        ByteArrayOutputStream out = null;\n        try {\n            Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());\n            cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n\n            byte[] data = text.getBytes();\n\n            int inputLen = data.length;\n            out = new ByteArrayOutputStream();\n            int offSet = 0;\n            byte[] cache;\n            int i = 0;\n\n            int maxEncryptBlock = getMaxEncryptBlock(publicKey);\n            // 分段加密\n            while ((inputLen - offSet) > 0) {\n                if ((inputLen - offSet) > maxEncryptBlock) {\n                    cache = cipher.doFinal(data, offSet, maxEncryptBlock);\n                } else {\n                    cache = cipher.doFinal(data, offSet, inputLen - offSet);\n                }\n                out.write(cache, 0, cache.length);\n                i++;\n                offSet = i * maxEncryptBlock;\n            }\n            byte[] encryptedData = out.toByteArray();\n            return Base64Util.encode(encryptedData);\n        } catch (Exception e) {\n            LOG.error(ExceptionUtil.getAllExceptionMessages(e));\n        } finally {\n            try {\n                if (out != null) out.close();\n            } catch (IOException e) {\n                LOG.error(ExceptionUtil.getAllExceptionMessages(e));\n            }\n        }\n        return null;\n    }\n\n    /**\n     * 私钥解密\n     *\n     * @param privateKey\n     * @param encryptBase64Text\n     *\n     * @return\n     */\n    public static String decrypt(RSAPrivateKey privateKey, String encryptBase64Text) {\n        if (privateKey == null || encryptBase64Text == null) return null;\n        ByteArrayOutputStream out = null;\n        try {\n            Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n\n            byte[] encryptedData = Base64Util.decode(encryptBase64Text);\n            int inputLen = encryptedData.length;\n            out = new ByteArrayOutputStream();\n            int offSet = 0;\n            byte[] cache;\n            int i = 0;\n\n            int maxDecryptBlock = getMaxDecryptBlock(privateKey);\n            // 分段解密\n            while (inputLen - offSet > 0) {\n                if (inputLen - offSet > maxDecryptBlock) {\n                    cache = cipher.doFinal(encryptedData, offSet, maxDecryptBlock);\n                } else {\n                    cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);\n                }\n                out.write(cache, 0, cache.length);\n                i++;\n                offSet = i * maxDecryptBlock;\n            }\n            byte[] decryptedData = out.toByteArray();\n            return new String(decryptedData);\n        } catch (Exception e) {\n            LOG.error(ExceptionUtil.getAllExceptionMessages(e));\n        } finally {\n            try {\n                if (out != null) out.close();\n            } catch (IOException e) {\n                LOG.error(ExceptionUtil.getAllExceptionMessages(e));\n            }\n        }\n        return null;\n    }\n\n    /**\n     * RSA最大加密明文大小，公钥modules长度(若不是外来key，那么就是KEY_SIZE) / 8 - 11\n     *\n     * @param publicKey\n     *\n     * @return\n     */\n    private static int getMaxEncryptBlock(RSAPublicKey publicKey) {\n        if (publicKey == null) return 0;\n        return (publicKey.getModulus().bitLength() >> 3) - 11;\n    }\n\n    /**\n     * RSA最大解密密文大小，私钥modules长度(若不是外来key，那么就是KEY_SIZE) / 8\n     *\n     * @param privateKey\n     *\n     * @return\n     */\n    private static int getMaxDecryptBlock(RSAPrivateKey privateKey) {\n        if (privateKey == null) return 0;\n        return privateKey.getModulus().bitLength() >> 3;\n    }\n}\n```', '2', '0', '2017-08-03 10:44:49'), ('90', '1', '161', '#NIO\n\n---\n\nJava NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。\n\n###Java NIO: Channels and Buffers（通道和缓冲区）\n\n标准的俄IO基于字节流和字符流进行操作的，而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。\n\n###Java NIO: Non-blocking IO（非阻塞IO）\n\nJava NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。\n\n###Java NIO: Selectors(选择器)\n\nJava NIO引入了选择器的概念，选择器用于监听多个通道的事件(比如：连接打开，数据到达)。因此，单个的线程可以监听多个数据通道。\n\nNIO由以下核心部分组成：\n\n* Channels\n* Buffers\n* Selectors\n\n**Channel和Buffer**\n\n基本上，所有的IO和NIO都从一个Channel开始。Channel有点像流。数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中\n\n![](http://ifeve.com/wp-content/uploads/2013/06/overview-channels-buffers1.png)\n\nChannel的实现\n\n* FileChannel\n* DatagramChannel\n* SocketChannel\n* ServerSocketChannel\n\n这些通道涵盖了UDP和TCP网络IO，以及文件IO。\n\n以下是Java NIO里关键的Buffer实现\n\n* ByteBuffer\n* CharBuffer\n* DoubleBuffer\n* FloatBuffer\n* IntBuffer\n* LongBuffer\n* ShortBuffer\n\n这些Buffer覆盖了你能通过IO发送的基本数据类型：byte,short,int,long,float,double和char\n\nJava NIO还有个MappedByteBuffer，用于表示内存映射文件。\n\n**Selextor**\n\nSelector允许单线程处理多个Channel。如果你的应用打开了多个连接(通道)，但每一个连接的流量都很低，使用Selector就会很方便。\n\n例如，在一个聊天服务器中\n\n这是在一个单线程中使用一个Selector处理3个Channel的图示：\n\n![](http://ifeve.com/wp-content/uploads/2013/06/overview-selectors.png)\n\n要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接送等。\n\n\n##Channel\n---\n\nJava NIO的通道类似流，但又有些不同：\n\n* 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\n* 通道可以异步的读写。\n* 通道的数据总是要先读到一个Buffer，或者总要从一个Buffer中写入。\n\n正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。\n\n**Channel的实现**\n\n* FileChannel  从文件中读取数据\n* DataChannel  能通过UDP读写网络中的数据\n* SocketChannel   能通过TCP读写网络中的数据\n* ServerSocketChannel   可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel\n\n\n基本的Channel示例\n\n下面是一个使用FileChannel读取数据到Buffer中的示例\n\n```\nRandomAccessFile aFile = new RandomAccessFile(\"data/nio-data.txt\", \"rw\");\nFileChannel inChannel = aFile.getChannel();\nByteBuffer buf = ByteBuffer.allocate(48);\nint bytesRead = inChannel.read(buf);\nwhile (bytesRead != -1) {\nSystem.out.println(\"Read \" + bytesRead);\nbuf.flip();\nwhile(buf.hasRemaining()){\nSystem.out.print((char) buf.get());\n}\nbuf.clear();\nbytesRead = inChannel.read(buf);\n}\naFile.close();\n\n```\n注意 buf.flip() 的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据。\n\n\n##Buffer\n\nJava NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。\n\n缓冲区本质是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问这块内存。\n\n**Buffer的基本用法**\n\n使用Buffer读写数据一般遵循以下四个步骤：\n\n1. 写入数据到Buffer\n2. 调用flip()方法\n3. 从Buffer中读取数据\n4. 调用clear()方法或者compact()方法', '2', '0', '2017-08-04 11:23:18'), ('91', '1', '163', '# Java并发\n---\n\n（Executor框架和多线程基础）\n\n**Thread与Runable如何实现多线程**\n\nJava 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。\n\n实现Runnable接口相比继承Thread类有如下优势：\n\n1. 可以避免由于Java的单继承特性而带来的局限\n2. 增强程序的健壮性，代码能够被多个程序共享，代码与数据是独立的\n3. 适合多个相同程序代码的线程区处理同一资源的情况\n\n补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示：\n\n```\nclass MyTask implements Callable<Integer> {  \n    private int upperBounds;  \n      \n    public MyTask(int upperBounds) {  \n        this.upperBounds = upperBounds;  \n    }  \n      \n    @Override  \n    public Integer call() throws Exception {  \n        int sum = 0;   \n        for(int i = 1; i <= upperBounds; i++) {  \n            sum += i;  \n        }  \n        return sum;  \n    }  \n      \n}  \n  \npublic class Test {  \n  \n    public static void main(String[] args) throws Exception {  \n        List<Future<Integer>> list = new ArrayList<>();  \n        ExecutorService service = Executors.newFixedThreadPool(10);  \n        for(int i = 0; i < 10; i++) {  \n            list.add(service.submit(new MyTask((int) (Math.random() * 100))));  \n        }  \n          \n        int sum = 0;  \n        for(Future<Integer> future : list) {  \n            while(!future.isDone()) ;  \n            sum += future.get();  \n        }  \n          \n        System.out.println(sum);  \n    }  \n}  \n```\n\n**线程同步的方法有什么；锁，synchronized块，信号量等**\n\n\n\n**锁的等级：方法锁、对象锁、类锁**\n\n**生产者消费者模式的几种实现，阻塞队列实现，sync关键字实现，lock实现,reentrantLock等**\n\n**ThreadLocal的设计理念与作用，ThreadPool用法与优势（这里在Android SDK原生的AsyncTask底层也有使用）**\n\n**线程池的底层实现和工作原理（建议写一个雏形简版源码实现）**\n\n**几个重要的线程api，interrupt，wait，sleep，stop等等**\n\n**写出生产者消费者模式。**\n\n**ThreadPool用法与优势。**\n\n**Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。**\n\n**wait()和sleep()的区别。**\n\nsleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用sleep 不会释放对象锁。wait()是Object 类的方法，对此对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。\n', '2', '0', '2017-08-04 11:36:55'), ('92', '1', '164', '#synchronized\n---\n\n在并发编程中，多线程同时并发访问的资源叫做临界资源，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机制，以确保在某一时刻，方法内只允许有一个线程。\n\n采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。\n\n这里就使用同步机制获取互斥锁的情况，进行几点说明：\n\n1. 如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。\n2. 类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的synchronized同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问synchronized同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。\n3. 访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。\n4. 持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非synchronized代码。当一个线程A持有一个对象级别锁（即进入了synchronized修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程B有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用synchronized修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让A线程运行，A线程继续持有对象级别锁，当A线程退出同步代码时（即释放了对象级别锁），如果B线程此时再运行，便会获得该对象级别锁，从而执行synchronized中的代码。\n5. 持有对象级别锁的线程会让其他线程阻塞在所有的synchronized代码外。例如，在一个类中有三个synchronized方法a，b，c，当线程A正在执行一个实例对象M中的方法a时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象M）中的代码时，便会在所有的synchronized方法处阻塞，即在方法a，b，c处都要被阻塞，等线程A释放掉对象级别锁时，其他的线程才可以去执行方法a，b或者c中的代码，从而获得该对象级别锁。\n6. 使用synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj为对象的引用，如果获取了obj对象上的对象级别锁，在并发访问obj对象时时，便会在其synchronized代码处阻塞等待，直到获取到该obj对象的对象级别锁。当obj为this时，便是获取当前对象的对象级别锁。\n7. 类级别锁被特定类的所有示例共享，它用于控制对static成员变量以及static方法的并发访问。具体用法与对象级别锁相似。\n8. 互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁便被释放了。由于synchronized同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。\n\n##内存可见性\n\n加锁（synchronized同步）的功能不仅仅局限于互斥行为，同时还存在另外一个重要的方面：内存可见性。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且还希望确保当一个线程修改了对象状态后，其他线程能够看到该变化。而线程的同步恰恰也能够实现这一点。\n\n内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。为了确保所有的线程都能看到共享变量的最新值，可以在所有执行读操作或写操作的线程上加上同一把锁。下图示例了同步的可见性保证。\n\n![](http://img.blog.csdn.net/20131212211029125)\n\n当线程A执行某个同步代码块时，线程B随后进入由同一个锁保护的同步代码块，这种情况下可以保证，当锁被释放前，A看到的所有变量值（锁释放前，A看到的变量包括y和x）在B获得同一个锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个锁保护的同步代码块中的所有操作结果。如果在线程A unlock M之后，线程B才进入lock M，那么线程B都可以看到线程A unlock M之前的操作，可以得到i=1，j=1。如果在线程B unlock M之后，线程A才进入lock M，那么线程B就不一定能看到线程A中的操作，因此j的值就不一定是1。\n\n现在考虑如下代码：\n\n```\npublic class  MutableInteger  \n{  \n    private int value;  \n  \n    public int get(){  \n        return value;  \n    }  \n    public void set(int value){  \n        this.value = value;  \n    }  \n}  \n```\n\n以上代码中，get和set方法都在没有同步的情况下访问value。如果value被多个线程共享，假如某个线程调用了set，那么另一个正在调用get的线程可能会看到更新后的value值，也可能看不到。\n\n通过对set和get方法进行同步，可以使MutableInteger成为一个线程安全的类，如下：\n\n```\npublic class  SynchronizedInteger  \n{  \n    private int value;  \n  \n    public synchronized int get(){  \n        return value;  \n    }  \n    public synchronized void set(int value){  \n        this.value = value;  \n    }  \n}  \n```\n\n对set和get方法进行了同步，加上了同一把对象锁，这样get方法可以看到set方法中value值的变化，从而每次通过get方法取得的value的值都是最新的value值。', '2', '0', '2017-08-04 11:37:19'), ('93', '1', '165', '# Thread和Runnable实现多线程的区别\n---\n\nJava中实现多线程有两种方法：继承Thread、实现Runnable接口，在程序开发中只要是多线程，肯定永远以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类有如下优势：\n\n1. 可以避免由于Java的单继承特性而带来的局限\n2. 增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的\n3. 适合多个相同程序的线程区处理同一资源的情况\n\n首先通过Thread类实现\n\n```\nclass MyThread extends Thread{  \n    private int ticket = 5;  \n    public void run(){  \n        for (int i=0;i<10;i++)  \n        {  \n            if(ticket > 0){  \n                System.out.println(\"ticket = \" + ticket--);  \n            }  \n        }  \n    }  \n}  \n  \npublic class ThreadDemo{  \n    public static void main(String[] args){  \n        new MyThread().start();  \n        new MyThread().start();  \n        new MyThread().start();  \n    }  \n} \n```\n\n运行结果：\n\n```\nticket = 5\nticket = 4\nticket = 5\nticket = 5\nticket = 4\nticket = 3\nticket = 2\nticket = 1\nticket = 4\nticket = 3\nticket = 3\nticket = 2\nticket = 1\nticket = 2\nticket = 1\n```\n\n每个线程单独卖了5张票，即独立的完成了买票的任务，但实际应用中，比如火车站售票，需要多个线程去共同完成任务，在本例中，即多个线程共同买5张票。\n\n通过实现Runnable借口实现的多线程程序\n\n```\nclass MyThread implements Runnable{  \n    private int ticket = 5;  \n    public void run(){  \n        for (int i=0;i<10;i++)  \n        {  \n            if(ticket > 0){  \n                System.out.println(\"ticket = \" + ticket--);  \n            }  \n        }  \n    }  \n}  \n  \npublic class RunnableDemo{  \n    public static void main(String[] args){  \n        MyThread my = new MyThread();  \n        new Thread(my).start();  \n        new Thread(my).start();  \n        new Thread(my).start();  \n    }  \n} \n```\n\n运行结果\n\n```\nticket = 5\nticket = 2\nticket = 1\nticket = 3\nticket = 4\n```\n\n* 在第二种方法(Runnable)中，ticket输出的顺序并不是54321，这是因为线程执行的时机难以预测。ticket并不是原子操作。\n* 在第一种方法中，我们new了3个Thread对象，即三个线程分别执行三个对象中的代码，因此便是三个线程去独立地完成卖票的任务；而在第二种方法中，我们同样也new了3个Thread对象，但只有一个Runnable对象，3个Thread对象共享这个Runnable对象中的代码，因此，便会出现3个线程共同完成卖票任务的结果。如果我们new出3个Runnable对象，作为参数分别传入3个Thread对象中，那么3个线程便会独立执行各自Runnable对象中的代码，即3个线程各自卖5张票。\n* 在第二种方法中，由于3个Thread对象共同执行一个Runnable对象中的代码，因此可能会造成线程的不安全，比如可能ticket会输出-1（如果我们System.out....语句前加上线程休眠操作，该情况将很有可能出现），这种情况的出现是由于，一个线程在判断ticket为1>0后，还没有来得及减1，另一个线程已经将ticket减1，变为了0，那么接下来之前的线程再将ticket减1，便得到了-1。这就需要加入同步操作（即互斥锁），确保同一时刻只有一个线程在执行每次for循环中的操作。而在第一种方法中，并不需要加入同步操作，因为每个线程执行自己Thread对象中的代码，不存在多个线程共同执行同一个方法的情况。\n', '2', '0', '2017-08-04 11:39:56'), ('94', '1', '166', '# 使用wait/notify/notifyAll实现线程间通信\n---\n\n在Java中，可以通过配合调用Object对象的wait（）方法和notify（）方法或notifyAll（）方法来实现线程间的通信。在线程中调用wait（）方法，将阻塞等待其他线程的通知（其他线程调用notify（）方法或notifyAll（）方法），在线程中调用notify（）方法或notifyAll（）方法，将通知其他线程从wait（）方法处返回。\n\nObject是所有类的超类，它有5个方法组成了等待/通知机制的核心：notify（）、notifyAll（）、wait（）、wait（long）和wait（long，int）。在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为final，因此在子类中不能覆写任何一个方法。\n\n这里详细说明一下各个方法在使用中需要注意的几点：\n\n1、wait（）\n\n```\npublic final void wait()  throws InterruptedException,IllegalMonitorStateException\n```\n\n该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用wait（）之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法。进入wait（）方法后，当前线程释放锁。在从wait（）返回前，线程与其他线程竞争重新获得锁。如果调用wait（）时，没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。\n\n2、notify（）\n\n```\npublic final native void notify() throws IllegalMonitorStateException\n```\n\n该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，的如果调用notify（）时没有持有适当的锁，也会抛出IllegalMonitorStateException。\n\n该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个wait（）状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的notifyAll（）方法执行后的情况不同。 \n\n3、notifyAll（）\n\n```\npublic final native void notifyAll() throws IllegalMonitorStateException\n```\n\n该方法与notify（）方法的工作方式相同，重要的一点差异是：\n\nnotifyAll使所有原来在该对象上wait的线程统统退出wait的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。\n\n4、wait（long）和wait（long,int）\n\n显然，这两个方法是设置等待超时时间的，后者在超值时间上加上ns，精度也难以达到，因此，该方法很少使用。对于前者，如果在等待线程接到通知或被中断之前，已经超过了指定的毫秒数，则它通过竞争重新获得锁，并从wait（long）返回。另外，需要知道，如果设置了超时时间，当wait（）返回时，我们不能确定它是因为接到了通知还是因为超时而返回的，因为wait（）方法不会返回任何相关的信息。但一般可以通过设置标志位来判断，在notify之前改变标志位的值，在wait（）方法后读取该标志位的值来判断，当然为了保证notify不被遗漏，我们还需要另外一个标志位来循环判断是否调用wait（）方法。\n\n\n深入理解：\n\n* 如果线程调用了对象的wait（）方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\n* 当有线程调用了对象的notifyAll（）方法（唤醒所有wait线程）或notify（）方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。\n* 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait（）方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。\n', '2', '0', '2017-08-04 11:44:37'), ('95', '1', '167', '# 可重入内置锁\n---\n\n每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁或监视器锁。线程在进入同步代码块之前会自动获取锁，并且在退出同步代码块时会自动释放锁。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。\n\n当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是调用。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程所持有，当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1，如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。\n\n重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。分析如下程序：\n\n```\npublic class Father  \n{  \n    public synchronized void doSomething(){  \n        ......  \n    }  \n}  \n  \npublic class Child extends Father  \n{  \n    public synchronized void doSomething(){  \n        ......  \n        super.doSomething();  \n    }  \n}  \n```\n\n子类覆写了父类的同步方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码件产生死锁。\n\n由于Fither和Child中的doSomething方法都是synchronized方法，因此每个doSomething方法在执行前都会获取Child对象实例上的锁。如果内置锁不是可重入的，那么在调用super.doSomething时将无法获得该Child对象上的互斥锁，因为这个锁已经被持有，从而线程会永远阻塞下去，一直在等待一个永远也无法获取的锁。重入则避免了这种死锁情况的发生。\n\n同一个线程在调用本类中其他synchronized方法/块或父类中的synchronized方法/块时，都不会阻碍该线程地执行，因为互斥锁时可重入的。', '2', '0', '2017-08-04 11:47:12'), ('96', '1', '168', '# 多线程环境中安全使用集合API\n---\n\n在集合API中，最初设计的Vector和Hashtable是多线程安全的。例如：对于Vector来说，用来添加和删除元素的方法是同步的。如果只有一个线程与Vector的实例交互，那么，要求获取和释放对象锁便是一种浪费，另外在不必要的时候如果滥用同步化，也有可能会带来死锁。因此，对于更改集合内容的方法，没有一个是同步化的。集合本质上是非多线程安全的，当多个线程与集合交互时，为了使它多线程安全，必须采取额外的措施。\n\n在Collections类 中有多个静态方法，它们可以获取通过同步方法封装非同步集合而得到的集合：\n\n* public static Collection synchronizedCollention(Collection c)\n* public static List synchronizedList(list l)\n* public static Map synchronizedMap(Map m)\n* public static Set synchronizedSet(Set s)\n* public static SortedMap synchronizedSortedMap(SortedMap sm)\n* public static SortedSet synchronizedSortedSet(SortedSet ss)\n\n\n这些方法基本上返回具有同步集合方法版本的新类。比如，为了创建多线程安全且由ArrayList支持的List，可以使用如下代码：\n\n```\nList list = Collection.synchronizedList(new ArrayList());\n```\n\n注意，ArrayList实例马上封装起来，不存在对未同步化ArrayList的直接引用（即直接封装匿名实例）。这是一种最安全的途径。如果另一个线程要直接引用ArrayList实例，它可以执行非同步修改。\n\n下面给出一段多线程中安全遍历集合元素的示例。我们使用Iterator逐个扫描List中的元素，在多线程环境中，当遍历当前集合中的元素时，一般希望阻止其他线程添加或删除元素。安全遍历的实现方法如下：\n\n```\nimport java.util.*;  \n  \npublic class SafeCollectionIteration extends Object {  \n    public static void main(String[] args) {  \n        //为了安全起见，仅使用同步列表的一个引用，这样可以确保控制了所有访问  \n        //集合必须同步化，这里是一个List  \n        List wordList = Collections.synchronizedList(new ArrayList());  \n  \n        //wordList中的add方法是同步方法，会获取wordList实例的对象锁  \n        wordList.add(\"Iterators\");  \n        wordList.add(\"require\");  \n        wordList.add(\"special\");  \n        wordList.add(\"handling\");  \n  \n        //获取wordList实例的对象锁，  \n        //迭代时，阻塞其他线程调用add或remove等方法修改元素  \n        synchronized ( wordList ) {  \n            Iterator iter = wordList.iterator();  \n            while ( iter.hasNext() ) {  \n                String s = (String) iter.next();  \n                System.out.println(\"found string: \" + s + \", length=\" + s.length());  \n            }  \n        }  \n    }  \n}  \n```\n\n这里需要注意的是：在Java语言中，大部分的线程安全类都是相对线程安全的，它能保证对这个对象单独的操作时线程安全的，我们在调用的时候不需要额外的保障措施，但是对于一些特定的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。例如Vector、HashTable、Collections的synchronizedXxxx（）方法包装的集合等。', '2', '0', '2017-08-04 11:49:56'), ('97', '1', '169', '# 守护线程与阻塞线程的四种情况\n---\n\nJava中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)\n\n用户线程即运行在前台的线程，而守护线程是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出，因为如果没有了守护者，也就没有继续运行程序的必要了。如果有非守护线程仍然活着，VM就不会退出。\n\n守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用Thread的setDaemon(true)方法设置当前线程为守护线程。\n\n虽然守护线程可能非常有用，但必须小心确保其它所有非守护线程消亡时，不会由于它的终止而产生任何危害。因为你不可能知道在所有的用户线程退出运行前，守护线程是否已经完成了预期的服务任务。一旦所有的用户线程退出了，虚拟机也就退出运行了。因此，不要再守护线程中执行业务逻辑操作(比如对数据的读写等)。\n\n还有几点：\n\n1. setDaemon(true)必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常。\n2. 在守护线程中产生的新线程也是守护线程\n3. 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。\n\n\n##线程阻塞\n\n线程可以阻塞于四种状态：\n\n1. 当线程执行Thread.sleep()时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断\n2. 当线程碰到一条wait()语句时，它会一直阻塞到接到通知(notify())、被中断或经过了指定毫秒 时间为止(若指定了超时值的话)\n3. 线程阻塞与不同的I/O的方式有多种。常见的一种方式是InputStream的read()方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间\n4. 线程也可以阻塞等待获取某个对象锁的排它性访问权限(即等待获得synchronized语句必须的锁时阻塞)\n\n并非所有的阻塞状态都是可中断的，以上阻塞状态的前两种可以被中断，后两种不会对中断做出反应。\n', '2', '0', '2017-08-04 11:52:12'), ('98', '1', '170', '# 并发编程中实现内存可见的两种方法比较：加锁和volatile变量\n---\n\n 1. volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。\n\n2. 从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。\n\n3. 在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。\n\n4. 加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。\n\n当且仅当满足以下所有条件时，才应该使用volatile变量：\n\n1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。\n2. 该变量没有包含在具有其他变量的不变式中。\n\n\n总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。', '2', '0', '2017-08-04 11:52:38'), ('99', '1', '171', '# 死锁\n---\n\n当线程需要同时持有多个锁时，有可能产生死锁。考虑如下情形：\n\n线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。接下来，当线程A仍然持有lock1时，它试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2的释放。如果此时线程B在持有lock2的时候，也在试图获取lock1，因为线程A正持有lock1，因此线程B会阻塞等待A对lock1的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。\n\n下面给出一个两个线程间产生死锁的示例，如下：\n\n```\n\npublic class Deadlock {\n\n	private String objID;\n\n	public Deadlock(String id) {\n		objID = id;\n	}\n\n	public synchronized void checkOther(Deadlock other) {\n		print(\"entering checkOther()\");  \n        try { Thread.sleep(2000); }   \n        catch ( InterruptedException x ) { }  \n        print(\"in checkOther() - about to \" + \"invoke \'other.action()\'\");  \n      //调用other对象的action方法，由于该方法是同步方法，因此会试图获取other对象的对象锁  \n        other.action();  \n        print(\"leaving checkOther()\");  \n	}\n	\n	public synchronized void action() {  \n        print(\"entering action()\");  \n        try { Thread.sleep(500); }   \n        catch ( InterruptedException x ) { }  \n        print(\"leaving action()\");  \n    }  \n\n	public void print(String msg) {\n		threadPrint(\"objID=\" + objID + \" - \" + msg);\n	}\n	\n	public static void threadPrint(String msg) {  \n        String threadName = Thread.currentThread().getName();  \n        System.out.println(threadName + \": \" + msg);  \n    }  \n	\n	public static void main(String[] args) {\n		final Deadlock obj1 = new Deadlock(\"obj1\");  \n        final Deadlock obj2 = new Deadlock(\"obj2\");  \n        \n        Runnable runA = new Runnable() {  \n            public void run() {  \n                obj1.checkOther(obj2);  \n            }  \n        };  \n        \n        Thread threadA = new Thread(runA, \"threadA\");  \n        threadA.start();  \n  \n        try { Thread.sleep(200); }   \n        catch ( InterruptedException x ) { }  \n        \n        Runnable runB = new Runnable() {  \n            public void run() {  \n                obj2.checkOther(obj1);  \n            }  \n        };  \n        \n        Thread threadB = new Thread(runB, \"threadB\");  \n        threadB.start();  \n  \n        try { Thread.sleep(5000); }   \n        catch ( InterruptedException x ) { }  \n  \n        threadPrint(\"finished sleeping\");  \n  \n        threadPrint(\"about to interrupt() threadA\"); \n        \n        threadA.interrupt();  \n        \n        try { Thread.sleep(1000); }   \n        catch ( InterruptedException x ) { }  \n  \n        threadPrint(\"about to interrupt() threadB\");  \n        threadB.interrupt();  \n  \n        try { Thread.sleep(1000); }   \n        catch ( InterruptedException x ) { }  \n  \n        threadPrint(\"did that break the deadlock?\");  \n	}\n}\n\n```\n\n运行结果：\n\n```\nthreadA: objID=obj1 - entering checkOther()\nthreadB: objID=obj2 - entering checkOther()\nthreadA: objID=obj1 - in checkOther() - about to invoke \'other.action()\'\nthreadB: objID=obj2 - in checkOther() - about to invoke \'other.action()\'\nmain: finished sleeping\nmain: about to interrupt() threadA\nmain: about to interrupt() threadB\nmain: did that break the deadlock?\n```\n\n从结果中可以看出，在执行到other.action（）时，由于两个线程都在试图获取对方的锁，但对方都没有释放自己的锁，因而便产生了死锁，在主线程中试图中断两个线程，但都无果。\n\n大部分代码并不容易产生死锁，死锁可能在代码中隐藏相当长的时间，等待不常见的条件地发生，但即使是很小的概率，一旦发生，便可能造成毁灭性的破坏。避免死锁是一件困难的事，遵循以下原则有助于规避死锁： \n\n1. 只在必要的最短时间内持有锁，考虑使用同步语句块代替整个同步方法；\n2. 尽量编写不在同一时刻需要持有多个锁的代码，如果不可避免，则确保线程持有第二个锁的时间尽量短暂；\n3. 创建和使用一个大锁来代替若干小锁，并把这个锁用于互斥，而不是用作单个对象的对象级别锁；', '2', '0', '2017-08-04 11:53:16'), ('100', '1', '172', '# 生产者和消费者问题\n\n```\npackage 生产者消费者;\n\npublic class ProducerConsumerTest {\n\n	public static void main(String[] args) {\n		PublicResource resource = new PublicResource();\n		new Thread(new ProducerThread(resource)).start();\n        new Thread(new ConsumerThread(resource)).start();\n        new Thread(new ProducerThread(resource)).start();\n        new Thread(new ConsumerThread(resource)).start();\n        new Thread(new ProducerThread(resource)).start();\n        new Thread(new ConsumerThread(resource)).start();\n	}\n}\n```\n```\npackage 生产者消费者;\n/**\n * 生产者线程，负责生产公共资源\n * @author dream\n *\n */\npublic class ProducerThread implements Runnable{\n\n	private PublicResource resource;\n\n	\n	public ProducerThread(PublicResource resource) {\n		this.resource = resource;\n	}\n\n\n	@Override\n	public void run() {\n		while (true) {\n			try {\n				Thread.sleep((long) (Math.random() * 1000));\n			} catch (InterruptedException e) {\n				e.printStackTrace();\n			}\n			resource.increase();\n		}\n	}\n	\n	\n}\n```\n\n```\npackage 生产者消费者;\n\n/**\n * 消费者线程，负责消费公共资源\n * @author dream\n *\n */\npublic class ConsumerThread implements Runnable{\n\n	private PublicResource resource;\n	\n	\n	public ConsumerThread(PublicResource resource) {\n		this.resource = resource;\n	}\n\n\n	@Override\n	public void run() {\n		while (true) {\n			try {\n				Thread.sleep((long) (Math.random() * 1000));\n			} catch (InterruptedException e) {\n				// TODO Auto-generated catch block\n				e.printStackTrace();\n			}\n			resource.decrease();\n		}\n		\n	}\n	\n\n}\n```\n\n```\npackage 生产者消费者;\n\n/**\n * 公共资源类\n * @author dream\n *\n */\npublic class PublicResource {\n\n	private int number = 0;\n	private int size = 10;\n	\n	/**\n	 * 增加公共资源\n	 */\n	public synchronized void increase()\n	{\n		while (number >= size) {\n			try {\n				wait();\n			} catch (InterruptedException e) {\n				// TODO Auto-generated catch block\n				e.printStackTrace();\n			}\n		}\n		number++;\n		System.out.println(\"生产了1个，总共有\" + number);\n		notifyAll();\n	}\n	\n	\n	/**\n	 * 减少公共资源\n	 */\n	public synchronized void decrease()\n	{\n		while (number <= 0) {\n			try {\n				wait();\n			} catch (InterruptedException e) {\n				// TODO Auto-generated catch block\n				e.printStackTrace();\n			}\n		}\n		number--;\n		System.out.println(\"消费了1个，总共有\" + number);\n		notifyAll();\n	}\n}\n\n```\n', '2', '0', '2017-08-04 11:53:55'), ('101', '1', '173', '# 线程中断\n---\n\n##使用interrupt()中断线程\n\n当一个线程运行时，另一个线程可以调用对应的Thread对象的interrupt（）方法来中断它，该方法只是在目标线程中设置一个标志，表示它已经被中断，并立即返回。这里需要注意的是，如果只是单纯的调用interrupt（）方法，线程并没有实际被中断，会继续往下执行。\n\n演示休眠线程的中断\n\n```\n\npublic class SleepInterrupt extends Object implements Runnable{\n\n	@Override\n	public void run() {\n		\n		try {\n			System.out.println(\"in run() - about to sleep for 20 seconds\");\n			Thread.sleep(20000);\n			System.out.println(\"in run() - woke up\");\n		} catch (InterruptedException e) {\n			System.out.println(\"in run() - interrupted while sleeping\");\n			//处理完中断异常后，返回到run()方法入口\n			//如果没有return,线程不会实际被中断，它会继续打印下面的信息\n			return;\n		}\n		System.out.println(\"in run() - leaving normally\");\n	}\n	\n	public static void main(String[] args) {\n		SleepInterrupt si = new SleepInterrupt();\n		Thread t = new Thread(si);\n		t.start();\n		//住线程休眠2秒，从而确保刚才启动的线程有机会执行一段时间\n		try {\n			Thread.sleep(2000);\n		} catch (InterruptedException e) {\n			e.printStackTrace();\n		}\n		System.out.println(\"in main() - interrupting other thread\"); \n		//中断线程t\n		t.interrupt();\n		System.out.println(\"in main() - leaving\");\n	}\n\n}\n\n```\n\n运行结果如下：\n\n```\nin run() - about to sleep for 20 seconds\nin main() - interrupting other thread\nin main() - leaving\nin run() - interrupted while sleeping\n```\n\n主线程启动新线程后，自身休眠2秒钟，允许新线程获得运行时间。新线程打印信息“about to sleep for 20 seconds”后，继而休眠20秒钟，大约2秒钟后，main线程通知新线程中断，那么新线程的20秒的休眠将被打断，从而抛出InterruptException异常，执行跳转到catch块，打印出“interrupted while sleeping”信息，并立即从run（）方法返回，然后消亡，而不会打印出catch块后面的“leaving normally”信息。\n\n请注意：由于不确定的线程规划，上图运行结果的后两行可能顺序相反，这取决于主线程和新线程哪个先消亡。但前两行信息的顺序必定如上图所示。\n\n另外，如果将catch块中的return语句注释掉，则线程在抛出异常后，会继续往下执行，而不会被中断，从而会打印出”leaving normally“信息。\n\n##待决中断\n---\n在上面的例子中，sleep（）方法的实现检查到休眠线程被中断，它会相当友好地终止线程，并抛出InterruptedException异常。另外一种情况，如果线程在调用sleep（）方法前被中断，那么该中断称为待决中断，它会在刚调用sleep（）方法时，立即抛出InterruptedException异常。\n\n```\n\npublic class PendingInterrupt extends Object{\n\n	public static void main(String[] args) {\n		//如果输入了参数，则在main线程中中断当前线程（即main线程）\n		if(args.length > 0){\n			Thread.currentThread().interrupt();\n		}\n		//获取当前时间\n		long startTime = System.currentTimeMillis();\n		try {\n			Thread.sleep(2000);\n			System.out.println(\"was NOT interrupted\");\n		} catch (InterruptedException e) {\n			System.out.println(\"was interrupted\");\n		}\n		//计算中间代码执行的时间\n		System.out.println(\"elapsedTime=\" + (System.currentTimeMillis() - startTime));\n	}\n}\n\n```\n\n如果PendingInterrupt不带任何命令行参数，那么线程不会被中断，最终输出的时间差距应该在2000附近（具体时间由系统决定，不精确），如果PendingInterrupt带有命令行参数，则调用中断当前线程的代码，但main线程仍然运行，最终输出的时间差距应该远小于2000，因为线程尚未休眠，便被中断，因此，一旦调用sleep（）方法，会立即打印出catch块中的信息。执行结果如下:\n\n```\nwas NOT interrupted\nelapsedTime=2001\n\n```\n\n这种模式下，main线程中断它自身。除了将中断标志（它是Thread的内部标志）设置为true外，没有其他任何影响。线程被中断了，但main线程仍然运行，main线程继续监视实时时钟，并进入try块，一旦调用sleep（）方法，它就会注意到待决中断的存在，并抛出InterruptException。于是执行跳转到catch块，并打印出线程被中断的信息。最后，计算并打印出时间差。\n\n##使用isInterrupted（）方法判断中断状态\n---\n\n可以在Thread对象上调用isInterrupted（）方法来检查任何线程的中断状态。这里需要注意：线程一旦被中断，isInterrupted（）方法便会返回true，而一旦sleep（）方法抛出异常，它将清空中断标志，此时isInterrupted（）方法将返回false。\n\n下面的代码演示了isInterrupted（）方法的使用：\n\n```\n\npublic class InterruptCheck extends Object{\n	\n	public static void main(String[] args) {\n		Thread t = Thread.currentThread();\n		System.out.println(\"Point A: t.isInterrupted()=\" + t.isInterrupted());  \n        //待决中断，中断自身  \n        t.interrupt();  \n        System.out.println(\"Point B: t.isInterrupted()=\" + t.isInterrupted());  \n        System.out.println(\"Point C: t.isInterrupted()=\" + t.isInterrupted());  \n	\n        try {\n			Thread.sleep(2000);\n			System.out.println(\"was NOT interrupted\");  \n		} catch (InterruptedException e) {\n			System.out.println(\"was interrupted\");  \n		}\n        //跑出异常后，会清除中断标志，这里会返回false\n        System.out.println(\"Point D: t.isInterrupted()=\" + t.isInterrupted());\n	}\n\n}\n\n```\n\n运行结果如下：\n\n```\nPoint A: t.isInterrupted()=false\nPoint B: t.isInterrupted()=true\nPoint C: t.isInterrupted()=true\nwas interrupted\nPoint D: t.isInterrupted()=false\n\n```\n\n##使用Thread.interrupted（）方法判断中断状态\n---\n\n可以使用Thread.interrupted（）方法来检查当前线程的中断状态（并隐式重置为false）。又由于它是静态方法，因此不能在特定的线程上使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回true。与isInterrupted（）不同，它将自动重置中断状态为false，第二次调用Thread.interrupted（）方法，总是返回false，除非中断了线程。\n\n如下代码演示了Thread.interrupted（）方法的使用：\n\n```\n\npublic class InterruptReset extends Object{\n	\n	public static void main(String[] args) {\n		System.out.println(  \n	            \"Point X: Thread.interrupted()=\" + Thread.interrupted());  \n	        Thread.currentThread().interrupt();  \n	        System.out.println(  \n	            \"Point Y: Thread.interrupted()=\" + Thread.interrupted());  \n	        System.out.println(  \n	            \"Point Z: Thread.interrupted()=\" + Thread.interrupted());  \n	}\n\n}\n\n```\n\n运行结果\n\n\n```\nPoint X: Thread.interrupted()=false\nPoint Y: Thread.interrupted()=true\nPoint Z: Thread.interrupted()=false\n\n```\n\n从结果中可以看出，当前线程中断自身后，在Y点，中断状态为true，并由Thread.interrupted（）自动重置为false，那么下次调用该方法得到的结果便是false。\n\n##补充\n---\n\nyield和join方法的使用\n\n* join方法用线程对象调用，如果在一个线程A中调用另一个线程B的join方法，线程A将会等待线程B执行完毕后再执行。\n* yield可以直接用Thread类调用，yield让出CPU执行权给同等级的线程，如果没有相同级别的线程在等待CPU的执行权，则该线程继续执行。', '2', '0', '2017-08-04 11:55:13'), ('102', '1', '175', '# ArrarList\n---\n* 是一个类\n* 实现的接口：List、Collectin、Iterable、Serializable、Cloneable、RandomAccess\n* 子类：AttributeList、RoleList、RoleUnresolvedList\n\n##简介\n---\n* 它是顺序表\n* 大小可变\n* 允许null元素\n* 可LinkedList一样，不具备线程同步的安全性、但速度较快\n* 第一次定义的时候没有指定数组的长度则长度是0，在第一次添加的时候判断如果是空则追加10。\n\n##容量是如何变化的\n---\n在源码中：\n\n```\nprivate transient Object[] elementData;\n```\n用于保存对象。它会随着元素的添加而改变大小。在下面的叙述中，容量指的是elementData.length，而不是size。\n\n>size不是容量，ArrayList对象占用的内存不是由size决定的。\n>size的大小在每次调用add(E e)方法时加1。\n>如果是调用ArrayList(Collection<? extends E> c)构造方法，则size的初始值为c\n\n* 如果在初始化时，没有指定大小，则容量大小为0。\n* 当大小为0时，第一次添加元素容量大小变为10。\n* 之后每次添加时，会先确保容量是否够用\n* 如果不够用，每次增加的容量为 newCapacity = oldCapacity + (oldCapacity >> 1)；即，每次增加为原来的1.5倍。\n\n##和Vector的区别\n---\n* Vector线程安全\n* ArrayList线程不安全，速度快\n\n##和LinkedList的区别\n---\n* ArrayList是顺序表，LinkedList是链表\n* ArrayList查找，修改方便，LinkedList添加、删除方便\n\n\n##ArrayList简介\n\nArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。\n\nArrayList不是线程安全的，只能在单线程环境下，多线程环境下可以考虑用collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。\n\n ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。\n\nArrayList源码剖析\n\nArrayList的源码如下（加入了比较详细的注释）：\n\n```\npackage java.util;    \n   \npublic class ArrayList<E> extends AbstractList<E>    \n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable    \n{    \n    // 序列版本号    \n    private static final long serialVersionUID = 8683452581122892189L;    \n   \n    // ArrayList基于该数组实现，用该数组保存数据   \n    private transient Object[] elementData;    \n   \n    // ArrayList中实际数据的数量    \n    private int size;    \n   \n    // ArrayList带容量大小的构造函数。    \n    public ArrayList(int initialCapacity) {    \n        super();    \n        if (initialCapacity < 0)    \n            throw new IllegalArgumentException(\"Illegal Capacity: \"+    \n                                               initialCapacity);    \n        // 新建一个数组    \n        this.elementData = new Object[initialCapacity];    \n    }    \n   \n    // ArrayList无参构造函数。默认容量是10。    \n    public ArrayList() {    \n        this(10);    \n    }    \n   \n    // 创建一个包含collection的ArrayList    \n    public ArrayList(Collection<? extends E> c) {    \n        elementData = c.toArray();    \n        size = elementData.length;    \n        if (elementData.getClass() != Object[].class)    \n            elementData = Arrays.copyOf(elementData, size, Object[].class);    \n    }    \n   \n   \n    // 将当前容量值设为实际元素个数    \n    public void trimToSize() {    \n        modCount++;    \n        int oldCapacity = elementData.length;    \n        if (size < oldCapacity) {    \n            elementData = Arrays.copyOf(elementData, size);    \n        }    \n    }    \n   \n   \n    // 确定ArrarList的容量。    \n    // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1”    \n    public void ensureCapacity(int minCapacity) {    \n        // 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的    \n        modCount++;    \n        int oldCapacity = elementData.length;    \n        // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”    \n        if (minCapacity > oldCapacity) {    \n            Object oldData[] = elementData;    \n            int newCapacity = (oldCapacity * 3)/2 + 1;    \n            //如果还不够，则直接将minCapacity设置为当前容量  \n            if (newCapacity < minCapacity)    \n                newCapacity = minCapacity;    \n            elementData = Arrays.copyOf(elementData, newCapacity);    \n        }    \n    }    \n   \n    // 添加元素e    \n    public boolean add(E e) {    \n        // 确定ArrayList的容量大小    \n        ensureCapacity(size + 1);  // Increments modCount!!    \n        // 添加e到ArrayList中    \n        elementData[size++] = e;    \n        return true;    \n    }    \n   \n    // 返回ArrayList的实际大小    \n    public int size() {    \n        return size;    \n    }    \n   \n    // ArrayList是否包含Object(o)    \n    public boolean contains(Object o) {    \n        return indexOf(o) >= 0;    \n    }    \n   \n    //返回ArrayList是否为空    \n    public boolean isEmpty() {    \n        return size == 0;    \n    }    \n   \n    // 正向查找，返回元素的索引值    \n    public int indexOf(Object o) {    \n        if (o == null) {    \n            for (int i = 0; i < size; i++)    \n            if (elementData[i]==null)    \n                return i;    \n            } else {    \n                for (int i = 0; i < size; i++)    \n                if (o.equals(elementData[i]))    \n                    return i;    \n            }    \n            return -1;    \n        }    \n   \n        // 反向查找，返回元素的索引值    \n        public int lastIndexOf(Object o) {    \n        if (o == null) {    \n            for (int i = size-1; i >= 0; i--)    \n            if (elementData[i]==null)    \n                return i;    \n        } else {    \n            for (int i = size-1; i >= 0; i--)    \n            if (o.equals(elementData[i]))    \n                return i;    \n        }    \n        return -1;    \n    }    \n   \n    // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值    \n    public int lastIndexOf(Object o) {    \n        if (o == null) {    \n            for (int i = size-1; i >= 0; i--)    \n            if (elementData[i]==null)    \n                return i;    \n        } else {    \n            for (int i = size-1; i >= 0; i--)    \n            if (o.equals(elementData[i]))    \n                return i;    \n        }    \n        return -1;    \n    }    \n     \n   \n    // 返回ArrayList的Object数组    \n    public Object[] toArray() {    \n        return Arrays.copyOf(elementData, size);    \n    }    \n   \n    // 返回ArrayList元素组成的数组  \n    public <T> T[] toArray(T[] a) {    \n        // 若数组a的大小 < ArrayList的元素个数；    \n        // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中    \n        if (a.length < size)    \n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());    \n   \n        // 若数组a的大小 >= ArrayList的元素个数；    \n        // 则将ArrayList的全部元素都拷贝到数组a中。    \n        System.arraycopy(elementData, 0, a, 0, size);    \n        if (a.length > size)    \n            a[size] = null;    \n        return a;    \n    }    \n   \n    // 获取index位置的元素值    \n    public E get(int index) {    \n        RangeCheck(index);    \n   \n        return (E) elementData[index];    \n    }    \n   \n    // 设置index位置的值为element    \n    public E set(int index, E element) {    \n        RangeCheck(index);    \n   \n        E oldValue = (E) elementData[index];    \n        elementData[index] = element;    \n        return oldValue;    \n    }    \n   \n    // 将e添加到ArrayList中    \n    public boolean add(E e) {    \n        ensureCapacity(size + 1);  // Increments modCount!!    \n        elementData[size++] = e;    \n        return true;    \n    }    \n   \n    // 将e添加到ArrayList的指定位置    \n    public void add(int index, E element) {    \n        if (index > size || index < 0)    \n            throw new IndexOutOfBoundsException(    \n            \"Index: \"+index+\", Size: \"+size);    \n   \n        ensureCapacity(size+1);  // Increments modCount!!    \n        System.arraycopy(elementData, index, elementData, index + 1,    \n             size - index);    \n        elementData[index] = element;    \n        size++;    \n    }    \n   \n    // 删除ArrayList指定位置的元素    \n    public E remove(int index) {    \n        RangeCheck(index);    \n   \n        modCount++;    \n        E oldValue = (E) elementData[index];    \n   \n        int numMoved = size - index - 1;    \n        if (numMoved > 0)    \n            System.arraycopy(elementData, index+1, elementData, index,    \n                 numMoved);    \n        elementData[--size] = null; // Let gc do its work    \n   \n        return oldValue;    \n    }    \n   \n    // 删除ArrayList的指定元素    \n    public boolean remove(Object o) {    \n        if (o == null) {    \n                for (int index = 0; index < size; index++)    \n            if (elementData[index] == null) {    \n                fastRemove(index);    \n                return true;    \n            }    \n        } else {    \n            for (int index = 0; index < size; index++)    \n            if (o.equals(elementData[index])) {    \n                fastRemove(index);    \n                return true;    \n            }    \n        }    \n        return false;    \n    }    \n   \n   \n    // 快速删除第index个元素    \n    private void fastRemove(int index) {    \n        modCount++;    \n        int numMoved = size - index - 1;    \n        // 从\"index+1\"开始，用后面的元素替换前面的元素。    \n        if (numMoved > 0)    \n            System.arraycopy(elementData, index+1, elementData, index,    \n                             numMoved);    \n        // 将最后一个元素设为null    \n        elementData[--size] = null; // Let gc do its work    \n    }    \n   \n    // 删除元素    \n    public boolean remove(Object o) {    \n        if (o == null) {    \n            for (int index = 0; index < size; index++)    \n            if (elementData[index] == null) {    \n                fastRemove(index);    \n            return true;    \n            }    \n        } else {    \n            // 便利ArrayList，找到“元素o”，则删除，并返回true。    \n            for (int index = 0; index < size; index++)    \n            if (o.equals(elementData[index])) {    \n                fastRemove(index);    \n            return true;    \n            }    \n        }    \n        return false;    \n    }    \n   \n    // 清空ArrayList，将全部的元素设为null    \n    public void clear() {    \n        modCount++;    \n   \n        for (int i = 0; i < size; i++)    \n            elementData[i] = null;    \n   \n        size = 0;    \n    }    \n   \n    // 将集合c追加到ArrayList中    \n    public boolean addAll(Collection<? extends E> c) {    \n        Object[] a = c.toArray();    \n        int numNew = a.length;    \n        ensureCapacity(size + numNew);  // Increments modCount    \n        System.arraycopy(a, 0, elementData, size, numNew);    \n        size += numNew;    \n        return numNew != 0;    \n    }    \n   \n    // 从index位置开始，将集合c添加到ArrayList    \n    public boolean addAll(int index, Collection<? extends E> c) {    \n        if (index > size || index < 0)    \n            throw new IndexOutOfBoundsException(    \n            \"Index: \" + index + \", Size: \" + size);    \n   \n        Object[] a = c.toArray();    \n        int numNew = a.length;    \n        ensureCapacity(size + numNew);  // Increments modCount    \n   \n        int numMoved = size - index;    \n        if (numMoved > 0)    \n            System.arraycopy(elementData, index, elementData, index + numNew,    \n                 numMoved);    \n   \n        System.arraycopy(a, 0, elementData, index, numNew);    \n        size += numNew;    \n        return numNew != 0;    \n    }    \n   \n    // 删除fromIndex到toIndex之间的全部元素。    \n    protected void removeRange(int fromIndex, int toIndex) {    \n    modCount++;    \n    int numMoved = size - toIndex;    \n        System.arraycopy(elementData, toIndex, elementData, fromIndex,    \n                         numMoved);    \n   \n    // Let gc do its work    \n    int newSize = size - (toIndex-fromIndex);    \n    while (size != newSize)    \n        elementData[--size] = null;    \n    }    \n   \n    private void RangeCheck(int index) {    \n    if (index >= size)    \n        throw new IndexOutOfBoundsException(    \n        \"Index: \"+index+\", Size: \"+size);    \n    }    \n   \n   \n    // 克隆函数    \n    public Object clone() {    \n        try {    \n            ArrayList<E> v = (ArrayList<E>) super.clone();    \n            // 将当前ArrayList的全部元素拷贝到v中    \n            v.elementData = Arrays.copyOf(elementData, size);    \n            v.modCount = 0;    \n            return v;    \n        } catch (CloneNotSupportedException e) {    \n            // this shouldn\'t happen, since we are Cloneable    \n            throw new InternalError();    \n        }    \n    }    \n   \n   \n    // java.io.Serializable的写入函数    \n    // 将ArrayList的“容量，所有的元素值”都写入到输出流中    \n    private void writeObject(java.io.ObjectOutputStream s)    \n        throws java.io.IOException{    \n    // Write out element count, and any hidden stuff    \n    int expectedModCount = modCount;    \n    s.defaultWriteObject();    \n   \n        // 写入“数组的容量”    \n        s.writeInt(elementData.length);    \n   \n    // 写入“数组的每一个元素”    \n    for (int i=0; i<size; i++)    \n            s.writeObject(elementData[i]);    \n   \n    if (modCount != expectedModCount) {    \n            throw new ConcurrentModificationException();    \n        }    \n   \n    }    \n   \n   \n    // java.io.Serializable的读取函数：根据写入方式读出    \n    // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出    \n    private void readObject(java.io.ObjectInputStream s)    \n        throws java.io.IOException, ClassNotFoundException {    \n        // Read in size, and any hidden stuff    \n        s.defaultReadObject();    \n   \n        // 从输入流中读取ArrayList的“容量”    \n        int arrayLength = s.readInt();    \n        Object[] a = elementData = new Object[arrayLength];    \n   \n        // 从输入流中将“所有的元素值”读出    \n        for (int i=0; i<size; i++)    \n            a[i] = s.readObject();    \n    }    \n}  \n```\n\n##几点总结\n\n关于ArrayList的源码，给出几点比较重要的总结：\n\n1. 注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。\n2. 注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍加1，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。\n3. ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。\n\n首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：\n\n```\npublic static <T> T[] copyOf(T[] original, int newLength) {  \n    return (T[]) copyOf(original, newLength, original.getClass());  \n}  \n```\n\n很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型，其源码如下：\n\n```\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {  \n    T[] copy = ((Object)newType == (Object)Object[].class)  \n        ? (T[]) new Object[newLength]  \n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  \n    System.arraycopy(original, 0, copy, 0,  \n                     Math.min(original.length, newLength));  \n    return copy;  \n}  \n```\n\n这里可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。\n\n下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。\n4. 注意ArrayList的两个转化为静态数组的toArray方法。\n\n第一个，Object[] toArray()方法。该方法有可能会抛出java.lang.ClassCastException异常，如果直接用向下转型的方法，将整个ArrayList集合转变为指定类型的Array数组，便会抛出该异常，而如果转化为Array数组时不向下转型，而是将每个元素向下转型，则不会抛出该异常，显然对数组中的元素一个个进行向下转型，效率不高，且不太方便。\n\n第二个，<T> T[] toArray(T[] a)方法。该方法可以直接将ArrayList转换得到的Array进行整体向下转型（转型其实是在该方法的源码中实现的），且从该方法的源码中可以看出，参数a的大小不足时，内部会调用Arrays.copyOf方法，该方法内部创建一个新的数组返回，因此对该方法的常用形式如下：\n\n```\npublic static Integer[] vectorToArray2(ArrayList<Integer> v) {    \n    Integer[] newText = (Integer[])v.toArray(new Integer[0]);    \n    return newText;    \n}    \n```\n\n\n5.ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。\n\n6.在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。', '2', '0', '2017-08-04 11:59:14');
INSERT INTO `note_detail` VALUES ('103', '1', '176', '\n####线性表，链表，哈希表是常用的数据结构，在进行Java开发时，JDK已经为我们提供了一系列相应的类来实现基本的数据结构。这些类均在java.util包中。本文试图通过简单的描述，向读者阐述各个类的作用以及如何正确使用这些类。 \n\n# Collection\n***\n* 是最基本的集合接口\n* 继承的接口：Iterable\n* 子接口：List、Set、Queue等\n\n##简介\n* 一个Collection代表一组Object，即Collection的元素（Elements），一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。\n* Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。\n\n##如何遍历Collection中的每一个元素？\n* 不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素，代码如下：\n\n```\n\n	Iterator it = collection.iterator(); // 获得一个迭代子\n    while(it.hasNext())　　\n    {\n        Object obj = it.next(); // 得到下一个元素\n    }\n```\n\n## 方法\n\n**retainAll(Collection<? extends E\\> c)**：保留，交运算  \n**addAll(Collection<? extends E\\> c)**：添加，并运算  \n**removeAll(Collection<? extends E\\> c)**：移除，减运算  \n\n\n\n\n', '2', '0', '2017-08-04 11:59:49'), ('104', '1', '177', '### HashMap简介\n   HashMap是基于哈希表实现的，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。\n\nHashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。\n\nHashMap实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。\n\n###HashMap源码剖析\n\nHashMap的源码如下（加入了比较详细的注释）：\n\n```\npackage java.util;    \nimport java.io.*;    \n   \npublic class HashMap<K,V>    \n    extends AbstractMap<K,V>    \n    implements Map<K,V>, Cloneable, Serializable    \n{    \n   \n    // 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。    \n    static final int DEFAULT_INITIAL_CAPACITY = 16;    \n   \n    // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）    \n    static final int MAXIMUM_CAPACITY = 1 << 30;    \n   \n    // 默认加载因子为0.75   \n    static final float DEFAULT_LOAD_FACTOR = 0.75f;    \n   \n    // 存储数据的Entry数组，长度是2的幂。    \n    // HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表    \n    transient Entry[] table;    \n   \n    // HashMap的底层数组中已用槽的数量    \n    transient int size;    \n   \n    // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）    \n    int threshold;    \n   \n    // 加载因子实际大小    \n    final float loadFactor;    \n   \n    // HashMap被改变的次数    \n    transient volatile int modCount;    \n   \n    // 指定“容量大小”和“加载因子”的构造函数    \n    public HashMap(int initialCapacity, float loadFactor) {    \n        if (initialCapacity < 0)    \n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +    \n                                               initialCapacity);    \n        // HashMap的最大容量只能是MAXIMUM_CAPACITY    \n        if (initialCapacity > MAXIMUM_CAPACITY)    \n            initialCapacity = MAXIMUM_CAPACITY;    \n        //加载因此不能小于0  \n        if (loadFactor <= 0 || Float.isNaN(loadFactor))    \n            throw new IllegalArgumentException(\"Illegal load factor: \" +    \n                                               loadFactor);    \n   \n        // 找出“大于initialCapacity”的最小的2的幂    \n        int capacity = 1;    \n        while (capacity < initialCapacity)    \n            capacity <<= 1;    \n   \n        // 设置“加载因子”    \n        this.loadFactor = loadFactor;    \n        // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。    \n        threshold = (int)(capacity * loadFactor);    \n        // 创建Entry数组，用来保存数据    \n        table = new Entry[capacity];    \n        init();    \n    }    \n   \n   \n    // 指定“容量大小”的构造函数    \n    public HashMap(int initialCapacity) {    \n        this(initialCapacity, DEFAULT_LOAD_FACTOR);    \n    }    \n   \n    // 默认构造函数。    \n    public HashMap() {    \n        // 设置“加载因子”为默认加载因子0.75    \n        this.loadFactor = DEFAULT_LOAD_FACTOR;    \n        // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。    \n        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);    \n        // 创建Entry数组，用来保存数据    \n        table = new Entry[DEFAULT_INITIAL_CAPACITY];    \n        init();    \n    }    \n   \n    // 包含“子Map”的构造函数    \n    public HashMap(Map<? extends K, ? extends V> m) {    \n        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,    \n                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);    \n        // 将m中的全部元素逐个添加到HashMap中    \n        putAllForCreate(m);    \n    }    \n   \n    //求hash值的方法，重新计算hash值  \n    static int hash(int h) {    \n        h ^= (h >>> 20) ^ (h >>> 12);    \n        return h ^ (h >>> 7) ^ (h >>> 4);    \n    }    \n   \n    // 返回h在数组中的索引值，这里用&代替取模，旨在提升效率   \n    // h & (length-1)保证返回值的小于length    \n    static int indexFor(int h, int length) {    \n        return h & (length-1);    \n    }    \n   \n    public int size() {    \n        return size;    \n    }    \n   \n    public boolean isEmpty() {    \n        return size == 0;    \n    }    \n   \n    // 获取key对应的value    \n    public V get(Object key) {    \n        if (key == null)    \n            return getForNullKey();    \n        // 获取key的hash值    \n        int hash = hash(key.hashCode());    \n        // 在“该hash值对应的链表”上查找“键值等于key”的元素    \n        for (Entry<K,V> e = table[indexFor(hash, table.length)];    \n             e != null;    \n             e = e.next) {    \n            Object k;    \n            //判断key是否相同  \n            if (e.hash == hash && ((k = e.key) == key || key.equals(k)))    \n                return e.value;    \n        }  \n        //没找到则返回null  \n        return null;    \n    }    \n   \n    // 获取“key为null”的元素的值    \n    // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！    \n    private V getForNullKey() {    \n        for (Entry<K,V> e = table[0]; e != null; e = e.next) {    \n            if (e.key == null)    \n                return e.value;    \n        }    \n        return null;    \n    }    \n   \n    // HashMap是否包含key    \n    public boolean containsKey(Object key) {    \n        return getEntry(key) != null;    \n    }    \n   \n    // 返回“键为key”的键值对    \n    final Entry<K,V> getEntry(Object key) {    \n        // 获取哈希值    \n        // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值    \n        int hash = (key == null) ? 0 : hash(key.hashCode());    \n        // 在“该hash值对应的链表”上查找“键值等于key”的元素    \n        for (Entry<K,V> e = table[indexFor(hash, table.length)];    \n             e != null;    \n             e = e.next) {    \n            Object k;    \n            if (e.hash == hash &&    \n                ((k = e.key) == key || (key != null && key.equals(k))))    \n                return e;    \n        }    \n        return null;    \n    }    \n   \n    // 将“key-value”添加到HashMap中    \n    public V put(K key, V value) {    \n        // 若“key为null”，则将该键值对添加到table[0]中。    \n        if (key == null)    \n            return putForNullKey(value);    \n        // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。    \n        int hash = hash(key.hashCode());    \n        int i = indexFor(hash, table.length);    \n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {    \n            Object k;    \n            // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！    \n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {    \n                V oldValue = e.value;    \n                e.value = value;    \n                e.recordAccess(this);    \n                return oldValue;    \n            }    \n        }    \n   \n        // 若“该key”对应的键值对不存在，则将“key-value”添加到table中    \n        modCount++;  \n        //将key-value添加到table[i]处  \n        addEntry(hash, key, value, i);    \n        return null;    \n    }    \n   \n    // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置    \n    private V putForNullKey(V value) {    \n        for (Entry<K,V> e = table[0]; e != null; e = e.next) {    \n            if (e.key == null) {    \n                V oldValue = e.value;    \n                e.value = value;    \n                e.recordAccess(this);    \n                return oldValue;    \n            }    \n        }    \n        // 如果没有存在key为null的键值对，则直接题阿见到table[0]处!    \n        modCount++;    \n        addEntry(0, null, value, 0);    \n        return null;    \n    }    \n   \n    // 创建HashMap对应的“添加方法”，    \n    // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap    \n    // 而put()是对外提供的往HashMap中添加元素的方法。    \n    private void putForCreate(K key, V value) {    \n        int hash = (key == null) ? 0 : hash(key.hashCode());    \n        int i = indexFor(hash, table.length);    \n   \n        // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值    \n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {    \n            Object k;    \n            if (e.hash == hash &&    \n                ((k = e.key) == key || (key != null && key.equals(k)))) {    \n                e.value = value;    \n                return;    \n            }    \n        }    \n   \n        // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中    \n        createEntry(hash, key, value, i);    \n    }    \n   \n    // 将“m”中的全部元素都添加到HashMap中。    \n    // 该方法被内部的构造HashMap的方法所调用。    \n    private void putAllForCreate(Map<? extends K, ? extends V> m) {    \n        // 利用迭代器将元素逐个添加到HashMap中    \n        for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) {    \n            Map.Entry<? extends K, ? extends V> e = i.next();    \n            putForCreate(e.getKey(), e.getValue());    \n        }    \n    }    \n   \n    // 重新调整HashMap的大小，newCapacity是调整后的容量    \n    void resize(int newCapacity) {    \n        Entry[] oldTable = table;    \n        int oldCapacity = oldTable.length;   \n        //如果就容量已经达到了最大值，则不能再扩容，直接返回  \n        if (oldCapacity == MAXIMUM_CAPACITY) {    \n            threshold = Integer.MAX_VALUE;    \n            return;    \n        }    \n   \n        // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，    \n        // 然后，将“新HashMap”赋值给“旧HashMap”。    \n        Entry[] newTable = new Entry[newCapacity];    \n        transfer(newTable);    \n        table = newTable;    \n        threshold = (int)(newCapacity * loadFactor);    \n    }    \n   \n    // 将HashMap中的全部元素都添加到newTable中    \n    void transfer(Entry[] newTable) {    \n        Entry[] src = table;    \n        int newCapacity = newTable.length;    \n        for (int j = 0; j < src.length; j++) {    \n            Entry<K,V> e = src[j];    \n            if (e != null) {    \n                src[j] = null;    \n                do {    \n                    Entry<K,V> next = e.next;    \n                    int i = indexFor(e.hash, newCapacity);    \n                    e.next = newTable[i];    \n                    newTable[i] = e;    \n                    e = next;    \n                } while (e != null);    \n            }    \n        }    \n    }    \n   \n    // 将\"m\"的全部元素都添加到HashMap中    \n    public void putAll(Map<? extends K, ? extends V> m) {    \n        // 有效性判断    \n        int numKeysToBeAdded = m.size();    \n        if (numKeysToBeAdded == 0)    \n            return;    \n   \n        // 计算容量是否足够，    \n        // 若“当前阀值容量 < 需要的容量”，则将容量x2。    \n        if (numKeysToBeAdded > threshold) {    \n            int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);    \n            if (targetCapacity > MAXIMUM_CAPACITY)    \n                targetCapacity = MAXIMUM_CAPACITY;    \n            int newCapacity = table.length;    \n            while (newCapacity < targetCapacity)    \n                newCapacity <<= 1;    \n            if (newCapacity > table.length)    \n                resize(newCapacity);    \n        }    \n   \n        // 通过迭代器，将“m”中的元素逐个添加到HashMap中。    \n        for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) {    \n            Map.Entry<? extends K, ? extends V> e = i.next();    \n            put(e.getKey(), e.getValue());    \n        }    \n    }    \n   \n    // 删除“键为key”元素    \n    public V remove(Object key) {    \n        Entry<K,V> e = removeEntryForKey(key);    \n        return (e == null ? null : e.value);    \n    }    \n   \n    // 删除“键为key”的元素    \n    final Entry<K,V> removeEntryForKey(Object key) {    \n        // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算    \n        int hash = (key == null) ? 0 : hash(key.hashCode());    \n        int i = indexFor(hash, table.length);    \n        Entry<K,V> prev = table[i];    \n        Entry<K,V> e = prev;    \n   \n        // 删除链表中“键为key”的元素    \n        // 本质是“删除单向链表中的节点”    \n        while (e != null) {    \n            Entry<K,V> next = e.next;    \n            Object k;    \n            if (e.hash == hash &&    \n                ((k = e.key) == key || (key != null && key.equals(k)))) {    \n                modCount++;    \n                size--;    \n                if (prev == e)    \n                    table[i] = next;    \n                else   \n                    prev.next = next;    \n                e.recordRemoval(this);    \n                return e;    \n            }    \n            prev = e;    \n            e = next;    \n        }    \n   \n        return e;    \n    }    \n   \n    // 删除“键值对”    \n    final Entry<K,V> removeMapping(Object o) {    \n        if (!(o instanceof Map.Entry))    \n            return null;    \n   \n        Map.Entry<K,V> entry = (Map.Entry<K,V>) o;    \n        Object key = entry.getKey();    \n        int hash = (key == null) ? 0 : hash(key.hashCode());    \n        int i = indexFor(hash, table.length);    \n        Entry<K,V> prev = table[i];    \n        Entry<K,V> e = prev;    \n   \n        // 删除链表中的“键值对e”    \n        // 本质是“删除单向链表中的节点”    \n        while (e != null) {    \n            Entry<K,V> next = e.next;    \n            if (e.hash == hash && e.equals(entry)) {    \n                modCount++;    \n                size--;    \n                if (prev == e)    \n                    table[i] = next;    \n                else   \n                    prev.next = next;    \n                e.recordRemoval(this);    \n                return e;    \n            }    \n            prev = e;    \n            e = next;    \n        }    \n   \n        return e;    \n    }    \n   \n    // 清空HashMap，将所有的元素设为null    \n    public void clear() {    \n        modCount++;    \n        Entry[] tab = table;    \n        for (int i = 0; i < tab.length; i++)    \n            tab[i] = null;    \n        size = 0;    \n    }    \n   \n    // 是否包含“值为value”的元素    \n    public boolean containsValue(Object value) {    \n    // 若“value为null”，则调用containsNullValue()查找    \n    if (value == null)    \n            return containsNullValue();    \n   \n    // 若“value不为null”，则查找HashMap中是否有值为value的节点。    \n    Entry[] tab = table;    \n        for (int i = 0; i < tab.length ; i++)    \n            for (Entry e = tab[i] ; e != null ; e = e.next)    \n                if (value.equals(e.value))    \n                    return true;    \n    return false;    \n    }    \n   \n    // 是否包含null值    \n    private boolean containsNullValue() {    \n    Entry[] tab = table;    \n        for (int i = 0; i < tab.length ; i++)    \n            for (Entry e = tab[i] ; e != null ; e = e.next)    \n                if (e.value == null)    \n                    return true;    \n    return false;    \n    }    \n   \n    // 克隆一个HashMap，并返回Object对象    \n    public Object clone() {    \n        HashMap<K,V> result = null;    \n        try {    \n            result = (HashMap<K,V>)super.clone();    \n        } catch (CloneNotSupportedException e) {    \n            // assert false;    \n        }    \n        result.table = new Entry[table.length];    \n        result.entrySet = null;    \n        result.modCount = 0;    \n        result.size = 0;    \n        result.init();    \n        // 调用putAllForCreate()将全部元素添加到HashMap中    \n        result.putAllForCreate(this);    \n   \n        return result;    \n    }    \n   \n    // Entry是单向链表。    \n    // 它是 “HashMap链式存储法”对应的链表。    \n    // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数    \n    static class Entry<K,V> implements Map.Entry<K,V> {    \n        final K key;    \n        V value;    \n        // 指向下一个节点    \n        Entry<K,V> next;    \n        final int hash;    \n   \n        // 构造函数。    \n        // 输入参数包括\"哈希值(h)\", \"键(k)\", \"值(v)\", \"下一节点(n)\"    \n        Entry(int h, K k, V v, Entry<K,V> n) {    \n            value = v;    \n            next = n;    \n            key = k;    \n            hash = h;    \n        }    \n   \n        public final K getKey() {    \n            return key;    \n        }    \n   \n        public final V getValue() {    \n            return value;    \n        }    \n   \n        public final V setValue(V newValue) {    \n            V oldValue = value;    \n            value = newValue;    \n            return oldValue;    \n        }    \n   \n        // 判断两个Entry是否相等    \n        // 若两个Entry的“key”和“value”都相等，则返回true。    \n        // 否则，返回false    \n        public final boolean equals(Object o) {    \n            if (!(o instanceof Map.Entry))    \n                return false;    \n            Map.Entry e = (Map.Entry)o;    \n            Object k1 = getKey();    \n            Object k2 = e.getKey();    \n            if (k1 == k2 || (k1 != null && k1.equals(k2))) {    \n                Object v1 = getValue();    \n                Object v2 = e.getValue();    \n                if (v1 == v2 || (v1 != null && v1.equals(v2)))    \n                    return true;    \n            }    \n            return false;    \n        }    \n   \n        // 实现hashCode()    \n        public final int hashCode() {    \n            return (key==null   ? 0 : key.hashCode()) ^    \n                   (value==null ? 0 : value.hashCode());    \n        }    \n   \n        public final String toString() {    \n            return getKey() + \"=\" + getValue();    \n        }    \n   \n        // 当向HashMap中添加元素时，绘调用recordAccess()。    \n        // 这里不做任何处理    \n        void recordAccess(HashMap<K,V> m) {    \n        }    \n   \n        // 当从HashMap中删除元素时，绘调用recordRemoval()。    \n        // 这里不做任何处理    \n        void recordRemoval(HashMap<K,V> m) {    \n        }    \n    }    \n   \n    // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。    \n    void addEntry(int hash, K key, V value, int bucketIndex) {    \n        // 保存“bucketIndex”位置的值到“e”中    \n        Entry<K,V> e = table[bucketIndex];    \n        // 设置“bucketIndex”位置的元素为“新Entry”，    \n        // 设置“e”为“新Entry的下一个节点”    \n        table[bucketIndex] = new Entry<K,V>(hash, key, value, e);    \n        // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小    \n        if (size++ >= threshold)    \n            resize(2 * table.length);    \n    }    \n   \n    // 创建Entry。将“key-value”插入指定位置。    \n    void createEntry(int hash, K key, V value, int bucketIndex) {    \n        // 保存“bucketIndex”位置的值到“e”中    \n        Entry<K,V> e = table[bucketIndex];    \n        // 设置“bucketIndex”位置的元素为“新Entry”，    \n        // 设置“e”为“新Entry的下一个节点”    \n        table[bucketIndex] = new Entry<K,V>(hash, key, value, e);    \n        size++;    \n    }    \n   \n    // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。    \n    // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。    \n    private abstract class HashIterator<E> implements Iterator<E> {    \n        // 下一个元素    \n        Entry<K,V> next;    \n        // expectedModCount用于实现fast-fail机制。    \n        int expectedModCount;    \n        // 当前索引    \n        int index;    \n        // 当前元素    \n        Entry<K,V> current;    \n   \n        HashIterator() {    \n            expectedModCount = modCount;    \n            if (size > 0) { // advance to first entry    \n                Entry[] t = table;    \n                // 将next指向table中第一个不为null的元素。    \n                // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。    \n                while (index < t.length && (next = t[index++]) == null)    \n                    ;    \n            }    \n        }    \n   \n        public final boolean hasNext() {    \n            return next != null;    \n        }    \n   \n        // 获取下一个元素    \n        final Entry<K,V> nextEntry() {    \n            if (modCount != expectedModCount)    \n                throw new ConcurrentModificationException();    \n            Entry<K,V> e = next;    \n            if (e == null)    \n                throw new NoSuchElementException();    \n   \n            // 注意！！！    \n            // 一个Entry就是一个单向链表    \n            // 若该Entry的下一个节点不为空，就将next指向下一个节点;    \n            // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。    \n            if ((next = e.next) == null) {    \n                Entry[] t = table;    \n                while (index < t.length && (next = t[index++]) == null)    \n                    ;    \n            }    \n            current = e;    \n            return e;    \n        }    \n   \n        // 删除当前元素    \n        public void remove() {    \n            if (current == null)    \n                throw new IllegalStateException();    \n            if (modCount != expectedModCount)    \n                throw new ConcurrentModificationException();    \n            Object k = current.key;    \n            current = null;    \n            HashMap.this.removeEntryForKey(k);    \n            expectedModCount = modCount;    \n        }    \n   \n    }    \n   \n    // value的迭代器    \n    private final class ValueIterator extends HashIterator<V> {    \n        public V next() {    \n            return nextEntry().value;    \n        }    \n    }    \n   \n    // key的迭代器    \n    private final class KeyIterator extends HashIterator<K> {    \n        public K next() {    \n            return nextEntry().getKey();    \n        }    \n    }    \n   \n    // Entry的迭代器    \n    private final class EntryIterator extends HashIterator<Map.Entry<K,V>> {    \n        public Map.Entry<K,V> next() {    \n            return nextEntry();    \n        }    \n    }    \n   \n    // 返回一个“key迭代器”    \n    Iterator<K> newKeyIterator()   {    \n        return new KeyIterator();    \n    }    \n    // 返回一个“value迭代器”    \n    Iterator<V> newValueIterator()   {    \n        return new ValueIterator();    \n    }    \n    // 返回一个“entry迭代器”    \n    Iterator<Map.Entry<K,V>> newEntryIterator()   {    \n        return new EntryIterator();    \n    }    \n   \n    // HashMap的Entry对应的集合    \n    private transient Set<Map.Entry<K,V>> entrySet = null;    \n   \n    // 返回“key的集合”，实际上返回一个“KeySet对象”    \n    public Set<K> keySet() {    \n        Set<K> ks = keySet;    \n        return (ks != null ? ks : (keySet = new KeySet()));    \n    }    \n   \n    // Key对应的集合    \n    // KeySet继承于AbstractSet，说明该集合中没有重复的Key。    \n    private final class KeySet extends AbstractSet<K> {    \n        public Iterator<K> iterator() {    \n            return newKeyIterator();    \n        }    \n        public int size() {    \n            return size;    \n        }    \n        public boolean contains(Object o) {    \n            return containsKey(o);    \n        }    \n        public boolean remove(Object o) {    \n            return HashMap.this.removeEntryForKey(o) != null;    \n        }    \n        public void clear() {    \n            HashMap.this.clear();    \n        }    \n    }    \n   \n    // 返回“value集合”，实际上返回的是一个Values对象    \n    public Collection<V> values() {    \n        Collection<V> vs = values;    \n        return (vs != null ? vs : (values = new Values()));    \n    }    \n   \n    // “value集合”    \n    // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，    \n    // Values中的元素能够重复。因为不同的key可以指向相同的value。    \n    private final class Values extends AbstractCollection<V> {    \n        public Iterator<V> iterator() {    \n            return newValueIterator();    \n        }    \n        public int size() {    \n            return size;    \n        }    \n        public boolean contains(Object o) {    \n            return containsValue(o);    \n        }    \n        public void clear() {    \n            HashMap.this.clear();    \n        }    \n    }    \n   \n    // 返回“HashMap的Entry集合”    \n    public Set<Map.Entry<K,V>> entrySet() {    \n        return entrySet0();    \n    }    \n   \n    // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象    \n    private Set<Map.Entry<K,V>> entrySet0() {    \n        Set<Map.Entry<K,V>> es = entrySet;    \n        return es != null ? es : (entrySet = new EntrySet());    \n    }    \n   \n    // EntrySet对应的集合    \n    // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。    \n    private final class EntrySet extends AbstractSet<Map.Entry<K,V>> {    \n        public Iterator<Map.Entry<K,V>> iterator() {    \n            return newEntryIterator();    \n        }    \n        public boolean contains(Object o) {    \n            if (!(o instanceof Map.Entry))    \n                return false;    \n            Map.Entry<K,V> e = (Map.Entry<K,V>) o;    \n            Entry<K,V> candidate = getEntry(e.getKey());    \n            return candidate != null && candidate.equals(e);    \n        }    \n        public boolean remove(Object o) {    \n            return removeMapping(o) != null;    \n        }    \n        public int size() {    \n            return size;    \n        }    \n        public void clear() {    \n            HashMap.this.clear();    \n        }    \n    }    \n   \n    // java.io.Serializable的写入函数    \n    // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中    \n    private void writeObject(java.io.ObjectOutputStream s)    \n        throws IOException    \n    {    \n        Iterator<Map.Entry<K,V>> i =    \n            (size > 0) ? entrySet0().iterator() : null;    \n   \n        // Write out the threshold, loadfactor, and any hidden stuff    \n        s.defaultWriteObject();    \n   \n        // Write out number of buckets    \n        s.writeInt(table.length);    \n   \n        // Write out size (number of Mappings)    \n        s.writeInt(size);    \n   \n        // Write out keys and values (alternating)    \n        if (i != null) {    \n            while (i.hasNext()) {    \n            Map.Entry<K,V> e = i.next();    \n            s.writeObject(e.getKey());    \n            s.writeObject(e.getValue());    \n            }    \n        }    \n    }    \n   \n   \n    private static final long serialVersionUID = 362498820763181265L;    \n   \n    // java.io.Serializable的读取函数：根据写入方式读出    \n    // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出    \n    private void readObject(java.io.ObjectInputStream s)    \n         throws IOException, ClassNotFoundException    \n    {    \n        // Read in the threshold, loadfactor, and any hidden stuff    \n        s.defaultReadObject();    \n   \n        // Read in number of buckets and allocate the bucket array;    \n        int numBuckets = s.readInt();    \n        table = new Entry[numBuckets];    \n   \n        init();  // Give subclass a chance to do its thing.    \n   \n        // Read in size (number of Mappings)    \n        int size = s.readInt();    \n   \n        // Read the keys and values, and put the mappings in the HashMap    \n        for (int i=0; i<size; i++) {    \n            K key = (K) s.readObject();    \n            V value = (V) s.readObject();    \n            putForCreate(key, value);    \n        }    \n    }    \n   \n    // 返回“HashMap总的容量”    \n    int   capacity()     { return table.length; }    \n    // 返回“HashMap的加载因子”    \n    float loadFactor()   { return loadFactor;   }    \n}   \n```\n\n###几点总结\n1、首先要清楚HashMap的存储结构，如下图所示：\n\n![](http://img.blog.csdn.net/20140701191403764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnNfY29kZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。\n\n2、首先看链表中节点的数据结构：\n\n```\n// Entry是单向链表。    \n// 它是 “HashMap链式存储法”对应的链表。    \n// 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数    \nstatic class Entry<K,V> implements Map.Entry<K,V> {    \n    final K key;    \n    V value;    \n    // 指向下一个节点    \n    Entry<K,V> next;    \n    final int hash;    \n  \n    // 构造函数。    \n    // 输入参数包括\"哈希值(h)\", \"键(k)\", \"值(v)\", \"下一节点(n)\"    \n    Entry(int h, K k, V v, Entry<K,V> n) {    \n        value = v;    \n        next = n;    \n        key = k;    \n        hash = h;    \n    }    \n  \n    public final K getKey() {    \n        return key;    \n    }    \n  \n    public final V getValue() {    \n        return value;    \n    }    \n  \n    public final V setValue(V newValue) {    \n        V oldValue = value;    \n        value = newValue;    \n        return oldValue;    \n    }    \n  \n    // 判断两个Entry是否相等    \n    // 若两个Entry的“key”和“value”都相等，则返回true。    \n    // 否则，返回false    \n    public final boolean equals(Object o) {    \n        if (!(o instanceof Map.Entry))    \n            return false;    \n        Map.Entry e = (Map.Entry)o;    \n        Object k1 = getKey();    \n        Object k2 = e.getKey();    \n        if (k1 == k2 || (k1 != null && k1.equals(k2))) {    \n            Object v1 = getValue();    \n            Object v2 = e.getValue();    \n            if (v1 == v2 || (v1 != null && v1.equals(v2)))    \n                return true;    \n        }    \n        return false;    \n    }    \n  \n    // 实现hashCode()    \n    public final int hashCode() {    \n        return (key==null   ? 0 : key.hashCode()) ^    \n               (value==null ? 0 : value.hashCode());    \n    }    \n  \n    public final String toString() {    \n        return getKey() + \"=\" + getValue();    \n    }    \n  \n    // 当向HashMap中添加元素时，绘调用recordAccess()。    \n    // 这里不做任何处理    \n    void recordAccess(HashMap<K,V> m) {    \n    }    \n  \n    // 当从HashMap中删除元素时，绘调用recordRemoval()。    \n    // 这里不做任何处理    \n    void recordRemoval(HashMap<K,V> m) {    \n    }    \n}    \n```\n\n它的结构元素除了key、value、hash外，还有next，next指向下一个节点。另外，这里覆写了equals和hashCode方法来保证键值对的独一无二。\n\n3、HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。\n\n下面说下加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。\n\n另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方\n\n4、HashMap中key和value都允许为null。\n\n5、要重点分析下HashMap中用的最多的两个方法put和get。先从比较简单的get方法着手，源码如下：\n\n```\n// 获取key对应的value    \npublic V get(Object key) {    \n    if (key == null)    \n        return getForNullKey();    \n    // 获取key的hash值    \n    int hash = hash(key.hashCode());    \n    // 在“该hash值对应的链表”上查找“键值等于key”的元素    \n    for (Entry<K,V> e = table[indexFor(hash, table.length)];    \n         e != null;    \n         e = e.next) {    \n        Object k;    \n/判断key是否相同  \n        if (e.hash == hash && ((k = e.key) == key || key.equals(k)))    \n            return e.value;    \n    }  \n没找到则返回null  \n    return null;    \n}    \n  \n// 获取“key为null”的元素的值    \n// HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！    \nprivate V getForNullKey() {    \n    for (Entry<K,V> e = table[0]; e != null; e = e.next) {    \n        if (e.key == null)    \n            return e.value;    \n    }    \n    return null;    \n}    \n```\n\n首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。\n\n如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。\n\nput方法稍微复杂些，代码如下：\n\n```\n  // 将“key-value”添加到HashMap中    \n  public V put(K key, V value) {    \n      // 若“key为null”，则将该键值对添加到table[0]中。    \n      if (key == null)    \n          return putForNullKey(value);    \n      // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。    \n      int hash = hash(key.hashCode());    \n      int i = indexFor(hash, table.length);    \n      for (Entry<K,V> e = table[i]; e != null; e = e.next) {    \n          Object k;    \n          // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！    \n          if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {    \n              V oldValue = e.value;    \n              e.value = value;    \n              e.recordAccess(this);    \n              return oldValue;    \n          }    \n      }    \n  \n      // 若“该key”对应的键值对不存在，则将“key-value”添加到table中    \n      modCount++;  \n//将key-value添加到table[i]处  \n      addEntry(hash, key, value, i);    \n      return null;    \n  }   \n```\n\n 如果key为null，则将其添加到table[0]对应的链表中，putForNullKey的源码如下：\n\n```\n// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置    \nprivate V putForNullKey(V value) {    \n    for (Entry<K,V> e = table[0]; e != null; e = e.next) {    \n        if (e.key == null) {    \n            V oldValue = e.value;    \n            e.value = value;    \n            e.recordAccess(this);    \n            return oldValue;    \n        }    \n    }    \n    // 如果没有存在key为null的键值对，则直接题阿见到table[0]处!    \n    modCount++;    \n    addEntry(0, null, value, 0);    \n    return null;    \n}   \n```\n\n如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，比将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到改单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下：\n\n```\n// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。    \nvoid addEntry(int hash, K key, V value, int bucketIndex) {    \n    // 保存“bucketIndex”位置的值到“e”中    \n    Entry<K,V> e = table[bucketIndex];    \n    // 设置“bucketIndex”位置的元素为“新Entry”，    \n    // 设置“e”为“新Entry的下一个节点”    \n    table[bucketIndex] = new Entry<K,V>(hash, key, value, e);    \n    // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小    \n    if (size++ >= threshold)    \n        resize(2 * table.length);    \n}    \n```\n\n注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。\n\n两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。\n\n6、关于扩容。上面我们看到了扩容的方法，resize方法，它的源码如下：\n\n```\n// 重新调整HashMap的大小，newCapacity是调整后的单位    \nvoid resize(int newCapacity) {    \n    Entry[] oldTable = table;    \n    int oldCapacity = oldTable.length;    \n    if (oldCapacity == MAXIMUM_CAPACITY) {    \n        threshold = Integer.MAX_VALUE;    \n        return;    \n    }    \n  \n    // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，    \n    // 然后，将“新HashMap”赋值给“旧HashMap”。    \n    Entry[] newTable = new Entry[newCapacity];    \n    transfer(newTable);    \n    table = newTable;    \n    threshold = (int)(newCapacity * loadFactor);    \n}    \n```\n\n 很明显，是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。transfer方法的源码如下：\n \n```\n// 将HashMap中的全部元素都添加到newTable中    \nvoid transfer(Entry[] newTable) {    \n    Entry[] src = table;    \n    int newCapacity = newTable.length;    \n    for (int j = 0; j < src.length; j++) {    \n        Entry<K,V> e = src[j];    \n        if (e != null) {    \n            src[j] = null;    \n            do {    \n                Entry<K,V> next = e.next;    \n                int i = indexFor(e.hash, newCapacity);    \n                e.next = newTable[i];    \n                newTable[i] = e;    \n                e = next;    \n            } while (e != null);    \n        }    \n    }    \n}    \n```\n\n很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。\n\n7、注意containsKey方法和containsValue方法。前者直接可以通过key的哈希值将搜索范围定位到指定索引对应的链表，而后者要对哈希数组的每个链表进行搜索。\n\n8、我们重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。\n\n计算哈希值的方法如下：\n\n```\nstatic int hash(int h) {  \n        h ^= (h >>> 20) ^ (h >>> 12);  \n        return h ^ (h >>> 7) ^ (h >>> 4);  \n    }  \n```\n\n它只是一个数学公式，IDK这样设计对hash值的计算，自然有它的好处，至于为什么这样设计，我们这里不去追究，只要明白一点，用的位的操作使hash值的计算效率很高。\n\n由hash值找到对应索引的方法如下：\n```\nstatic int indexFor(int h, int length) {  \n        return h & (length-1);  \n    }  \n```\n\n这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。\n\n接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。', '2', '0', '2017-08-04 12:00:39'), ('105', '1', '178', '# HashMap的hashcode的作用？\n1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；\n2. 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；\n3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；\n4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。\n\n#什么时候需要重写？\n\n一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？就HashMap来说，好比HashMap就是一个大内存块，里面有很多小内存块，小内存块里面是一系列的对象，可以利用hashCode来查找小内存块hashCode%size(小内存块数量)，所以当equal相等时，hashCode必须相等，而且如果是object对象，必须重载hashCode和equal方法。\n\n[对于equal和hashcode的理解，何时需要重写](http://blog.csdn.net/qq352773277/article/details/41675407)\n\n#如何解决哈希冲突？\n\n1. 线性探查法(Linear Probing)\n2. 线性补偿探测法\n3. 随机探测\n\n[解决哈希（HASH）冲突的主要方法](http://blog.csdn.net/lightty/article/details/11191971)\n\n\n\n#查找的时候流程是如何？\n\n1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有\n例如内存中有这样的位置\n0  1  2  3  4  5  6  7  \n而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。\n但如果用hashcode那就会使效率提高很多。\n我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。\n2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。\n也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。\n那么。重写了equals()，为什么还要重写hashCode()呢？\n想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊\n\n\n总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。   \n\n于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。关于哈希算法，这里就不详细介绍。可以这样简单理解，hashCode方法实际上返回的就是对象存储位置的映像。   \n\n这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就能定位到它应该放置的存储位置。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就表示发生冲突了，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。这样一来，实际调用equals方法的次数就大大降低了，几乎只需要一两次。   \n', '2', '0', '2017-08-04 12:01:12'), ('106', '1', '179', '## Hashtable简介\n\nHashTable同样是基于哈希表实现的，同样每个元素都是key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。\n\nHashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。\n\nHashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。\n\n##Hashtable源码剖析\nHashtable的源码的很多实现都和HashMap差不多，源码如下（加入了比较详细的注释）：\n\n```\npackage java.util;    \nimport java.io.*;    \n   \npublic class Hashtable<K,V>    \n    extends Dictionary<K,V>    \n    implements Map<K,V>, Cloneable, java.io.Serializable {    \n   \n    // 保存key-value的数组。    \n    // Hashtable同样采用单链表解决冲突，每一个Entry本质上是一个单向链表    \n    private transient Entry[] table;    \n   \n    // Hashtable中键值对的数量    \n    private transient int count;    \n   \n    // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子）    \n    private int threshold;    \n   \n    // 加载因子    \n    private float loadFactor;    \n   \n    // Hashtable被改变的次数，用于fail-fast机制的实现    \n    private transient int modCount = 0;    \n   \n    // 序列版本号    \n    private static final long serialVersionUID = 1421746759512286392L;    \n   \n    // 指定“容量大小”和“加载因子”的构造函数    \n    public Hashtable(int initialCapacity, float loadFactor) {    \n        if (initialCapacity < 0)    \n            throw new IllegalArgumentException(\"Illegal Capacity: \"+    \n                                               initialCapacity);    \n        if (loadFactor <= 0 || Float.isNaN(loadFactor))    \n            throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor);    \n   \n        if (initialCapacity==0)    \n            initialCapacity = 1;    \n        this.loadFactor = loadFactor;    \n        table = new Entry[initialCapacity];    \n        threshold = (int)(initialCapacity * loadFactor);    \n    }    \n   \n    // 指定“容量大小”的构造函数    \n    public Hashtable(int initialCapacity) {    \n        this(initialCapacity, 0.75f);    \n    }    \n   \n    // 默认构造函数。    \n    public Hashtable() {    \n        // 默认构造函数，指定的容量大小是11；加载因子是0.75    \n        this(11, 0.75f);    \n    }    \n   \n    // 包含“子Map”的构造函数    \n    public Hashtable(Map<? extends K, ? extends V> t) {    \n        this(Math.max(2*t.size(), 11), 0.75f);    \n        // 将“子Map”的全部元素都添加到Hashtable中    \n        putAll(t);    \n    }    \n    \n    private int hash(Object k) {\n        if (useAltHashing) {\n            if (k.getClass() == String.class) {\n                return sun.misc.Hashing.stringHash32((String) k);\n            } else {\n                int h = hashSeed ^ k.hashCode();\n\n                // This function ensures that hashCodes that differ only by\n                // constant multiples at each bit position have a bounded\n                // number of collisions (approximately 8 at default load factor).\n                h ^= (h >>> 20) ^ (h >>> 12);\n                return h ^ (h >>> 7) ^ (h >>> 4);\n             }\n        } else  {\n            return k.hashCode();\n        }\n    }\n   \n    public synchronized int size() {    \n        return count;    \n    }    \n   \n    public synchronized boolean isEmpty() {    \n        return count == 0;    \n    }    \n   \n    // 返回“所有key”的枚举对象    \n    public synchronized Enumeration<K> keys() {    \n        return this.<K>getEnumeration(KEYS);    \n    }    \n   \n    // 返回“所有value”的枚举对象    \n    public synchronized Enumeration<V> elements() {    \n        return this.<V>getEnumeration(VALUES);    \n    }    \n   \n    // 判断Hashtable是否包含“值(value)”    \n    public synchronized boolean contains(Object value) {    \n        //注意，Hashtable中的value不能是null，    \n        // 若是null的话，抛出异常!    \n        if (value == null) {    \n            throw new NullPointerException();    \n        }    \n   \n        // 从后向前遍历table数组中的元素(Entry)    \n        // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value    \n        Entry tab[] = table;    \n        for (int i = tab.length ; i-- > 0 ;) {    \n            for (Entry<K,V> e = tab[i] ; e != null ; e = e.next) {    \n                if (e.value.equals(value)) {    \n                    return true;    \n                }    \n            }    \n        }    \n        return false;    \n    }    \n   \n    public boolean containsValue(Object value) {    \n        return contains(value);    \n    }    \n   \n    // 判断Hashtable是否包含key    \n    public synchronized boolean containsKey(Object key) {    \n        Entry tab[] = table;    \n        //计算hash值，直接用key的hashCode代替  \n        int hash = key.hashCode();      \n        // 计算在数组中的索引值   \n        int index = (hash & 0x7FFFFFFF) % tab.length;    \n        // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素    \n        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {    \n            if ((e.hash == hash) && e.key.equals(key)) {    \n                return true;    \n            }    \n        }    \n        return false;    \n    }    \n   \n    // 返回key对应的value，没有的话返回null    \n    public synchronized V get(Object key) {    \n        Entry tab[] = table;    \n        int hash = hash(key);\n        // 计算索引值，    \n        int index = (hash & 0x7FFFFFFF) % tab.length;    \n        // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素    \n        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {    \n            if ((e.hash == hash) && e.key.equals(key)) {    \n                return e.value;    \n            }    \n        }    \n        return null;    \n    }    \n   \n    // 调整Hashtable的长度，将长度变成原来的2倍+1   \n    protected void rehash() {    \n        int oldCapacity = table.length;    \n        Entry[] oldMap = table;    \n   \n        //创建新容量大小的Entry数组  \n        int newCapacity = oldCapacity * 2 + 1;    \n        Entry[] newMap = new Entry[newCapacity];    \n   \n        modCount++;    \n        threshold = (int)(newCapacity * loadFactor);    \n        table = newMap;    \n          \n        //将“旧的Hashtable”中的元素复制到“新的Hashtable”中  \n        for (int i = oldCapacity ; i-- > 0 ;) {    \n            for (Entry<K,V> old = oldMap[i] ; old != null ; ) {    \n                Entry<K,V> e = old;    \n                old = old.next;    \n                //重新计算index  \n                int index = (e.hash & 0x7FFFFFFF) % newCapacity;    \n                e.next = newMap[index];    \n                newMap[index] = e;    \n            }    \n        }    \n    }    \n   \n    // 将“key-value”添加到Hashtable中    \n    public synchronized V put(K key, V value) {    \n        // Hashtable中不能插入value为null的元素！！！    \n        if (value == null) {    \n            throw new NullPointerException();    \n        }    \n   \n        // 若“Hashtable中已存在键为key的键值对”，    \n        // 则用“新的value”替换“旧的value”    \n        Entry tab[] = table;    \n        int hash = hash(key);\n        int index = (hash & 0x7FFFFFFF) % tab.length;    \n        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {    \n            if ((e.hash == hash) && e.key.equals(key)) {    \n                V old = e.value;    \n                e.value = value;    \n                return old;    \n                }    \n        }    \n   \n        // 若“Hashtable中不存在键为key的键值对”，  \n        // 将“修改统计数”+1    \n        modCount++;    \n        //  若“Hashtable实际容量” > “阈值”(阈值=总的容量 * 加载因子)    \n        //  则调整Hashtable的大小    \n        if (count >= threshold) {  \n            rehash();    \n   \n            tab = table;    \n            index = (hash & 0x7FFFFFFF) % tab.length;    \n        }    \n   \n        //将新的key-value对插入到tab[index]处（即链表的头结点）  \n        Entry<K,V> e = tab[index];           \n        tab[index] = new Entry<K,V>(hash, key, value, e);    \n        count++;    \n        return null;    \n    }    \n   \n    // 删除Hashtable中键为key的元素    \n    public synchronized V remove(Object key) {    \n        Entry tab[] = table;    \n        int hash = hash(key);\n        int index = (hash & 0x7FFFFFFF) % tab.length;    \n          \n        //从table[index]链表中找出要删除的节点，并删除该节点。  \n        //因为是单链表，因此要保留带删节点的前一个节点，才能有效地删除节点  \n        for (Entry<K,V> e = tab[index], prev = null ; e != null ; prev = e, e = e.next) {    \n            if ((e.hash == hash) && e.key.equals(key)) {    \n                modCount++;    \n                if (prev != null) {    \n                    prev.next = e.next;    \n                } else {    \n                    tab[index] = e.next;    \n                }    \n                count--;    \n                V oldValue = e.value;    \n                e.value = null;    \n                return oldValue;    \n            }    \n        }    \n        return null;    \n    }    \n   \n    // 将“Map(t)”的中全部元素逐一添加到Hashtable中    \n    public synchronized void putAll(Map<? extends K, ? extends V> t) {    \n        for (Map.Entry<? extends K, ? extends V> e : t.entrySet())    \n            put(e.getKey(), e.getValue());    \n    }    \n   \n    // 清空Hashtable    \n    // 将Hashtable的table数组的值全部设为null    \n    public synchronized void clear() {    \n        Entry tab[] = table;    \n        modCount++;    \n        for (int index = tab.length; --index >= 0; )    \n            tab[index] = null;    \n        count = 0;    \n    }    \n   \n    // 克隆一个Hashtable，并以Object的形式返回。    \n    public synchronized Object clone() {    \n        try {    \n            Hashtable<K,V> t = (Hashtable<K,V>) super.clone();    \n            t.table = new Entry[table.length];    \n            for (int i = table.length ; i-- > 0 ; ) {    \n                t.table[i] = (table[i] != null)    \n                ? (Entry<K,V>) table[i].clone() : null;    \n            }    \n            t.keySet = null;    \n            t.entrySet = null;    \n            t.values = null;    \n            t.modCount = 0;    \n            return t;    \n        } catch (CloneNotSupportedException e) {     \n            throw new InternalError();    \n        }    \n    }    \n   \n    public synchronized String toString() {    \n        int max = size() - 1;    \n        if (max == -1)    \n            return \"{}\";    \n   \n        StringBuilder sb = new StringBuilder();    \n        Iterator<Map.Entry<K,V>> it = entrySet().iterator();    \n   \n        sb.append(\'{\');    \n        for (int i = 0; ; i++) {    \n            Map.Entry<K,V> e = it.next();    \n            K key = e.getKey();    \n            V value = e.getValue();    \n            sb.append(key   == this ? \"(this Map)\" : key.toString());    \n            sb.append(\'=\');    \n            sb.append(value == this ? \"(this Map)\" : value.toString());    \n   \n            if (i == max)    \n                return sb.append(\'}\').toString();    \n            sb.append(\", \");    \n        }    \n    }    \n   \n    // 获取Hashtable的枚举类对象    \n    // 若Hashtable的实际大小为0,则返回“空枚举类”对象；    \n    // 否则，返回正常的Enumerator的对象。   \n    private <T> Enumeration<T> getEnumeration(int type) {    \n    if (count == 0) {    \n        return (Enumeration<T>)emptyEnumerator;    \n    } else {    \n        return new Enumerator<T>(type, false);    \n    }    \n    }    \n   \n    // 获取Hashtable的迭代器    \n    // 若Hashtable的实际大小为0,则返回“空迭代器”对象；    \n    // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)    \n    private <T> Iterator<T> getIterator(int type) {    \n        if (count == 0) {    \n            return (Iterator<T>) emptyIterator;    \n        } else {    \n            return new Enumerator<T>(type, true);    \n        }    \n    }    \n   \n    // Hashtable的“key的集合”。它是一个Set，没有重复元素    \n    private transient volatile Set<K> keySet = null;    \n    // Hashtable的“key-value的集合”。它是一个Set，没有重复元素    \n    private transient volatile Set<Map.Entry<K,V>> entrySet = null;    \n    // Hashtable的“key-value的集合”。它是一个Collection，可以有重复元素    \n    private transient volatile Collection<V> values = null;    \n   \n    // 返回一个被synchronizedSet封装后的KeySet对象    \n    // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步    \n    public Set<K> keySet() {    \n        if (keySet == null)    \n            keySet = Collections.synchronizedSet(new KeySet(), this);    \n        return keySet;    \n    }    \n   \n    // Hashtable的Key的Set集合。    \n    // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。    \n    private class KeySet extends AbstractSet<K> {    \n        public Iterator<K> iterator() {    \n            return getIterator(KEYS);    \n        }    \n        public int size() {    \n            return count;    \n        }    \n        public boolean contains(Object o) {    \n            return containsKey(o);    \n        }    \n        public boolean remove(Object o) {    \n            return Hashtable.this.remove(o) != null;    \n        }    \n        public void clear() {    \n            Hashtable.this.clear();    \n        }    \n    }    \n   \n    // 返回一个被synchronizedSet封装后的EntrySet对象    \n    // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步    \n    public Set<Map.Entry<K,V>> entrySet() {    \n        if (entrySet==null)    \n            entrySet = Collections.synchronizedSet(new EntrySet(), this);    \n        return entrySet;    \n    }    \n   \n    // Hashtable的Entry的Set集合。    \n    // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。    \n    private class EntrySet extends AbstractSet<Map.Entry<K,V>> {    \n        public Iterator<Map.Entry<K,V>> iterator() {    \n            return getIterator(ENTRIES);    \n        }    \n   \n        public boolean add(Map.Entry<K,V> o) {    \n            return super.add(o);    \n        }    \n   \n        // 查找EntrySet中是否包含Object(0)    \n        // 首先，在table中找到o对应的Entry链表    \n        // 然后，查找Entry链表中是否存在Object    \n        public boolean contains(Object o) {    \n            if (!(o instanceof Map.Entry))    \n                return false;    \n            Map.Entry entry = (Map.Entry)o;    \n            Object key = entry.getKey();    \n            Entry[] tab = table;    \n            int hash = hash(key);\n            int index = (hash & 0x7FFFFFFF) % tab.length;    \n   \n            for (Entry e = tab[index]; e != null; e = e.next)    \n                if (e.hash==hash && e.equals(entry))    \n                    return true;    \n            return false;    \n        }    \n   \n        // 删除元素Object(0)    \n        // 首先，在table中找到o对应的Entry链表  \n        // 然后，删除链表中的元素Object    \n        public boolean remove(Object o) {    \n            if (!(o instanceof Map.Entry))    \n                return false;    \n            Map.Entry<K,V> entry = (Map.Entry<K,V>) o;    \n            K key = entry.getKey();    \n            Entry[] tab = table;    \n            int hash = hash(key);\n            int index = (hash & 0x7FFFFFFF) % tab.length;    \n   \n            for (Entry<K,V> e = tab[index], prev = null; e != null;    \n                 prev = e, e = e.next) {    \n                if (e.hash==hash && e.equals(entry)) {    \n                    modCount++;    \n                    if (prev != null)    \n                        prev.next = e.next;    \n                    else   \n                        tab[index] = e.next;    \n   \n                    count--;    \n                    e.value = null;    \n                    return true;    \n                }    \n            }    \n            return false;    \n        }    \n   \n        public int size() {    \n            return count;    \n        }    \n   \n        public void clear() {    \n            Hashtable.this.clear();    \n        }    \n    }    \n   \n    // 返回一个被synchronizedCollection封装后的ValueCollection对象    \n    // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步    \n    public Collection<V> values() {    \n    if (values==null)    \n        values = Collections.synchronizedCollection(new ValueCollection(),    \n                                                        this);    \n        return values;    \n    }    \n   \n    // Hashtable的value的Collection集合。    \n    // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。    \n    private class ValueCollection extends AbstractCollection<V> {    \n        public Iterator<V> iterator() {    \n        return getIterator(VALUES);    \n        }    \n        public int size() {    \n            return count;    \n        }    \n        public boolean contains(Object o) {    \n            return containsValue(o);    \n        }    \n        public void clear() {    \n            Hashtable.this.clear();    \n        }    \n    }    \n   \n    // 重新equals()函数    \n    // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等    \n    public synchronized boolean equals(Object o) {    \n        if (o == this)    \n            return true;    \n   \n        if (!(o instanceof Map))    \n            return false;    \n        Map<K,V> t = (Map<K,V>) o;    \n        if (t.size() != size())    \n            return false;    \n   \n        try {    \n            // 通过迭代器依次取出当前Hashtable的key-value键值对    \n            // 并判断该键值对，存在于Hashtable中。    \n            // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。    \n            Iterator<Map.Entry<K,V>> i = entrySet().iterator();    \n            while (i.hasNext()) {    \n                Map.Entry<K,V> e = i.next();    \n                K key = e.getKey();    \n                V value = e.getValue();    \n                if (value == null) {    \n                    if (!(t.get(key)==null && t.containsKey(key)))    \n                        return false;    \n                } else {    \n                    if (!value.equals(t.get(key)))    \n                        return false;    \n                }    \n            }    \n        } catch (ClassCastException unused)   {    \n            return false;    \n        } catch (NullPointerException unused) {    \n            return false;    \n        }    \n   \n        return true;    \n    }    \n   \n    // 计算Entry的hashCode    \n    // 若 Hashtable的实际大小为0 或者 加载因子<0，则返回0。    \n    // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。    \n    public synchronized int hashCode() {    \n        int h = 0;    \n        if (count == 0 || loadFactor < 0)    \n            return h;  // Returns zero    \n   \n        loadFactor = -loadFactor;  // Mark hashCode computation in progress    \n        Entry[] tab = table;    \n        for (int i = 0; i < tab.length; i++)    \n            for (Entry e = tab[i]; e != null; e = e.next)    \n                h += e.key.hashCode() ^ e.value.hashCode();    \n        loadFactor = -loadFactor;  // Mark hashCode computation complete    \n   \n        return h;    \n    }    \n   \n    // java.io.Serializable的写入函数    \n    // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中    \n    private synchronized void writeObject(java.io.ObjectOutputStream s)    \n        throws IOException    \n    {    \n        // Write out the length, threshold, loadfactor    \n        s.defaultWriteObject();    \n   \n        // Write out length, count of elements and then the key/value objects    \n        s.writeInt(table.length);    \n        s.writeInt(count);    \n        for (int index = table.length-1; index >= 0; index--) {    \n            Entry entry = table[index];    \n   \n            while (entry != null) {    \n            s.writeObject(entry.key);    \n            s.writeObject(entry.value);    \n            entry = entry.next;    \n            }    \n        }    \n    }    \n   \n    // java.io.Serializable的读取函数：根据写入方式读出    \n    // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出    \n    private void readObject(java.io.ObjectInputStream s)    \n         throws IOException, ClassNotFoundException    \n    {    \n        // Read in the length, threshold, and loadfactor    \n        s.defaultReadObject();    \n   \n        // Read the original length of the array and number of elements    \n        int origlength = s.readInt();    \n        int elements = s.readInt();    \n   \n        // Compute new size with a bit of room 5% to grow but    \n        // no larger than the original size.  Make the length    \n        // odd if it\'s large enough, this helps distribute the entries.    \n        // Guard against the length ending up zero, that\'s not valid.    \n        int length = (int)(elements * loadFactor) + (elements / 20) + 3;    \n        if (length > elements && (length & 1) == 0)    \n            length--;    \n        if (origlength > 0 && length > origlength)    \n            length = origlength;    \n   \n        Entry[] table = new Entry[length];    \n        count = 0;    \n   \n        // Read the number of elements and then all the key/value objects    \n        for (; elements > 0; elements--) {    \n            K key = (K)s.readObject();    \n            V value = (V)s.readObject();    \n                // synch could be eliminated for performance    \n                reconstitutionPut(table, key, value);    \n        }    \n        this.table = table;    \n    }    \n   \n    private void reconstitutionPut(Entry[] tab, K key, V value)    \n        throws StreamCorruptedException    \n    {    \n        if (value == null) {    \n            throw new java.io.StreamCorruptedException();    \n        }    \n        // Makes sure the key is not already in the hashtable.    \n        // This should not happen in deserialized version.    \n        int hash = key.hashCode();    \n        int index = (hash & 0x7FFFFFFF) % tab.length;    \n        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {    \n            if ((e.hash == hash) && e.key.equals(key)) {    \n                throw new java.io.StreamCorruptedException();    \n            }    \n        }    \n        // Creates the new entry.    \n        Entry<K,V> e = tab[index];    \n        tab[index] = new Entry<K,V>(hash, key, value, e);    \n        count++;    \n    }    \n   \n    // Hashtable的Entry节点，它本质上是一个单向链表。    \n    // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表    \n    private static class Entry<K,V> implements Map.Entry<K,V> {    \n        // 哈希值    \n        int hash;    \n        K key;    \n        V value;    \n        // 指向的下一个Entry，即链表的下一个节点    \n        Entry<K,V> next;    \n   \n        // 构造函数    \n        protected Entry(int hash, K key, V value, Entry<K,V> next) {    \n            this.hash = hash;    \n            this.key = key;    \n            this.value = value;    \n            this.next = next;    \n        }    \n   \n        protected Object clone() {    \n            return new Entry<K,V>(hash, key, value,    \n                  (next==null ? null : (Entry<K,V>) next.clone()));    \n        }    \n   \n        public K getKey() {    \n            return key;    \n        }    \n   \n        public V getValue() {    \n            return value;    \n        }    \n   \n        // 设置value。若value是null，则抛出异常。    \n        public V setValue(V value) {    \n            if (value == null)    \n                throw new NullPointerException();    \n   \n            V oldValue = this.value;    \n            this.value = value;    \n            return oldValue;    \n        }    \n   \n        // 覆盖equals()方法，判断两个Entry是否相等。    \n        // 若两个Entry的key和value都相等，则认为它们相等。    \n        public boolean equals(Object o) {    \n            if (!(o instanceof Map.Entry))    \n                return false;    \n            Map.Entry e = (Map.Entry)o;    \n   \n            return (key==null ? e.getKey()==null : key.equals(e.getKey())) &&    \n               (value==null ? e.getValue()==null : value.equals(e.getValue()));    \n        }    \n   \n        public int hashCode() {    \n            return hash ^ (value==null ? 0 : value.hashCode());    \n        }    \n   \n        public String toString() {    \n            return key.toString()+\"=\"+value.toString();    \n        }    \n    }    \n   \n    private static final int KEYS = 0;    \n    private static final int VALUES = 1;    \n    private static final int ENTRIES = 2;    \n   \n    // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。    \n    private class Enumerator<T> implements Enumeration<T>, Iterator<T> {    \n        // 指向Hashtable的table    \n        Entry[] table = Hashtable.this.table;    \n        // Hashtable的总的大小    \n        int index = table.length;    \n        Entry<K,V> entry = null;    \n        Entry<K,V> lastReturned = null;    \n        int type;    \n   \n        // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志    \n        // iterator为true，表示它是迭代器；否则，是枚举类。    \n        boolean iterator;    \n   \n        // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。    \n        protected int expectedModCount = modCount;    \n   \n        Enumerator(int type, boolean iterator) {    \n            this.type = type;    \n            this.iterator = iterator;    \n        }    \n   \n        // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。    \n        public boolean hasMoreElements() {    \n            Entry<K,V> e = entry;    \n            int i = index;    \n            Entry[] t = table;    \n            /* Use locals for faster loop iteration */   \n            while (e == null && i > 0) {    \n                e = t[--i];    \n            }    \n            entry = e;    \n            index = i;    \n            return e != null;    \n        }    \n   \n        // 获取下一个元素    \n        // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式”    \n        // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。    \n        // 然后，依次向后遍历单向链表Entry。    \n        public T nextElement() {    \n            Entry<K,V> et = entry;    \n            int i = index;    \n            Entry[] t = table;    \n            /* Use locals for faster loop iteration */   \n            while (et == null && i > 0) {    \n                et = t[--i];    \n            }    \n            entry = et;    \n            index = i;    \n            if (et != null) {    \n                Entry<K,V> e = lastReturned = entry;    \n                entry = e.next;    \n                return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);    \n            }    \n            throw new NoSuchElementException(\"Hashtable Enumerator\");    \n        }    \n   \n        // 迭代器Iterator的判断是否存在下一个元素    \n        // 实际上，它是调用的hasMoreElements()    \n        public boolean hasNext() {    \n            return hasMoreElements();    \n        }    \n   \n        // 迭代器获取下一个元素    \n        // 实际上，它是调用的nextElement()    \n        public T next() {    \n            if (modCount != expectedModCount)    \n                throw new ConcurrentModificationException();    \n            return nextElement();    \n        }    \n   \n        // 迭代器的remove()接口。    \n        // 首先，它在table数组中找出要删除元素所在的Entry，    \n        // 然后，删除单向链表Entry中的元素。    \n        public void remove() {    \n            if (!iterator)    \n                throw new UnsupportedOperationException();    \n            if (lastReturned == null)    \n                throw new IllegalStateException(\"Hashtable Enumerator\");    \n            if (modCount != expectedModCount)    \n                throw new ConcurrentModificationException();    \n   \n            synchronized(Hashtable.this) {    \n                Entry[] tab = Hashtable.this.table;    \n                int index = (lastReturned.hash & 0x7FFFFFFF) % tab.length;    \n   \n                for (Entry<K,V> e = tab[index], prev = null; e != null;    \n                     prev = e, e = e.next) {    \n                    if (e == lastReturned) {    \n                        modCount++;    \n                        expectedModCount++;    \n                        if (prev == null)    \n                            tab[index] = e.next;    \n                        else   \n                            prev.next = e.next;    \n                        count--;    \n                        lastReturned = null;    \n                        return;    \n                    }    \n                }    \n                throw new ConcurrentModificationException();    \n            }    \n        }    \n    }    \n   \n   \n    private static Enumeration emptyEnumerator = new EmptyEnumerator();    \n    private static Iterator emptyIterator = new EmptyIterator();    \n   \n    // 空枚举类    \n    // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。    \n    private static class EmptyEnumerator implements Enumeration<Object> {    \n   \n        EmptyEnumerator() {    \n        }    \n   \n        // 空枚举类的hasMoreElements() 始终返回false    \n        public boolean hasMoreElements() {    \n            return false;    \n        }    \n   \n        // 空枚举类的nextElement() 抛出异常    \n        public Object nextElement() {    \n            throw new NoSuchElementException(\"Hashtable Enumerator\");    \n        }    \n    }    \n   \n   \n    // 空迭代器    \n    // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。    \n    private static class EmptyIterator implements Iterator<Object> {    \n   \n        EmptyIterator() {    \n        }    \n   \n        public boolean hasNext() {    \n            return false;    \n        }    \n   \n        public Object next() {    \n            throw new NoSuchElementException(\"Hashtable Iterator\");    \n        }    \n   \n        public void remove() {    \n            throw new IllegalStateException(\"Hashtable Iterator\");    \n        }    \n   \n    }    \n}   \n```\n\n##几点总结\n 针对Hashtable，我们同样给出几点比较重要的总结，但要结合与HashMap的比较来总结。\n\n1. 二者的存储结构和解决冲突的方法都是相同的。\n2. HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。\n3. Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。我们来看下ContainsKey方法和ContainsValue的源码：\n\n```\n// 判断Hashtable是否包含“值(value)”    \n public synchronized boolean contains(Object value) {    \n     //注意，Hashtable中的value不能是null，    \n     // 若是null的话，抛出异常!    \n     if (value == null) {    \n         throw new NullPointerException();    \n     }    \n  \n     // 从后向前遍历table数组中的元素(Entry)    \n     // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value    \n     Entry tab[] = table;    \n     for (int i = tab.length ; i-- > 0 ;) {    \n         for (Entry<K,V> e = tab[i] ; e != null ; e = e.next) {    \n             if (e.value.equals(value)) {    \n                 return true;    \n             }    \n         }    \n     }    \n     return false;    \n }    \n  \n public boolean containsValue(Object value) {    \n     return contains(value);    \n }    \n  \n // 判断Hashtable是否包含key    \n public synchronized boolean containsKey(Object key) {    \n     Entry tab[] = table;    \n/计算hash值，直接用key的hashCode代替  \n     int hash = hash(key);\n     // 计算在数组中的索引值   \n     int index = (hash & 0x7FFFFFFF) % tab.length;    \n     // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素    \n     for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {    \n         if ((e.hash == hash) && e.key.equals(key)) {    \n             return true;    \n         }    \n     }    \n     return false;    \n }    \n```\n\n 很明显，如果value为null，会直接抛出NullPointerException异常，但源码中并没有对key是否为null判断，有点小不解！不过NullPointerException属于RuntimeException异常，是可以由JVM自动抛出的，也许对key的值在JVM中有所限制吧。\n4. Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。\n5. Hashtable和HashMap都重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&0x7FFFFFFF后，再对length取模，&0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&0x7FFFFFFF后，只有符号外改变，而后面的位都不变。', '2', '0', '2017-08-04 12:01:50');
INSERT INTO `note_detail` VALUES ('107', '1', '180', '# Java中的内存泄漏\n---\n\n1.Java内存回收机制\n\n不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。 \n\n2.Java内存泄漏引起的原因\n\n内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。\n\nJava内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：\n\n1、静态集合类引起内存泄漏：\n\n像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 \n\n例如\n\n```\n	Static Vector v = new Vector(10);\n	for (int i = 1; i<100; i++)\n	{\n		Object o = new Object();\n		v.add(o);\n		o = null;\n	}\n```\n\n在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。\n\n2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。\n\n例如：\n\n```\npublic static void main(String[] args)\n{\n	Set<Person> set = new HashSet<Person>();\n	Person p1 = new Person(\"唐僧\",\"pwd1\",25);\n	Person p2 = new Person(\"孙悟空\",\"pwd2\",26);\n	Person p3 = new Person(\"猪八戒\",\"pwd3\",27);\n	set.add(p1);\n	set.add(p2);\n	set.add(p3);\n	System.out.println(\"总共有:\"+set.size()+\" 个元素!\"); //结果：总共有:3 个元素!\n	p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变\n\n	set.remove(p3); //此时remove不掉，造成内存泄漏\n\n	set.add(p3); //重新添加，居然添加成功\n	System.out.println(\"总共有:\"+set.size()+\" 个元素!\"); //结果：总共有:4 个元素!\n	for (Person person : set)\n	{\n		System.out.println(person);\n	}\n}\n```\n\n3、监听器\n\n在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。\n\n4、各种连接 \n\n比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。\n\n5、内部类和外部模块的引用\n\n内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：\npublic void registerMsg(Object b);\n这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。\n\n6、单例模式 \n\n不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：\n\n```\nclass A{\n	public A(){\n		B.getInstance().setA(this);\n	}\n	....\n}\n//B类采用单例模式\nclass B{\n	private A a;\n	private static B instance=new B();\n	public B(){}\n	public static B getInstance(){\n		return instance;\n	}\n	public void setA(A a){\n		this.a=a;\n	}\n	//getter...\n} \n```\n\n\n显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况\n', '2', '0', '2017-08-04 12:03:49'), ('108', '1', '181', '# Java基础知识\n---\n\n##基础\n---\n**八种基本数据类型的大小，以及他们的封装类。**\n\n八种基本数据类型，int ,double ,long ,float, short,byte,character,boolean\n\n对应的封装类型是：Integer ,Double ,Long ,Float, Short,Byte,Character,Boolean\n\n---\n\n**Switch能否用string做参数？**\n\n在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。\n\n---\n\n**equals与==的区别。**\n\n[http://www.importnew.com/6804.html](http://www.importnew.com/6804.html)\n> ==与equals的主要区别是：==常用于比较原生类型，而equals()方法用于检查对象的相等性。另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。equals()方法最重要的一点是，能够根据业务要求去重写，按照自定义规则去判断两个对象是否相等。重写equals()方法的时候，要注意一下hashCode是否会因为对象的属性改变而改变，否则在使用散列集合储存该对象的时候会碰到坑！！理解equals()方法的存在是很重要的。\n\n1. 使用==比较有两种情况：\n\n        比较基础数据类型(Java中基础数据类型包括八中：short,int,long,float,double,char,byte,boolen)：这种情况下，==比较的是他们的值是否相等。\n        引用间的比较：在这种情况下，==比较的是他们在内存中的地址，也就是说，除非引用指向的是同一个new出来的对象，此时他们使用`==`去比较得到true，否则，得到false。\n2. 使用equals进行比较：\n    \n        equals追根溯源，是Object类中的一个方法，在该类中，equals的实现也仅仅只是比较两个对象的内存地址是否相等，但在一些子类中，如：String、Integer 等，该方法将被重写。\n\n3. 以`String`类为例子说明`eqauls`与`==`的区别：\n> 在开始这个例子之前，同学们需要知道JVM处理String的一些特性。*Java的虚拟机在内存中开辟出一块单独的区域，用来存储字符串对象，这块内存区域被称为字符串缓冲池。*当使用\n`String a = \"abc\"`这样的语句进行定义一个引用的时候，首先会在*字符串缓冲池*中查找是否已经相同的对象，如果存在，那么就直接将这个对象的引用返回给a，如果不存在，则需要新建一个值为\"abc\"的对象，再将新的引用返回a。`String a = new String(\"abc\");`这样的语句明确告诉JVM想要产生一个新的String对象，并且值为\"abc\"，于是就*在堆内存中的某一个小角落开辟了一个新的String对象*。\n\n    - `==`在比较引用的情况下，会去比较两个引用的内存地址是否相等。\n    ```\n        String str1 = \"abc\";\n        String str2 = \"abc\";\n        \n        System.out.println(str1 == str2);\n        System.out.println(str1.equals(str2));\n        \n        String str2 = new String(\"abc\");\n        System.out.println(str1 == str2);\n        System.out.println(str1.equals(str2));\n        \n    ```\n        以上代码将会输出\n        true\n        true\n        false\n        true\n        **第一个true：**因为在str2赋值之前，str1的赋值操作就已经在内存中创建了一个值为\"abc\"的对象了，然后str2将会与str1指向相同的地址。\n        **第二个true：**因为`String`已经重写了`equals`方法：为了方便大家阅读我贴出来，并且在注释用进行分析：\n        ```\n        public boolean equals(Object anObject) {\n        //如果比较的对象与自身内存地址相等的话\n        //就说明他两指向的是同一个对象\n        //所以此时equals的返回值跟==的结果是一样的。\n        if (this == anObject) {\n            return true;\n        }\n        //当比较的对象与自身的内存地址不相等，并且\n        //比较的对象是String类型的时候\n        //将会执行这个分支\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                //在这里循环遍历两个String中的char\n                while (n-- != 0) {\n                    //只要有一个不相等，那么就会返回false\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n        ```\n        进行以上分析之后，就不难理解第一段代码中的实例程序输出了。\n\n\n\n---\n\n**Object有哪些公用方法？**\n\n[http://www.cnblogs.com/yumo/p/4908315.html](http://www.cnblogs.com/yumo/p/4908315.html)\n\n1．clone方法\n\n保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。\n\n主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。\n\n2．getClass方法\n\nfinal方法，获得运行时类型。\n\n3．toString方法\n\n该方法用得比较多，一般子类都有覆盖。\n\n4．finalize方法\n\n该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。\n\n5．equals方法\n\n该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。\n\n6．hashCode方法\n\n该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。\n\n一般必须满足obj1.equals(obj2)==true。可以推出obj1.hashCode()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。\n\n如果不重写hashCode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。\n\n7．wait方法\n\nwait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。\n\n调用该方法后当前线程进入睡眠状态，直到以下事件发生。\n\n（1）其他线程调用了该对象的notify方法。\n\n（2）其他线程调用了该对象的notifyAll方法。\n\n（3）其他线程调用了interrupt中断该线程。\n\n（4）时间间隔到了。\n\n此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。\n\n8．notify方法\n\n该方法唤醒在该对象上等待的某个线程。\n\n9．notifyAll方法\n\n该方法唤醒在该对象上等待的所有线程。\n\n---\n\n**Java的四种引用，强弱软虚，用到的场景。**\n\nJDK1.2之前只有强引用,其他几种引用都是在JDK1.2之后引入的.\n\n* 强引用（Strong Reference）\n	最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。\n	\n* 软引用（Soft Reference）\n	用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。\n当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null\n\n* 弱引用（Weak Reference）\n	发生GC时必定回收弱引用指向的内存空间。\n和软引用加入队列的时机相同\n\n* 虚引用（Phantom Reference)\n又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。\n当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了.\n虚引用和软引用和弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有\n\n---\n\n**Hashcode的作用。**\n\n[http://c610367182.iteye.com/blog/1930676](http://c610367182.iteye.com/blog/1930676)\n\n以Java.lang.Object来理解,JVM每new一个Object,它都会将这个Object丢到一个Hash哈希表中去,这样的话,下次做Object的比较或者取这个对象的时候,它会根据对象的hashcode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。具体过程是这样: \n\n1. new Object(),JVM根据这个对象的Hashcode值,放入到对应的Hash表对应的Key上,如果不同的对象确产生了相同的hash值,也就是发生了Hash key相同导致冲突的情况,那么就在这个Hash key的地方产生一个链表,将所有产生相同hashcode的对象放到这个单链表上去,串在一起。 \n\n\n2. 比较两个对象的时候,首先根据他们的hashcode去hash表中找他的对象,当两个对象的hashcode相同,那么就是说他们这两个对象放在Hash表中的同一个key上,那么他们一定在这个key上的链表上。那么此时就只能根据Object的equal方法来比较这个对象是否equal。当两个对象的hashcode不同的话，肯定他们不能equal. \n\n---\n\n\n**String、StringBuffer与StringBuilder的区别。**\n\nJava 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBulder类表示的字符串对象可以直接进行修改。StringBuilder是JDK1.5引入的，它和StringBuffer的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。\n\n---\n\n**try catch finally，try里有return，finally还执行么？**\n\n会执行，在方法 返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是纪录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法规定不能做这样的事。\n\n---\n\n**Excption与Error区别**\n\nError表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的状况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。\n\n---\n\n**Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。**\n\n[http://www.cnblogs.com/yumo/p/4909617.html](http://www.cnblogs.com/yumo/p/4909617.html)\n\nJava异常架构图\n\n![](http://images2015.cnblogs.com/blog/679904/201510/679904-20151025210813989-921927916.jpg)\n\n\n1. Throwable \nThrowable是 Java 语言中所有错误或异常的超类。 \nThrowable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。 \nThrowable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。\n\n2. Exception \nException及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。\n\n3. RuntimeException \nRuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 \n编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既\"没有通过throws声明抛出ArithmeticException异常\"，也\"没有通过try...catch...处理该异常\"，也能通过编译。这就是我们所说的\"编译器不会检查RuntimeException异常\"！ \n如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！\n\n4. Error \n和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。 \n和RuntimeException一样， 编译器也不会检查Error。\n\nJava将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。\n\n(01) 运行时异常 \n定义 : RuntimeException及其子类都被称为运行时异常。 \n特点 : Java编译器不会检查它。 也就是说，当程序中可能出现这类异常时，倘若既\"没有通过throws声明抛出它\"，也\"没有用try-catch语句捕获它\"，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。 \n虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。 \n如果产生运行时异常，则需要通过修改代码来进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！\n\n(02) 被检查的异常 \n定义 :  Exception类本身，以及Exception的子类中除了\"运行时异常\"之外的其它子类都属于被检查异常。 \n特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。 \n被检查异常通常都是可以恢复的。\n\n(03) 错误 \n定义 : Error类及其子类。 \n特点 : 和运行时异常一样，编译器也不会对错误进行检查。 \n当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。 \n按照Java惯例，我们是不应该是实现任何新的Error子类的！\n\n对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是： 对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。\n\n---\n\n**OOM：**\n\n1. OutOfMemoryError异常\n\n	除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能，\n\n	Java Heap 溢出\n\n	一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess\n\n	java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。\n\n	出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。\n\n	如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。\n\n	如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。\n\n2. 虚拟机栈和本地方法栈溢出\n\n	如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。\n\n	如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常\n\n	这里需要注意当栈的大小越大可分配的线程数就越少。\n\n3. 运行时常量池溢出\n\n	异常信息：java.lang.OutOfMemoryError:PermGen space\n\n	如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。\n\n4. 方法区溢出\n\n	方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。\n\n	异常信息：java.lang.OutOfMemoryError:PermGen space\n\n	方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。\n\n---\n\n**Java面向对象的三个特征与含义。**\n\n继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。\n\n封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。\n\n多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。\n \n---\n\n\n**Override和Overload的含义与区别。**\n\nOverload：顾名思义，就是Over(重新)——load（加载），所以中文名称是重载。它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、类型不能相同；或者说可以改变参数、类型但是函数名字依然不变。\n\nOverride：就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。\n\n方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。\n\n---\n\n**Interface与abstract类的区别。**\n\n抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。\n\n---\n\n**Static class 与non static class的区别。**\n\n内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。\n\n---\n\n**java多态的实现原理。**\n\n[http://blog.csdn.net/zzzhangzhun/article/details/51095075](http://blog.csdn.net/zzzhangzhun/article/details/51095075)\n\n当JVM执行Java字节码时，类型信息会存储在方法区中，为了优化对象的调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。\n\n方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 \n运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。 \n方法区的内存回收目标是针对常量池的回收及对类型的卸载。\n\n方法表的构造\n\n由于java的单继承机制，一个类只能继承一个父类，而所有的类又都继承Object类，方法表中最先存放的是Object的方法，接下来是父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。\n\n由于这样的特性，使得方法表的偏移量总是固定的，例如，对于任何类来说，其方法表的equals方法的偏移量总是一个定值，所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。\n\n实例\n\n假设Class A是Class B的子类，并且A改写了B的方法的method()，那么B来说，method方法的指针指向B的method方法入口；对于A来说，A的方法表的method项指向自身的method而非父类的。\n\n流程：调用方法时，虚拟机通过对象引用得到方法区中类型信息的方法表的指针入口，查询类的方法表 ，根据实例方法的符号引用解析出该方法在方法表的偏移量，子类对象声明为父类类型时，形式上调用的是父类的方法，此时虚拟机会从实际的方法表中找到方法地址，从而定位到实际类的方法。 \n注：所有引用为父类，但方法区的类型信息中存放的是子类的信息，所以调用的是子类的方法表。\n\n---\n\n**foreach与正常for循环效率对比。**\n\n[http://904510742.iteye.com/blog/2118331](http://904510742.iteye.com/blog/2118331)\n\n直接for循环效率最高，其次是迭代器和 ForEach操作。\n作为语法糖，其实 ForEach 编译成 字节码之后，使用的是迭代器实现的，反编译后，testForEach方法如下：\n\n```\npublic static void testForEach(List list) {  \n    for (Iterator iterator = list.iterator(); iterator.hasNext();) {  \n        Object t = iterator.next();  \n        Object obj = t;  \n    }  \n}  \n```\n\n可以看到，只比迭代器遍历多了生成中间变量这一步，因为性能也略微下降了一些。\n\n---\n\n**反射机制**\n\n\n\nJAVA反射机制是在运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法; 对于任意一个对象, 都能够调用它的任意一个方法和属性; 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制.\n\n主要作用有三：\n\n运行时取得类的方法和字段的相关信息。\n\n创建某个类的新实例(.newInstance())\n\n取得字段引用直接获取和设置对象字段，无论访问修饰符是什么。\n\n用处如下：\n\n观察或操作应用程序的运行时行为。\n\n调试或测试程序，因为可以直接访问方法、构造函数和成员字段。\n\n通过名字调用不知道的方法并使用该信息来创建对象和调用方法。\n\n---\n\n**String类内部实现，能否改变String对象内容**\n\n[String源码分析](https://github.com/GeniusVJR/LearningNotes/blob/master/Part2/JavaSE/String源码分析.md)\n\n[http://blog.csdn.net/zhangjg_blog/article/details/18319521](http://blog.csdn.net/zhangjg_blog/article/details/18319521)\n\n---\n\n**try catch 块，try里有return，finally也有return，如何执行**\n\n[http://qing0991.blog.51cto.com/1640542/1387200](http://qing0991.blog.51cto.com/1640542/1387200)\n\n---\n\n**泛型的优缺点**\n\n优点：\n\n使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。\n\n泛型最常见的用途是创建集合类。\n\n缺点：\n\n在性能上不如数组快。\n\n---\n\n**泛型常用特点，List`<String>`能否转为List`<Object>`**\n\n能，但是利用类都继承自Object，所以使用是每次调用里面的函数都要通过强制转换还原回原来的类，这样既不安全，运行速度也慢。\n\n---\n\n**解析XML的几种方式的原理与特点：DOM、SAX、PULL。**\n\n[http://www.cnblogs.com/HaroldTihan/p/4316397.html](http://www.cnblogs.com/HaroldTihan/p/4316397.html)\n\n---\n\n**Java与C++对比。**\n\n[http://developer.51cto.com/art/201106/270422.htm](http://developer.51cto.com/art/201106/270422.htm)\n\n---\n\n**Java1.7与1.8新特性。**\n\n[http://blog.chinaunix.net/uid-29618857-id-4416835.html](http://blog.chinaunix.net/uid-29618857-id-4416835.html)\n\n---\n\n**JNI的使用。**\n\n[http://landerlyoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/](http://landerlyoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/)\n\n---\n\n###集合\n\n**ArrayList、LinkedList、Vector的底层实现和区别**\n\n* 从同步性来看，ArrayList和LinkedList是不同步的，而Vector是的。所以线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList、LinkedList，使我们也达到同步，但效率可能会有所降低。\n* 从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。如果你要在集合中保存大量的数据，那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。\n* ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或者删除元素那么花费的时间会呈线性增长O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置，因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList底层是由双向循环链表实现的，LinkedList在插入、删除集合中任何位置的元素所花费的时间都是一样的O(1)，但它在索引一个元素的时候比较慢，为O(i)，其中i是索引的位置，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。\n\n**HashMap和HashTable的底层实现和区别，两者和ConcurrentHashMap的区别。**\n\n[http://blog.csdn.net/xuefeng0707/article/details/40834595](http://blog.csdn.net/xuefeng0707/article/details/40834595)\n\nHashTable线程安全则是依靠方法简单粗暴的sychronized修饰，HashMap则没有相关的线程安全问题考虑。。\n\n在以前的版本貌似ConcurrentHashMap引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。\n\n通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍。\n\n---\n\n**HashMap的hashcode的作用？什么时候需要重写？如何解决哈希冲突？查找的时候流程是如何？**\n\n[从源码分析HashMap](http://blog.csdn.net/codeemperor/article/details/51351247)\n\n---\n\n**Arraylist和HashMap如何扩容？负载因子有什么作用？如何保证读写进程安全？**\n\n[http://m.blog.csdn.net/article/details?id=48956087](http://m.blog.csdn.net/article/details?id=48956087)\n\n[http://hovertree.com/h/bjaf/2jdr60li.htm](http://hovertree.com/h/bjaf/2jdr60li.htm)\n\nArrayList 本身不是线程安全的。\n所以正确的做法是去用 java.util.concurrent 里的 CopyOnWriteArrayList 或者某个同步的 Queue 类。\n\nHashMap实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须 保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问.\n\n---\n\n**TreeMap、HashMap、LinkedHashMap的底层实现区别。**\n\n[http://blog.csdn.net/lolashe/article/details/20806319](http://blog.csdn.net/lolashe/article/details/20806319)\n\n---\n\n**Collection包结构，与Collections的区别。**\n\nCollection是一个接口，它是Set、List等容器的父接口；Collections是一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。\n\n---\n\n**Set、List之间的区别是什么?**\n\n[http://developer.51cto.com/art/201309/410205_all.htm](http://developer.51cto.com/art/201309/410205_all.htm)\n\n---\n\n**Map、Set、List、Queue、Stack的特点与用法。**\n\n[http://www.cnblogs.com/yumo/p/4908718.html](http://www.cnblogs.com/yumo/p/4908718.html)\n\nCollection 是对象集合， Collection 有两个子接口 List 和 Set\n\nList 可以通过下标 (1,2..) 来取得值，值可以重复\n\n而 Set 只能通过游标来取值，并且值是不能重复的\n\nArrayList ， Vector ， LinkedList 是 List 的实现类\n\nArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的\n\nLinkedList 是线程不安全的，底层是由链表实现的   \n\n\nMap 是键值对集合\n\nHashTable 和 HashMap 是 Map 的实现类   \nHashTable 是线程安全的，不能存储 null 值   \nHashMap 不是线程安全的，可以存储 null 值  \n\nStack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。\n\nQueue接口：提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。\n', '2', '0', '2017-08-04 12:06:11'), ('109', '1', '182', '##LinkedHashMap简介\n\nLinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同。\n\nLinkedHashMap可以用来实现LRU算法（这会在下面的源码中进行分析）。\n\nLinkedHashMap同样是非线程安全的，只在单线程环境下使用。\n\n##LinkedHashMap源码剖析\n\nLinkedHashMap源码如下（加入了详细的注释）：\n\n```\npackage java.util;  \nimport java.io.*;  \n  \n  \npublic class LinkedHashMap<K,V>  \n    extends HashMap<K,V>  \n    implements Map<K,V>  \n{  \n  \n    private static final long serialVersionUID = 3801124242820219131L;  \n  \n    //双向循环链表的头结点，整个LinkedHashMap中只有一个header，  \n    //它将哈希表中所有的Entry贯穿起来，header中不保存key-value对，只保存前后节点的引用  \n    private transient Entry<K,V> header;  \n  \n    //双向链表中元素排序规则的标志位。  \n    //accessOrder为false，表示按插入顺序排序  \n    //accessOrder为true，表示按访问顺序排序  \n    private final boolean accessOrder;  \n  \n    //调用HashMap的构造方法来构造底层的数组  \n    public LinkedHashMap(int initialCapacity, float loadFactor) {  \n        super(initialCapacity, loadFactor);  \n        accessOrder = false;    //链表中的元素默认按照插入顺序排序  \n    }  \n  \n    //加载因子取默认的0.75f  \n    public LinkedHashMap(int initialCapacity) {  \n        super(initialCapacity);  \n        accessOrder = false;  \n    }  \n  \n    //加载因子取默认的0.75f，容量取默认的16  \n    public LinkedHashMap() {  \n        super();  \n        accessOrder = false;  \n    }  \n  \n    //含有子Map的构造方法，同样调用HashMap的对应的构造方法  \n    public LinkedHashMap(Map<? extends K, ? extends V> m) {  \n        super(m);  \n        accessOrder = false;  \n    }  \n  \n    //该构造方法可以指定链表中的元素排序的规则  \n    public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) {  \n        super(initialCapacity, loadFactor);  \n        this.accessOrder = accessOrder;  \n    }  \n  \n    //覆写父类的init()方法（HashMap中的init方法为空），  \n    //该方法在父类的构造方法和Clone、readObject中在插入元素前被调用，  \n    //初始化一个空的双向循环链表，头结点中不保存数据，头结点的下一个节点才开始保存数据。  \n    void init() {  \n        header = new Entry<K,V>(-1, null, null, null);  \n        header.before = header.after = header;  \n    }  \n  \n  \n    //覆写HashMap中的transfer方法，它在父类的resize方法中被调用，  \n    //扩容后，将key-value对重新映射到新的newTable中  \n    //覆写该方法的目的是为了提高复制的效率，  \n    //这里充分利用双向循环链表的特点进行迭代，不用对底层的数组进行for循环。  \n    void transfer(HashMap.Entry[] newTable) {  \n        int newCapacity = newTable.length;  \n        for (Entry<K,V> e = header.after; e != header; e = e.after) {  \n            int index = indexFor(e.hash, newCapacity);  \n            e.next = newTable[index];  \n            newTable[index] = e;  \n        }  \n    }  \n  \n  \n    //覆写HashMap中的containsValue方法，  \n    //覆写该方法的目的同样是为了提高查询的效率，  \n    //利用双向循环链表的特点进行查询，少了对数组的外层for循环  \n    public boolean containsValue(Object value) {  \n        // Overridden to take advantage of faster iterator  \n        if (value==null) {  \n            for (Entry e = header.after; e != header; e = e.after)  \n                if (e.value==null)  \n                    return true;  \n        } else {  \n            for (Entry e = header.after; e != header; e = e.after)  \n                if (value.equals(e.value))  \n                    return true;  \n        }  \n        return false;  \n    }  \n  \n  \n    //覆写HashMap中的get方法，通过getEntry方法获取Entry对象。  \n    //注意这里的recordAccess方法，  \n    //如果链表中元素的排序规则是按照插入的先后顺序排序的话，该方法什么也不做，  \n    //如果链表中元素的排序规则是按照访问的先后顺序排序的话，则将e移到链表的末尾处。  \n    public V get(Object key) {  \n        Entry<K,V> e = (Entry<K,V>)getEntry(key);  \n        if (e == null)  \n            return null;  \n        e.recordAccess(this);  \n        return e.value;  \n    }  \n  \n    //清空HashMap，并将双向链表还原为只有头结点的空链表  \n    public void clear() {  \n        super.clear();  \n        header.before = header.after = header;  \n    }  \n  \n    //Enty的数据结构，多了两个指向前后节点的引用  \n    private static class Entry<K,V> extends HashMap.Entry<K,V> {  \n        // These fields comprise the doubly linked list used for iteration.  \n        Entry<K,V> before, after;  \n  \n        //调用父类的构造方法  \n        Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {  \n            super(hash, key, value, next);  \n        }  \n  \n        //双向循环链表中，删除当前的Entry  \n        private void remove() {  \n            before.after = after;  \n            after.before = before;  \n        }  \n  \n        //双向循环立链表中，将当前的Entry插入到existingEntry的前面  \n        private void addBefore(Entry<K,V> existingEntry) {  \n            after  = existingEntry;  \n            before = existingEntry.before;  \n            before.after = this;  \n            after.before = this;  \n        }  \n  \n  \n        //覆写HashMap中的recordAccess方法（HashMap中该方法为空），  \n        //当调用父类的put方法，在发现插入的key已经存在时，会调用该方法，  \n        //调用LinkedHashmap覆写的get方法时，也会调用到该方法，  \n        //该方法提供了LRU算法的实现，它将最近使用的Entry放到双向循环链表的尾部，  \n        //accessOrder为true时，get方法会调用recordAccess方法  \n        //put方法在覆盖key-value对时也会调用recordAccess方法  \n        //它们导致Entry最近使用，因此将其移到双向链表的末尾  \n        void recordAccess(HashMap<K,V> m) {  \n            LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;  \n            //如果链表中元素按照访问顺序排序，则将当前访问的Entry移到双向循环链表的尾部，  \n            //如果是按照插入的先后顺序排序，则不做任何事情。  \n            if (lm.accessOrder) {  \n                lm.modCount++;  \n                //移除当前访问的Entry  \n                remove();  \n                //将当前访问的Entry插入到链表的尾部  \n                addBefore(lm.header);  \n            }  \n        }  \n  \n        void recordRemoval(HashMap<K,V> m) {  \n            remove();  \n        }  \n    }  \n  \n    //迭代器  \n    private abstract class LinkedHashIterator<T> implements Iterator<T> {  \n    Entry<K,V> nextEntry    = header.after;  \n    Entry<K,V> lastReturned = null;  \n  \n    /** \n     * The modCount value that the iterator believes that the backing \n     * List should have.  If this expectation is violated, the iterator \n     * has detected concurrent modification. \n     */  \n    int expectedModCount = modCount;  \n  \n    public boolean hasNext() {  \n            return nextEntry != header;  \n    }  \n  \n    public void remove() {  \n        if (lastReturned == null)  \n        throw new IllegalStateException();  \n        if (modCount != expectedModCount)  \n        throw new ConcurrentModificationException();  \n  \n            LinkedHashMap.this.remove(lastReturned.key);  \n            lastReturned = null;  \n            expectedModCount = modCount;  \n    }  \n  \n    //从head的下一个节点开始迭代  \n    Entry<K,V> nextEntry() {  \n        if (modCount != expectedModCount)  \n        throw new ConcurrentModificationException();  \n            if (nextEntry == header)  \n                throw new NoSuchElementException();  \n  \n            Entry<K,V> e = lastReturned = nextEntry;  \n            nextEntry = e.after;  \n            return e;  \n    }  \n    }  \n  \n    //key迭代器  \n    private class KeyIterator extends LinkedHashIterator<K> {  \n    public K next() { return nextEntry().getKey(); }  \n    }  \n  \n    //value迭代器  \n    private class ValueIterator extends LinkedHashIterator<V> {  \n    public V next() { return nextEntry().value; }  \n    }  \n  \n    //Entry迭代器  \n    private class EntryIterator extends LinkedHashIterator<Map.Entry<K,V>> {  \n    public Map.Entry<K,V> next() { return nextEntry(); }  \n    }  \n  \n    // These Overrides alter the behavior of superclass view iterator() methods  \n    Iterator<K> newKeyIterator()   { return new KeyIterator();   }  \n    Iterator<V> newValueIterator() { return new ValueIterator(); }  \n    Iterator<Map.Entry<K,V>> newEntryIterator() { return new EntryIterator(); }  \n  \n  \n    //覆写HashMap中的addEntry方法，LinkedHashmap并没有覆写HashMap中的put方法，  \n    //而是覆写了put方法所调用的addEntry方法和recordAccess方法，  \n    //put方法在插入的key已存在的情况下，会调用recordAccess方法，  \n    //在插入的key不存在的情况下，要调用addEntry插入新的Entry  \n    void addEntry(int hash, K key, V value, int bucketIndex) {  \n        //创建新的Entry，并插入到LinkedHashMap中  \n        createEntry(hash, key, value, bucketIndex);  \n  \n        //双向链表的第一个有效节点（header后的那个节点）为近期最少使用的节点  \n        Entry<K,V> eldest = header.after;  \n        //如果有必要，则删除掉该近期最少使用的节点，  \n        //这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。  \n        if (removeEldestEntry(eldest)) {  \n            removeEntryForKey(eldest.key);  \n        } else {  \n            //扩容到原来的2倍  \n            if (size >= threshold)  \n                resize(2 * table.length);  \n        }  \n    }  \n  \n    void createEntry(int hash, K key, V value, int bucketIndex) {  \n        //创建新的Entry，并将其插入到数组对应槽的单链表的头结点处，这点与HashMap中相同  \n        HashMap.Entry<K,V> old = table[bucketIndex];  \n        Entry<K,V> e = new Entry<K,V>(hash, key, value, old);  \n        table[bucketIndex] = e;  \n        //每次插入Entry时，都将其移到双向链表的尾部，  \n        //这便会按照Entry插入LinkedHashMap的先后顺序来迭代元素，  \n        //同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，符合LRU算法的实现  \n        e.addBefore(header);  \n        size++;  \n    }  \n  \n    //该方法是用来被覆写的，一般如果用LinkedHashmap实现LRU算法，就要覆写该方法，  \n    //比如可以将该方法覆写为如果设定的内存已满，则返回true，这样当再次向LinkedHashMap中put  \n    //Entry时，在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。  \n    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {  \n        return false;  \n    }  \n}  \n```\n##几点总结\n\n关于LinkedHashMap的源码，给出以下几点比较重要的总结：\n\n1、从源码中可以看出，LinkedHashMap中加入了一个head头结点，将所有插入到该LinkedHashMap中的Entry按照插入的先后顺序依次加入到以head为头结点的双向循环链表的尾部。\n\n![](http://img.blog.csdn.net/20140716084631981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnNfY29kZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n1、实际上就是HashMap和LinkedList两个集合类的存储结构的结合。在LinkedHashMapMap中，所有put进来的Entry都保存在如第一个图所示的哈希表中，但它又额外定义了一个以head为头结点的空的双向循环链表，每次put进来Entry，除了将其保存到对哈希表中对应的位置上外，还要将其插入到双向循环链表的尾部。\n\n2、LinkedHashMap由于继承自HashMap，因此它具有HashMap的所有特性，同样允许key和value为null。\n\n3、注意源码中的accessOrder标志位，当它false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序；当它为true时，表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同，覆盖原有的Entry的情况下调用recordAccess方法），该方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用creatEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了），否则，什么也不做。\n\n4、注意构造方法，前四个构造方法都将accessOrder设为false，说明默认是按照插入顺序排序的，而第五个构造方法可以自定义传入的accessOrder的值，因此可以指定双向循环链表中元素的排序规则，一般要用LinkedHashMap实现LRU算法，就要用该构造方法，将accessOrder置为true。\n\n5、LinkedHashMap并没有覆写HashMap中的put方法，而是覆写了put方法中调用的addEntry方法和recordAccess方法，我们回过头来再看下HashMap的put方法：\n\n```\n// 将“key-value”添加到HashMap中      \npublic V put(K key, V value) {      \n    // 若“key为null”，则将该键值对添加到table[0]中。      \n    if (key == null)      \n        return putForNullKey(value);      \n    // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。      \n    int hash = hash(key.hashCode());      \n    int i = indexFor(hash, table.length);      \n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {      \n        Object k;      \n        // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！      \n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {      \n            V oldValue = e.value;      \n            e.value = value;      \n            e.recordAccess(this);      \n            return oldValue;      \n        }      \n    }      \n  \n    // 若“该key”对应的键值对不存在，则将“key-value”添加到table中      \n    modCount++;    \n    //将key-value添加到table[i]处    \n    addEntry(hash, key, value, i);      \n    return null;      \n}      \n```\n\n当要put进来的Entry的key在哈希表中已经在存在时，会调用recordAccess方法，当该key不存在时，则会调用addEntry方法将新的Entry插入到对应槽的单链表的头部。\n\n我们先来看recordAccess方法：\n\n```\n//覆写HashMap中的recordAccess方法（HashMap中该方法为空），  \n//当调用父类的put方法，在发现插入的key已经存在时，会调用该方法，  \n//调用LinkedHashmap覆写的get方法时，也会调用到该方法，  \n//该方法提供了LRU算法的实现，它将最近使用的Entry放到双向循环链表的尾部，  \n//accessOrder为true时，get方法会调用recordAccess方法  \n//put方法在覆盖key-value对时也会调用recordAccess方法  \n//它们导致Entry最近使用，因此将其移到双向链表的末尾  \n      void recordAccess(HashMap<K,V> m) {  \n          LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;  \n    //如果链表中元素按照访问顺序排序，则将当前访问的Entry移到双向循环链表的尾部，  \n    //如果是按照插入的先后顺序排序，则不做任何事情。  \n          if (lm.accessOrder) {  \n              lm.modCount++;  \n        //移除当前访问的Entry  \n              remove();  \n        //将当前访问的Entry插入到链表的尾部  \n              addBefore(lm.header);  \n          }  \n      }  \n```\n\n该方法会判断accessOrder是否为true，如果为true，它会将当前访问的Entry（在这里指put进来的Entry）移动到双向循环链表的尾部，从而实现双向链表中的元素按照访问顺序来排序（最近访问的Entry放到链表的最后，这样多次下来，前面就是最近没有被访问的元素，在实现、LRU算法时，当双向链表中的节点数达到最大值时，将前面的元素删去即可，因为前面的元素是最近最少使用的），否则什么也不做。\n\n再来看addEntry方法：\n\n```\n//覆写HashMap中的addEntry方法，LinkedHashmap并没有覆写HashMap中的put方法，  \n//而是覆写了put方法所调用的addEntry方法和recordAccess方法，  \n//put方法在插入的key已存在的情况下，会调用recordAccess方法，  \n//在插入的key不存在的情况下，要调用addEntry插入新的Entry  \n   void addEntry(int hash, K key, V value, int bucketIndex) {  \n    //创建新的Entry，并插入到LinkedHashMap中  \n       createEntry(hash, key, value, bucketIndex);  \n  \n       //双向链表的第一个有效节点（header后的那个节点）为近期最少使用的节点  \n       Entry<K,V> eldest = header.after;  \n    //如果有必要，则删除掉该近期最少使用的节点，  \n    //这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。  \n       if (removeEldestEntry(eldest)) {  \n           removeEntryForKey(eldest.key);  \n       } else {  \n        //扩容到原来的2倍  \n           if (size >= threshold)  \n               resize(2 * table.length);  \n       }  \n   }  \n  \n   void createEntry(int hash, K key, V value, int bucketIndex) {  \n    //创建新的Entry，并将其插入到数组对应槽的单链表的头结点处，这点与HashMap中相同  \n       HashMap.Entry<K,V> old = table[bucketIndex];  \n    Entry<K,V> e = new Entry<K,V>(hash, key, value, old);  \n       table[bucketIndex] = e;  \n    //每次插入Entry时，都将其移到双向链表的尾部，  \n    //这便会按照Entry插入LinkedHashMap的先后顺序来迭代元素，  \n    //同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，符合LRU算法的实现  \n       e.addBefore(header);  \n       size++;  \n   }  \n```\n\n同样是将新的Entry插入到table中对应槽所对应单链表的头结点中，但可以看出，在createEntry中，同样把新put进来的Entry插入到了双向链表的尾部，从插入顺序的层面来说，新的Entry插入到双向链表的尾部，可以实现按照插入的先后顺序来迭代Entry，而从访问顺序的层面来说，新put进来的Entry又是最近访问的Entry，也应该将其放在双向链表的尾部。\n\n上面还有个removeEldestEntry方法，该方法如下：\n\n```\n    //该方法是用来被覆写的，一般如果用LinkedHashmap实现LRU算法，就要覆写该方法，  \n    //比如可以将该方法覆写为如果设定的内存已满，则返回true，这样当再次向LinkedHashMap中put  \n    //Entry时，在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。  \n    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {  \n        return false;  \n    }  \n}  \n```\n\n该方法默认返回false，我们一般在用LinkedHashMap实现LRU算法时，要覆写该方法，一般的实现是，当设定的内存（这里指节点个数）达到最大值时，返回true，这样put新的Entry（该Entry的key在哈希表中没有已经存在）时，就会调用removeEntryForKey方法，将最近最少使用的节点删除（head后面的那个节点，实际上是最近没有使用）。\n\n6、LinkedHashMap覆写了HashMap的get方法：\n\n```\n//覆写HashMap中的get方法，通过getEntry方法获取Entry对象。  \n//注意这里的recordAccess方法，  \n//如果链表中元素的排序规则是按照插入的先后顺序排序的话，该方法什么也不做，  \n//如果链表中元素的排序规则是按照访问的先后顺序排序的话，则将e移到链表的末尾处。  \n   public V get(Object key) {  \n       Entry<K,V> e = (Entry<K,V>)getEntry(key);  \n       if (e == null)  \n           return null;  \n       e.recordAccess(this);  \n       return e.value;  \n   }  \n```\n\n先取得Entry，如果不为null，一样调用recordAccess方法，上面已经说得很清楚，这里不在多解释了。\n\n7、最后说说LinkedHashMap是如何实现LRU的。首先，当accessOrder为true时，才会开启按访问顺序排序的模式，才能用来实现LRU算法。我们可以看到，无论是put方法还是get方法，都会导致目标Entry成为最近访问的Entry，因此便把该Entry加入到了双向链表的末尾（get方法通过调用recordAccess方法来实现，put方法在覆盖已有key的情况下，也是通过调用recordAccess方法来实现，在插入新的Entry时，则是通过createEntry中的addBefore方法来实现），这样便把最近使用了的Entry放入到了双向链表的后面，多次操作后，双向链表前面的Entry便是最近没有使用的，这样当节点个数满的时候，删除的最前面的Entry(head后面的那个Entry)便是最近最少使用的Entry。', '2', '0', '2017-08-04 13:14:18'), ('110', '1', '183', '#LinkedList<E\\>\n---\n* 是一个类\n* 实现的接口：List、Collection、Iterable、Serializable、Cloneable、Deque，Queue\n* 子类：没有子类\n\n##简介\n---\n* 它是链表\n* 它还是队列、双端队列\n* 它还可以用作堆栈\n* 和ArrayList一样，不具有线程安全性\n\n##关于添加元素\n---\n**boolean add(E e)**\n添加到链表末尾\n\n**void add(int index, E e)**\n添加到指定位置\n\n**boolean addAll(int index, Collection<? extends E> c)**\n\n**boolean addAll(Collection<? extends E> c)**\n\n\n##LinkedList简介\nLinkedList是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当作链表来操作外，它还可以当作栈，队列和双端队列来使用。\n\nLinkedList同样是非线程安全的，只在单线程下适合使用。\n\nLinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。\n\n##LinkedList源码剖析\nLinkedList的源码如下（加入了比较详细的注释）\n\n```\npackage java.util;    \n   \npublic class LinkedList<E>    \n    extends AbstractSequentialList<E>    \n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable    \n{    \n    // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。    \n    private transient Entry<E> header = new Entry<E>(null, null, null);    \n   \n    // LinkedList中元素个数    \n    private transient int size = 0;    \n   \n    // 默认构造函数：创建一个空的链表    \n    public LinkedList() {    \n        header.next = header.previous = header;    \n    }    \n   \n    // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList    \n    public LinkedList(Collection<? extends E> c) {    \n        this();    \n        addAll(c);    \n    }    \n   \n    // 获取LinkedList的第一个元素    \n    public E getFirst() {    \n        if (size==0)    \n            throw new NoSuchElementException();    \n   \n        // 链表的表头header中不包含数据。    \n        // 这里返回header所指下一个节点所包含的数据。    \n        return header.next.element;    \n    }    \n   \n    // 获取LinkedList的最后一个元素    \n    public E getLast()  {    \n        if (size==0)    \n            throw new NoSuchElementException();    \n   \n        // 由于LinkedList是双向链表；而表头header不包含数据。    \n        // 因而，这里返回表头header的前一个节点所包含的数据。    \n        return header.previous.element;    \n    }    \n   \n    // 删除LinkedList的第一个元素    \n    public E removeFirst() {    \n        return remove(header.next);    \n    }    \n   \n    // 删除LinkedList的最后一个元素    \n    public E removeLast() {    \n        return remove(header.previous);    \n    }    \n   \n    // 将元素添加到LinkedList的起始位置    \n    public void addFirst(E e) {    \n        addBefore(e, header.next);    \n    }    \n   \n    // 将元素添加到LinkedList的结束位置    \n    public void addLast(E e) {    \n        addBefore(e, header);    \n    }    \n   \n    // 判断LinkedList是否包含元素(o)    \n    public boolean contains(Object o) {    \n        return indexOf(o) != -1;    \n    }    \n   \n    // 返回LinkedList的大小    \n    public int size() {    \n        return size;    \n    }    \n   \n    // 将元素(E)添加到LinkedList中    \n    public boolean add(E e) {    \n        // 将节点(节点数据是e)添加到表头(header)之前。    \n        // 即，将节点添加到双向链表的末端。    \n        addBefore(e, header);    \n        return true;    \n    }    \n   \n    // 从LinkedList中删除元素(o)    \n    // 从链表开始查找，如存在元素(o)则删除该元素并返回true；    \n    // 否则，返回false。    \n    public boolean remove(Object o) {    \n        if (o==null) {    \n            // 若o为null的删除情况    \n            for (Entry<E> e = header.next; e != header; e = e.next) {    \n                if (e.element==null) {    \n                    remove(e);    \n                    return true;    \n                }    \n            }    \n        } else {    \n            // 若o不为null的删除情况    \n            for (Entry<E> e = header.next; e != header; e = e.next) {    \n                if (o.equals(e.element)) {    \n                    remove(e);    \n                    return true;    \n                }    \n            }    \n        }    \n        return false;    \n    }    \n   \n    // 将“集合(c)”添加到LinkedList中。    \n    // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。    \n    public boolean addAll(Collection<? extends E> c) {    \n        return addAll(size, c);    \n    }    \n   \n    // 从双向链表的index开始，将“集合(c)”添加到双向链表中。    \n    public boolean addAll(int index, Collection<? extends E> c) {    \n        if (index < 0 || index > size)    \n            throw new IndexOutOfBoundsException(\"Index: \"+index+    \n                                                \", Size: \"+size);    \n        Object[] a = c.toArray();    \n        // 获取集合的长度    \n        int numNew = a.length;    \n        if (numNew==0)    \n            return false;    \n        modCount++;    \n   \n        // 设置“当前要插入节点的后一个节点”    \n        Entry<E> successor = (index==size ? header : entry(index));    \n        // 设置“当前要插入节点的前一个节点”    \n        Entry<E> predecessor = successor.previous;    \n        // 将集合(c)全部插入双向链表中    \n        for (int i=0; i<numNew; i++) {    \n            Entry<E> e = new Entry<E>((E)a[i], successor, predecessor);    \n            predecessor.next = e;    \n            predecessor = e;    \n        }    \n        successor.previous = predecessor;    \n   \n        // 调整LinkedList的实际大小    \n        size += numNew;    \n        return true;    \n    }    \n   \n    // 清空双向链表    \n    public void clear() {    \n        Entry<E> e = header.next;    \n        // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作：    \n        // (01) 设置前一个节点为null     \n        // (02) 设置当前节点的内容为null     \n        // (03) 设置后一个节点为“新的当前节点”    \n        while (e != header) {    \n            Entry<E> next = e.next;    \n            e.next = e.previous = null;    \n            e.element = null;    \n            e = next;    \n        }    \n        header.next = header.previous = header;    \n        // 设置大小为0    \n        size = 0;    \n        modCount++;    \n    }    \n   \n    // 返回LinkedList指定位置的元素    \n    public E get(int index) {    \n        return entry(index).element;    \n    }    \n   \n    // 设置index位置对应的节点的值为element    \n    public E set(int index, E element) {    \n        Entry<E> e = entry(index);    \n        E oldVal = e.element;    \n        e.element = element;    \n        return oldVal;    \n    }    \n     \n    // 在index前添加节点，且节点的值为element    \n    public void add(int index, E element) {    \n        addBefore(element, (index==size ? header : entry(index)));    \n    }    \n   \n    // 删除index位置的节点    \n    public E remove(int index) {    \n        return remove(entry(index));    \n    }    \n   \n    // 获取双向链表中指定位置的节点    \n    private Entry<E> entry(int index) {    \n        if (index < 0 || index >= size)    \n            throw new IndexOutOfBoundsException(\"Index: \"+index+    \n                                                \", Size: \"+size);    \n        Entry<E> e = header;    \n        // 获取index处的节点。    \n        // 若index < 双向链表长度的1/2,则从前先后查找;    \n        // 否则，从后向前查找。    \n        if (index < (size >> 1)) {    \n            for (int i = 0; i <= index; i++)    \n                e = e.next;    \n        } else {    \n            for (int i = size; i > index; i--)    \n                e = e.previous;    \n        }    \n        return e;    \n    }    \n   \n    // 从前向后查找，返回“值为对象(o)的节点对应的索引”    \n    // 不存在就返回-1    \n    public int indexOf(Object o) {    \n        int index = 0;    \n        if (o==null) {    \n            for (Entry e = header.next; e != header; e = e.next) {    \n                if (e.element==null)    \n                    return index;    \n                index++;    \n            }    \n        } else {    \n            for (Entry e = header.next; e != header; e = e.next) {    \n                if (o.equals(e.element))    \n                    return index;    \n                index++;    \n            }    \n        }    \n        return -1;    \n    }    \n   \n    // 从后向前查找，返回“值为对象(o)的节点对应的索引”    \n    // 不存在就返回-1    \n    public int lastIndexOf(Object o) {    \n        int index = size;    \n        if (o==null) {    \n            for (Entry e = header.previous; e != header; e = e.previous) {    \n                index--;    \n                if (e.element==null)    \n                    return index;    \n            }    \n        } else {    \n            for (Entry e = header.previous; e != header; e = e.previous) {    \n                index--;    \n                if (o.equals(e.element))    \n                    return index;    \n            }    \n        }    \n        return -1;    \n    }    \n   \n    // 返回第一个节点    \n    // 若LinkedList的大小为0,则返回null    \n    public E peek() {    \n        if (size==0)    \n            return null;    \n        return getFirst();    \n    }    \n   \n    // 返回第一个节点    \n    // 若LinkedList的大小为0,则抛出异常    \n    public E element() {    \n        return getFirst();    \n    }    \n   \n    // 删除并返回第一个节点    \n    // 若LinkedList的大小为0,则返回null    \n    public E poll() {    \n        if (size==0)    \n            return null;    \n        return removeFirst();    \n    }    \n   \n    // 将e添加双向链表末尾    \n    public boolean offer(E e) {    \n        return add(e);    \n    }    \n   \n    // 将e添加双向链表开头    \n    public boolean offerFirst(E e) {    \n        addFirst(e);    \n        return true;    \n    }    \n   \n    // 将e添加双向链表末尾    \n    public boolean offerLast(E e) {    \n        addLast(e);    \n        return true;    \n    }    \n   \n    // 返回第一个节点    \n    // 若LinkedList的大小为0,则返回null    \n    public E peekFirst() {    \n        if (size==0)    \n            return null;    \n        return getFirst();    \n    }    \n   \n    // 返回最后一个节点    \n    // 若LinkedList的大小为0,则返回null    \n    public E peekLast() {    \n        if (size==0)    \n            return null;    \n        return getLast();    \n    }    \n   \n    // 删除并返回第一个节点    \n    // 若LinkedList的大小为0,则返回null    \n    public E pollFirst() {    \n        if (size==0)    \n            return null;    \n        return removeFirst();    \n    }    \n   \n    // 删除并返回最后一个节点    \n    // 若LinkedList的大小为0,则返回null    \n    public E pollLast() {    \n        if (size==0)    \n            return null;    \n        return removeLast();    \n    }    \n   \n    // 将e插入到双向链表开头    \n    public void push(E e) {    \n        addFirst(e);    \n    }    \n   \n    // 删除并返回第一个节点    \n    public E pop() {    \n        return removeFirst();    \n    }    \n   \n    // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点    \n    // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点    \n    public boolean removeFirstOccurrence(Object o) {    \n        return remove(o);    \n    }    \n   \n    // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点    \n    // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点    \n    public boolean removeLastOccurrence(Object o) {    \n        if (o==null) {    \n            for (Entry<E> e = header.previous; e != header; e = e.previous) {    \n                if (e.element==null) {    \n                    remove(e);    \n                    return true;    \n                }    \n            }    \n        } else {    \n            for (Entry<E> e = header.previous; e != header; e = e.previous) {    \n                if (o.equals(e.element)) {    \n                    remove(e);    \n                    return true;    \n                }    \n            }    \n        }    \n        return false;    \n    }    \n   \n    // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器)    \n    public ListIterator<E> listIterator(int index) {    \n        return new ListItr(index);    \n    }    \n   \n    // List迭代器    \n    private class ListItr implements ListIterator<E> {    \n        // 上一次返回的节点    \n        private Entry<E> lastReturned = header;    \n        // 下一个节点    \n        private Entry<E> next;    \n        // 下一个节点对应的索引值    \n        private int nextIndex;    \n        // 期望的改变计数。用来实现fail-fast机制。    \n        private int expectedModCount = modCount;    \n   \n        // 构造函数。    \n        // 从index位置开始进行迭代    \n        ListItr(int index) {    \n            // index的有效性处理    \n            if (index < 0 || index > size)    \n                throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size);    \n            // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找；    \n            // 否则，从最后一个元素往前查找。    \n            if (index < (size >> 1)) {    \n                next = header.next;    \n                for (nextIndex=0; nextIndex<index; nextIndex++)    \n                    next = next.next;    \n            } else {    \n                next = header;    \n                for (nextIndex=size; nextIndex>index; nextIndex--)    \n                    next = next.previous;    \n            }    \n        }    \n   \n        // 是否存在下一个元素    \n        public boolean hasNext() {    \n            // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。    \n            return nextIndex != size;    \n        }    \n   \n        // 获取下一个元素    \n        public E next() {    \n            checkForComodification();    \n            if (nextIndex == size)    \n                throw new NoSuchElementException();    \n   \n            lastReturned = next;    \n            // next指向链表的下一个元素    \n            next = next.next;    \n            nextIndex++;    \n            return lastReturned.element;    \n        }    \n   \n        // 是否存在上一个元素    \n        public boolean hasPrevious() {    \n            // 通过元素索引是否等于0，来判断是否达到开头。    \n            return nextIndex != 0;    \n        }    \n   \n        // 获取上一个元素    \n        public E previous() {    \n            if (nextIndex == 0)    \n            throw new NoSuchElementException();    \n   \n            // next指向链表的上一个元素    \n            lastReturned = next = next.previous;    \n            nextIndex--;    \n            checkForComodification();    \n            return lastReturned.element;    \n        }    \n   \n        // 获取下一个元素的索引    \n        public int nextIndex() {    \n            return nextIndex;    \n        }    \n   \n        // 获取上一个元素的索引    \n        public int previousIndex() {    \n            return nextIndex-1;    \n        }    \n   \n        // 删除当前元素。    \n        // 删除双向链表中的当前节点    \n        public void remove() {    \n            checkForComodification();    \n            Entry<E> lastNext = lastReturned.next;    \n            try {    \n                LinkedList.this.remove(lastReturned);    \n            } catch (NoSuchElementException e) {    \n                throw new IllegalStateException();    \n            }    \n            if (next==lastReturned)    \n                next = lastNext;    \n            else   \n                nextIndex--;    \n            lastReturned = header;    \n            expectedModCount++;    \n        }    \n   \n        // 设置当前节点为e    \n        public void set(E e) {    \n            if (lastReturned == header)    \n                throw new IllegalStateException();    \n            checkForComodification();    \n            lastReturned.element = e;    \n        }    \n   \n        // 将e添加到当前节点的前面    \n        public void add(E e) {    \n            checkForComodification();    \n            lastReturned = header;    \n            addBefore(e, next);    \n            nextIndex++;    \n            expectedModCount++;    \n        }    \n   \n        // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。    \n        final void checkForComodification() {    \n            if (modCount != expectedModCount)    \n            throw new ConcurrentModificationException();    \n        }    \n    }    \n   \n    // 双向链表的节点所对应的数据结构。    \n    // 包含3部分：上一节点，下一节点，当前节点值。    \n    private static class Entry<E> {    \n        // 当前节点所包含的值    \n        E element;    \n        // 下一个节点    \n        Entry<E> next;    \n        // 上一个节点    \n        Entry<E> previous;    \n   \n        /**   \n         * 链表节点的构造函数。   \n         * 参数说明：   \n         *   element  —— 节点所包含的数据   \n         *   next      —— 下一个节点   \n         *   previous —— 上一个节点   \n         */   \n        Entry(E element, Entry<E> next, Entry<E> previous) {    \n            this.element = element;    \n            this.next = next;    \n            this.previous = previous;    \n        }    \n    }    \n   \n    // 将节点(节点数据是e)添加到entry节点之前。    \n    private Entry<E> addBefore(E e, Entry<E> entry) {    \n        // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e    \n        Entry<E> newEntry = new Entry<E>(e, entry, entry.previous);    \n        newEntry.previous.next = newEntry;    \n        newEntry.next.previous = newEntry;    \n        // 修改LinkedList大小    \n        size++;    \n        // 修改LinkedList的修改统计数：用来实现fail-fast机制。    \n        modCount++;    \n        return newEntry;    \n    }    \n   \n    // 将节点从链表中删除    \n    private E remove(Entry<E> e) {    \n        if (e == header)    \n            throw new NoSuchElementException();    \n   \n        E result = e.element;    \n        e.previous.next = e.next;    \n        e.next.previous = e.previous;    \n        e.next = e.previous = null;    \n        e.element = null;    \n        size--;    \n        modCount++;    \n        return result;    \n    }    \n   \n    // 反向迭代器    \n    public Iterator<E> descendingIterator() {    \n        return new DescendingIterator();    \n    }    \n   \n    // 反向迭代器实现类。    \n    private class DescendingIterator implements Iterator {    \n        final ListItr itr = new ListItr(size());    \n        // 反向迭代器是否下一个元素。    \n        // 实际上是判断双向链表的当前节点是否达到开头    \n        public boolean hasNext() {    \n            return itr.hasPrevious();    \n        }    \n        // 反向迭代器获取下一个元素。    \n        // 实际上是获取双向链表的前一个节点    \n        public E next() {    \n            return itr.previous();    \n        }    \n        // 删除当前节点    \n        public void remove() {    \n            itr.remove();    \n        }    \n    }    \n   \n   \n    // 返回LinkedList的Object[]数组    \n    public Object[] toArray() {    \n    // 新建Object[]数组    \n    Object[] result = new Object[size];    \n        int i = 0;    \n        // 将链表中所有节点的数据都添加到Object[]数组中    \n        for (Entry<E> e = header.next; e != header; e = e.next)    \n            result[i++] = e.element;    \n    return result;    \n    }    \n   \n    // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型    \n    public <T> T[] toArray(T[] a) {    \n        // 若数组a的大小 < LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素)    \n        // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。    \n        if (a.length < size)    \n            a = (T[])java.lang.reflect.Array.newInstance(    \n                                a.getClass().getComponentType(), size);    \n        // 将链表中所有节点的数据都添加到数组a中    \n        int i = 0;    \n        Object[] result = a;    \n        for (Entry<E> e = header.next; e != header; e = e.next)    \n            result[i++] = e.element;    \n   \n        if (a.length > size)    \n            a[size] = null;    \n   \n        return a;    \n    }    \n   \n   \n    // 克隆函数。返回LinkedList的克隆对象。    \n    public Object clone() {    \n        LinkedList<E> clone = null;    \n        // 克隆一个LinkedList克隆对象    \n        try {    \n            clone = (LinkedList<E>) super.clone();    \n        } catch (CloneNotSupportedException e) {    \n            throw new InternalError();    \n        }    \n   \n        // 新建LinkedList表头节点    \n        clone.header = new Entry<E>(null, null, null);    \n        clone.header.next = clone.header.previous = clone.header;    \n        clone.size = 0;    \n        clone.modCount = 0;    \n   \n        // 将链表中所有节点的数据都添加到克隆对象中    \n        for (Entry<E> e = header.next; e != header; e = e.next)    \n            clone.add(e.element);    \n   \n        return clone;    \n    }    \n   \n    // java.io.Serializable的写入函数    \n    // 将LinkedList的“容量，所有的元素值”都写入到输出流中    \n    private void writeObject(java.io.ObjectOutputStream s)    \n        throws java.io.IOException {    \n        // Write out any hidden serialization magic    \n        s.defaultWriteObject();    \n   \n        // 写入“容量”    \n        s.writeInt(size);    \n   \n        // 将链表中所有节点的数据都写入到输出流中    \n        for (Entry e = header.next; e != header; e = e.next)    \n            s.writeObject(e.element);    \n    }    \n   \n    // java.io.Serializable的读取函数：根据写入方式反向读出    \n    // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出    \n    private void readObject(java.io.ObjectInputStream s)    \n        throws java.io.IOException, ClassNotFoundException {    \n        // Read in any hidden serialization magic    \n        s.defaultReadObject();    \n   \n        // 从输入流中读取“容量”    \n        int size = s.readInt();    \n   \n        // 新建链表表头节点    \n        header = new Entry<E>(null, null, null);    \n        header.next = header.previous = header;    \n   \n        // 从输入流中将“所有的元素值”并逐个添加到链表中    \n        for (int i=0; i<size; i++)    \n            addBefore((E)s.readObject(), header);    \n    }    \n   \n}   \n```\n##几点总结\n\n关于LinkedList的源码，给出几点比较重要的总结：\n\n1、从源码中很明显可以看出，LinkedList的实现是基于双向循环链表的，且头结点中不存放数据，如下图;\n\n![](http://img.blog.csdn.net/20140629153056171)\n\n2、注意两个不同的构造方法。无参构造方法直接建立一个仅包含head节点的空链表，包含Collection的构造方法，先调用无参构造方法建立一个空链表，然后将Collection中的数据加入到链表的尾部后面。\n\n3、在查找和删除某元素时，源码中都划分为该元素为null和不为null两种情况来处理，LinkedList中允许元素为null。\n\n4、LinkedList是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。\n\n 5、注意源码中的Entry<E> entry(int index)方法。该方法返回双向链表中指定位置处的节点，而链表中是没有下标索引的，要指定位置出的元素，就要遍历该链表，从源码的实现中，我们看到这里有一个加速动作。源码中先将index与长度size的一半比较，如果index<size/2，就只从位置0往后遍历到位置index处，而如果index>size/2，就只从位置size往前遍历到位置index处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。\n\n 6、注意链表类对应的数据结构Entry。如下;\n\n```\n// 双向链表的节点所对应的数据结构。    \n// 包含3部分：上一节点，下一节点，当前节点值。    \nprivate static class Entry<E> {    \n    // 当前节点所包含的值    \n    E element;    \n    // 下一个节点    \n    Entry<E> next;    \n    // 上一个节点    \n    Entry<E> previous;    \n  \n    /**   \n     * 链表节点的构造函数。   \n     * 参数说明：   \n     *   element  —— 节点所包含的数据   \n     *   next      —— 下一个节点   \n     *   previous —— 上一个节点   \n     */   \n    Entry(E element, Entry<E> next, Entry<E> previous) {    \n        this.element = element;    \n        this.next = next;    \n        this.previous = previous;    \n    }    \n}    \n```\n\n 7、LinkedList是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）。\n\n 8、要注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。', '2', '0', '2017-08-04 13:15:04'), ('111', '1', '184', '# List\n***\n* 是一个接口\n* 继承的接口：Collection\n* 间接继承的接口：Iterable\n* 实现类：ArrayList、LinkedList、Vector等\n\n##简介\n* List是有序的**Collection**\n	- 可以对每个元素的插入位置进行精准控制\n	- 可以根据索引访问元素\n* 允许重复元素\n* 有自己的迭代器 ListIterator\n* 如果元素包含自身，equals()和hashCode()不再是良定义的\n\n## 方法\n**boolean add(E e)**: 添加到末尾  \n**void add(int index, E e)**: 添加到指定位置  \n\n**E set(int index, E e)**: 设置指定位置的元素,返回一个E  \n**get(int index)**: 获得指定位置的元素  \n\n**Iterator iterator()**   \n**ListIterator listIterator()**  \n**ListIterator listIterator(int index)**  \n\n**int indexOf(E e)**  \n**int lastIndexOf(E e)**\n\n**List<E> subList(int fromIndex, int toIndex)**\n\n##子类介绍\n1. ArrayList是一个可改变大小的数组，当更多的元素加入到ArrayList中时，其大小将会动态的增长。内部的元素可以直接通过get与set方法进行访问，因为ArrayList本质上就是一个数组\n2. LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比,如果数据和运算量很小,那么对比将失去意义。\nLinkedList还实现了Queue接口，该接口比List提供了更多的方法，包括offer(),peek(),poll等\n3. Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。\nVector和ArrayList在更多元素添加进来时会请求更大的空间。Vector每次请求其大小的双倍空间，而ArrayList每次对size增长50%.\n', '2', '0', '2017-08-04 13:15:42'), ('112', '1', '185', '# Queue\n---\n* 是一个泛型接口\n* 父接口：Collection\n* 子接口：Deque\n\n##简介\n---\n* 是个队列\n* 插入、提取、检查操作都存在两种形式，一种在操作失败后返回特殊值，一种抛出异常\n\n##方法\n---\n1. boolean add(E e)和 boolean offer(E e)添加元素\n失败时，add()抛出异常，offer()返回false\n2. E element()和E peek()获取但不移除\n失败时，element抛出异常，peek()返回null\n3. E remove()和E poll()获取并移除\n失败时，remove()抛出异常，poll()返回null\n\n##子类介绍\n---\n###Deque\n* 双端队列\n* 可以实现队列。也可以用作栈\n', '2', '0', '2017-08-04 13:16:02'), ('113', '1', '186', '# Set\n---\n* 是一个泛型接口\n* 继承了接口Collection\n* 子接口：NavigableSet、SortedSet\n* 子类：EnumSet、HashSet、LinkedHashSet、TreeSet、AbstractSet等\n* 不允许重复元素\n\n两个注意点\n---\n\n```\n1. Set中的元素的类，必须有一个有效的equals方法。\n2. 对Set的构造方法，传入的Collection对象中重复的元素会只留下一个\n```', '2', '0', '2017-08-04 13:17:08'), ('114', '1', '187', '# String源码分析\n---\n\n从一段代码说起：\n\n```\npublic void stringTest(){\n    String a = \"a\"+\"b\"+1;\n    String b = \"ab1\";\n    System.out.println(a == b);\n}\n```\n\n大家猜一猜结果如何？如果你的结论是true。好吧，再来一段代码：\n\n```\npublic void stringTest(){\n    String a = new String(\"ab1\");\n    String b = \"ab1\";\n    System.out.println(a == b);\n}\n```\n\n结果如何呢？正确答案是false。\n\n让我们看看经过编译器编译后的代码如何\n\n```\n//第一段代码\npublic void stringTest() {\n    String a = \"ab1\";\n    String b = \"ab1\";\n    System.out.println(a == b);\n}\n```\n```\n//第二段代码\npublic void stringTest() {\n    String a1 = new String(\"ab1\");\n    String b = \"ab1\";\n    System.out.println(a1 == b);\n}\n```\n\n也就是说第一段代码经过了编译期优化，原因是编译器发现\"a\"+\"b\"+1和\"ab1\"的效果是一样的，都是不可变量组成。但是为什么他们的内存地址会相同呢？如果你对此还有兴趣，那就一起看看String类的一些重要源码吧。\n\n\n一 String类\n\nString类被final所修饰，也就是说String对象是不可变量，并发程序最喜欢不可变量了。String类实现了Serializable, Comparable<String>, CharSequence接口。\n\nComparable接口有compareTo(String s)方法，CharSequence接口有length()，charAt(int index)，subSequence(int start,int end)方法。\n\n\n二 String属性\n\nString类中包含一个不可变的char数组用来存放字符串，一个int型的变量hash用来存放计算后的哈希值。\n\n```\n/** The value is used for character storage. */\nprivate final char value[];\n\n/** Cache the hash code for the string */\nprivate int hash; // Default to 0\n\n/** use serialVersionUID from JDK 1.0.2 for interoperability */\nprivate static final long serialVersionUID = -6849794470754667710L;\n```\n\n三 String构造函数\n\n```\n//不含参数的构造函数，一般没什么用，因为value是不可变量\npublic String() {\n    this.value = new char[0];\n}\n\n//参数为String类型\npublic String(String original) {\n    this.value = original.value;\n    this.hash = original.hash;\n}\n\n//参数为char数组，使用java.utils包中的Arrays类复制\npublic String(char value[]) {\n    this.value = Arrays.copyOf(value, value.length);\n}\n\n//从bytes数组中的offset位置开始，将长度为length的字节，以charsetName格式编码，拷贝到value\npublic String(byte bytes[], int offset, int length, String charsetName)\n        throws UnsupportedEncodingException {\n    if (charsetName == null)\n        throw new NullPointerException(\"charsetName\");\n    checkBounds(bytes, offset, length);\n    this.value = StringCoding.decode(charsetName, bytes, offset, length);\n}\n\n//调用public String(byte bytes[], int offset, int length, String charsetName)构造函数\npublic String(byte bytes[], String charsetName)\n        throws UnsupportedEncodingException {\n    this(bytes, 0, bytes.length, charsetName);\n}\n```\n\n三 String常用方法\n\n```\nboolean equals(Object anObject)\n\npublic boolean equals(Object anObject) {\n    //如果引用的是同一个对象，返回真\n    if (this == anObject) {\n        return true;\n    }\n    //如果不是String类型的数据，返回假\n    if (anObject instanceof String) {\n        String anotherString = (String) anObject;\n        int n = value.length;\n        //如果char数组长度不相等，返回假\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            //从后往前单个字符判断，如果有不相等，返回假\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                        return false;\n                i++;\n            }\n            //每个字符都相等，返回真\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nequals方法经常用得到，它用来判断两个对象从实际意义上是否相等，String对象判断规则：\n\n内存地址相同，则为真。\n\n如果对象类型不是String类型，则为假。否则继续判断。\n\n如果对象长度不相等，则为假。否则继续判断。\n\n从后往前，判断String类中char数组value的单个字符是否相等，有不相等则为假。如果一直相等直到第一个数，则返回真。\n\n由此可以看出，如果对两个超长的字符串进行比较还是非常费时间的。\n\n```\nint compareTo(String anotherString)\n\npublic int compareTo(String anotherString) {\n    //自身对象字符串长度len1\n    int len1 = value.length;\n    //被比较对象字符串长度len2\n    int len2 = anotherString.value.length;\n    //取两个字符串长度的最小值lim\n    int lim = Math.min(len1, len2);\n    char v1[] = value;\n    char v2[] = anotherString.value;\n\n    int k = 0;\n    //从value的第一个字符开始到最小长度lim处为止，如果字符不相等，返回自身（对象不相等处字符-被比较对象不相等字符）\n    while (k < lim) {\n        char c1 = v1[k];\n        char c2 = v2[k];\n        if (c1 != c2) {\n            return c1 - c2;\n        }\n        k++;\n    }\n    //如果前面都相等，则返回（自身长度-被比较对象长度）\n    return len1 - len2;\n}\n```\n\n这个方法写的很巧妙，先从0开始判断字符大小。如果两个对象能比较字符的地方比较完了还相等，就直接返回自身长度减被比较对象长度，如果两个字符串长度相等，则返回的是0，巧妙地判断了三种情况。\n\n```\nint hashCode()\n\npublic int hashCode() {\n    int h = hash;\n    //如果hash没有被计算过，并且字符串不为空，则进行hashCode计算\n    if (h == 0 && value.length > 0) {\n        char val[] = value;\n\n        //计算过程\n        //s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n        for (int i = 0; i < value.length; i++) {\n            h = 31 * h + val[i];\n        }\n        //hash赋值\n        hash = h;\n    }\n    return h;\n}\n```\n\nString类重写了hashCode方法，Object中的hashCode方法是一个Native调用。String类的hash采用多项式计算得来，我们完全可以通过不相同的字符串得出同样的hash，所以两个String对象的hashCode相同，并不代表两个String是一样的。\n\n```\nboolean startsWith(String prefix,int toffset)\n\npublic boolean startsWith(String prefix, int toffset) {\n    char ta[] = value;\n    int to = toffset;\n    char pa[] = prefix.value;\n    int po = 0;\n    int pc = prefix.value.length;\n    // Note: toffset might be near -1>>>1.\n    //如果起始地址小于0或者（起始地址+所比较对象长度）大于自身对象长度，返回假\n    if ((toffset < 0) || (toffset > value.length - pc)) {\n        return false;\n    }\n    //从所比较对象的末尾开始比较\n    while (--pc >= 0) {\n        if (ta[to++] != pa[po++]) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic boolean startsWith(String prefix) {\n    return startsWith(prefix, 0);\n}\n\npublic boolean endsWith(String suffix) {\n    return startsWith(suffix, value.length - suffix.value.length);\n}\n```\n\n起始比较和末尾比较都是比较经常用得到的方法，例如在判断一个字符串是不是http协议的，或者初步判断一个文件是不是mp3文件，都可以采用这个方法进行比较。\n\n```\nString concat(String str)\n\npublic String concat(String str) {\n    int otherLen = str.length();\n    //如果被添加的字符串为空，返回对象本身\n    if (otherLen == 0) {\n        return this;\n    }\n    int len = value.length;\n    char buf[] = Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n}\n```\n\nconcat方法也是经常用的方法之一，它先判断被添加字符串是否为空来决定要不要创建新的对象。\n\n```\nString replace(char oldChar,char newChar)\n\npublic String replace(char oldChar, char newChar) {\n    //新旧值先对比\n    if (oldChar != newChar) {\n        int len = value.length;\n        int i = -1;\n        char[] val = value; /* avoid getfield opcode */\n\n        //找到旧值最开始出现的位置\n        while (++i < len) {\n            if (val[i] == oldChar) {\n                break;\n            }\n        }\n        //从那个位置开始，直到末尾，用新值代替出现的旧值\n        if (i < len) {\n            char buf[] = new char[len];\n            for (int j = 0; j < i; j++) {\n                buf[j] = val[j];\n            }\n            while (i < len) {\n                char c = val[i];\n                buf[i] = (c == oldChar) ? newChar : c;\n                i++;\n            }\n            return new String(buf, true);\n        }\n    }\n    return this;\n}\n```\n\n这个方法也有讨巧的地方，例如最开始先找出旧值出现的位置，这样节省了一部分对比的时间。replace(String oldStr,String newStr)方法通过正则表达式来判断。\n\n```\nString trim()\n\npublic String trim() {\n    int len = value.length;\n    int st = 0;\n    char[] val = value;    /* avoid getfield opcode */\n\n    //找到字符串前段没有空格的位置\n    while ((st < len) && (val[st] <= \' \')) {\n        st++;\n    }\n    //找到字符串末尾没有空格的位置\n    while ((st < len) && (val[len - 1] <= \' \')) {\n        len--;\n    }\n    //如果前后都没有出现空格，返回字符串本身\n    return ((st > 0) || (len < value.length)) ? substring(st, len) : this;\n}\n```\n\ntrim方法用起来也6的飞起\n\n```\nString intern()\n\npublic native String intern();\n```\n\nintern方法是Native调用，它的作用是在方法区中的常量池里通过equals方法寻找等值的对象，如果没有找到则在常量池中开辟一片空间存放字符串并返回该对应String的引用，否则直接返回常量池中已存在String对象的引用。\n\n将引言中第二段代码\n\n```\n//String a = new String(\"ab1\");\n//改为\nString a = new String(\"ab1\").intern();\n```\n\n则结果为为真，原因在于a所指向的地址来自于常量池，而b所指向的字符串常量默认会调用这个方法，所以a和b都指向了同一个地址空间。\n\n```\nint hash32()\n\nprivate transient int hash32 = 0;\nint hash32() {\n    int h = hash32;\n    if (0 == h) {\n       // harmless data race on hash32 here.\n       h = sun.misc.Hashing.murmur3_32(HASHING_SEED, value, 0, value.length);\n\n       // ensure result is not zero to avoid recalcing\n       h = (0 != h) ? h : 1;\n\n       hash32 = h;\n    }\n\n    return h;\n}\n```\n\n在JDK1.7中，Hash相关集合类在String类作key的情况下，不再使用hashCode方式离散数据，而是采用hash32方法。这个方法默认使用系统当前时间，String类地址，System类地址等作为因子计算得到hash种子，通过hash种子在经过hash得到32位的int型数值。\n\n```\npublic int length() {\n    return value.length;\n}\npublic String toString() {\n    return this;\n}\npublic boolean isEmpty() {\n    return value.length == 0;\n}\npublic char charAt(int index) {\n    if ((index < 0) || (index >= value.length)) {\n        throw new StringIndexOutOfBoundsException(index);\n    }\n    return value[index];\n}\n```\n\n以上是一些简单的常用方法。\n\n\n总结\n\nString对象是不可变类型，返回类型为String的String方法每次返回的都是新的String对象，除了某些方法的某些特定条件返回自身。\n\nString对象的三种比较方式：\n\n==内存比较：直接对比两个引用所指向的内存值，精确简洁直接明了。\n\nequals字符串值比较：比较两个引用所指对象字面值是否相等。\n\nhashCode字符串数值化比较：将字符串数值化。两个引用的hashCode相同，不保证内存一定相同，不保证字面值一定相同。\n\n\n', '2', '0', '2017-08-04 13:17:39');
INSERT INTO `note_detail` VALUES ('115', '1', '188', '## Vector简介\nVector也是基于数组实现的，是一个动态数组，其容量能自动增长。\n\nVector是JDK1.0引入了，它的很多实现方法都加入了同步语句，因此是线程安全的（其实也只是相对安全，有些时候还是要加入同步语句来保证线程的安全），可以用于多线程环境。\n\nVector没有实现Serializable接口，因此它不支持序列化，实现了Cloneable接口，能被克隆，实现了RandomAccess接口，支持快速随机访问。\n\n##Vector源码剖析\nVector的源码如下（加入了比较详细的注释）：\n\n```\npackage java.util;    \n   \npublic class Vector<E>    \n    extends AbstractList<E>    \n    implements List<E>, RandomAccess, Cloneable, java.io.Serializable    \n{    \n       \n    // 保存Vector中数据的数组    \n    protected Object[] elementData;    \n   \n    // 实际数据的数量    \n    protected int elementCount;    \n   \n    // 容量增长系数    \n    protected int capacityIncrement;    \n   \n    // Vector的序列版本号    \n    private static final long serialVersionUID = -2767605614048989439L;    \n   \n    // Vector构造函数。默认容量是10。    \n    public Vector() {    \n        this(10);    \n    }    \n   \n    // 指定Vector容量大小的构造函数    \n    public Vector(int initialCapacity) {    \n        this(initialCapacity, 0);    \n    }    \n   \n    // 指定Vector\"容量大小\"和\"增长系数\"的构造函数    \n    public Vector(int initialCapacity, int capacityIncrement) {    \n        super();    \n        if (initialCapacity < 0)    \n            throw new IllegalArgumentException(\"Illegal Capacity: \"+    \n                                               initialCapacity);    \n        // 新建一个数组，数组容量是initialCapacity    \n        this.elementData = new Object[initialCapacity];    \n        // 设置容量增长系数    \n        this.capacityIncrement = capacityIncrement;    \n    }    \n   \n    // 指定集合的Vector构造函数。    \n    public Vector(Collection<? extends E> c) {    \n        // 获取“集合(c)”的数组，并将其赋值给elementData    \n        elementData = c.toArray();    \n        // 设置数组长度    \n        elementCount = elementData.length;    \n        // c.toArray might (incorrectly) not return Object[] (see 6260652)    \n        if (elementData.getClass() != Object[].class)    \n            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);    \n    }    \n   \n    // 将数组Vector的全部元素都拷贝到数组anArray中    \n    public synchronized void copyInto(Object[] anArray) {    \n        System.arraycopy(elementData, 0, anArray, 0, elementCount);    \n    }    \n   \n    // 将当前容量值设为 =实际元素个数    \n    public synchronized void trimToSize() {    \n        modCount++;    \n        int oldCapacity = elementData.length;    \n        if (elementCount < oldCapacity) {    \n            elementData = Arrays.copyOf(elementData, elementCount);    \n        }    \n    }    \n   \n    // 确认“Vector容量”的帮助函数    \n    private void ensureCapacityHelper(int minCapacity) {    \n        int oldCapacity = elementData.length;    \n        // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。    \n        // 若 容量增量系数>0(即capacityIncrement>0)，则将容量增大当capacityIncrement    \n        // 否则，将容量增大一倍。    \n        if (minCapacity > oldCapacity) {    \n            Object[] oldData = elementData;    \n            int newCapacity = (capacityIncrement > 0) ?    \n                (oldCapacity + capacityIncrement) : (oldCapacity * 2);    \n            if (newCapacity < minCapacity) {    \n                newCapacity = minCapacity;    \n            }    \n            elementData = Arrays.copyOf(elementData, newCapacity);    \n        }    \n    }    \n   \n    // 确定Vector的容量。    \n    public synchronized void ensureCapacity(int minCapacity) {    \n        // 将Vector的改变统计数+1    \n        modCount++;    \n        ensureCapacityHelper(minCapacity);    \n    }    \n   \n    // 设置容量值为 newSize    \n    public synchronized void setSize(int newSize) {    \n        modCount++;    \n        if (newSize > elementCount) {    \n            // 若 \"newSize 大于 Vector容量\"，则调整Vector的大小。    \n            ensureCapacityHelper(newSize);    \n        } else {    \n            // 若 \"newSize 小于/等于 Vector容量\"，则将newSize位置开始的元素都设置为null    \n            for (int i = newSize ; i < elementCount ; i++) {    \n                elementData[i] = null;    \n            }    \n        }    \n        elementCount = newSize;    \n    }    \n   \n    // 返回“Vector的总的容量”    \n    public synchronized int capacity() {    \n        return elementData.length;    \n    }    \n   \n    // 返回“Vector的实际大小”，即Vector中元素个数    \n    public synchronized int size() {    \n        return elementCount;    \n    }    \n   \n    // 判断Vector是否为空    \n    public synchronized boolean isEmpty() {    \n        return elementCount == 0;    \n    }    \n   \n    // 返回“Vector中全部元素对应的Enumeration”    \n    public Enumeration<E> elements() {    \n        // 通过匿名类实现Enumeration    \n        return new Enumeration<E>() {    \n            int count = 0;    \n   \n            // 是否存在下一个元素    \n            public boolean hasMoreElements() {    \n                return count < elementCount;    \n            }    \n   \n            // 获取下一个元素    \n            public E nextElement() {    \n                synchronized (Vector.this) {    \n                    if (count < elementCount) {    \n                        return (E)elementData[count++];    \n                    }    \n                }    \n                throw new NoSuchElementException(\"Vector Enumeration\");    \n            }    \n        };    \n    }    \n   \n    // 返回Vector中是否包含对象(o)    \n    public boolean contains(Object o) {    \n        return indexOf(o, 0) >= 0;    \n    }    \n   \n   \n    // 从index位置开始向后查找元素(o)。    \n    // 若找到，则返回元素的索引值；否则，返回-1    \n    public synchronized int indexOf(Object o, int index) {    \n        if (o == null) {    \n            // 若查找元素为null，则正向找出null元素，并返回它对应的序号    \n            for (int i = index ; i < elementCount ; i++)    \n            if (elementData[i]==null)    \n                return i;    \n        } else {    \n            // 若查找元素不为null，则正向找出该元素，并返回它对应的序号    \n            for (int i = index ; i < elementCount ; i++)    \n            if (o.equals(elementData[i]))    \n                return i;    \n        }    \n        return -1;    \n    }    \n   \n    // 查找并返回元素(o)在Vector中的索引值    \n    public int indexOf(Object o) {    \n        return indexOf(o, 0);    \n    }    \n   \n    // 从后向前查找元素(o)。并返回元素的索引    \n    public synchronized int lastIndexOf(Object o) {    \n        return lastIndexOf(o, elementCount-1);    \n    }    \n   \n    // 从后向前查找元素(o)。开始位置是从前向后的第index个数；    \n    // 若找到，则返回元素的“索引值”；否则，返回-1。    \n    public synchronized int lastIndexOf(Object o, int index) {    \n        if (index >= elementCount)    \n            throw new IndexOutOfBoundsException(index + \" >= \"+ elementCount);    \n   \n        if (o == null) {    \n            // 若查找元素为null，则反向找出null元素，并返回它对应的序号    \n            for (int i = index; i >= 0; i--)    \n            if (elementData[i]==null)    \n                return i;    \n        } else {    \n            // 若查找元素不为null，则反向找出该元素，并返回它对应的序号    \n            for (int i = index; i >= 0; i--)    \n            if (o.equals(elementData[i]))    \n                return i;    \n        }    \n        return -1;    \n    }    \n   \n    // 返回Vector中index位置的元素。    \n    // 若index月结，则抛出异常    \n    public synchronized E elementAt(int index) {    \n        if (index >= elementCount) {    \n            throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);    \n        }    \n   \n        return (E)elementData[index];    \n    }    \n   \n    // 获取Vector中的第一个元素。    \n    // 若失败，则抛出异常！    \n    public synchronized E firstElement() {    \n        if (elementCount == 0) {    \n            throw new NoSuchElementException();    \n        }    \n        return (E)elementData[0];    \n    }    \n   \n    // 获取Vector中的最后一个元素。    \n    // 若失败，则抛出异常！    \n    public synchronized E lastElement() {    \n        if (elementCount == 0) {    \n            throw new NoSuchElementException();    \n        }    \n        return (E)elementData[elementCount - 1];    \n    }    \n   \n    // 设置index位置的元素值为obj    \n    public synchronized void setElementAt(E obj, int index) {    \n        if (index >= elementCount) {    \n            throw new ArrayIndexOutOfBoundsException(index + \" >= \" +    \n                                 elementCount);    \n        }    \n        elementData[index] = obj;    \n    }    \n   \n    // 删除index位置的元素    \n    public synchronized void removeElementAt(int index) {    \n        modCount++;    \n        if (index >= elementCount) {    \n            throw new ArrayIndexOutOfBoundsException(index + \" >= \" +    \n                                 elementCount);    \n        } else if (index < 0) {    \n            throw new ArrayIndexOutOfBoundsException(index);    \n        }    \n   \n        int j = elementCount - index - 1;    \n        if (j > 0) {    \n            System.arraycopy(elementData, index + 1, elementData, index, j);    \n        }    \n        elementCount--;    \n        elementData[elementCount] = null; /* to let gc do its work */   \n    }    \n   \n    // 在index位置处插入元素(obj)    \n    public synchronized void insertElementAt(E obj, int index) {    \n        modCount++;    \n        if (index > elementCount) {    \n            throw new ArrayIndexOutOfBoundsException(index    \n                                 + \" > \" + elementCount);    \n        }    \n        ensureCapacityHelper(elementCount + 1);    \n        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);    \n        elementData[index] = obj;    \n        elementCount++;    \n    }    \n   \n    // 将“元素obj”添加到Vector末尾    \n    public synchronized void addElement(E obj) {    \n        modCount++;    \n        ensureCapacityHelper(elementCount + 1);    \n        elementData[elementCount++] = obj;    \n    }    \n   \n    // 在Vector中查找并删除元素obj。    \n    // 成功的话，返回true；否则，返回false。    \n    public synchronized boolean removeElement(Object obj) {    \n        modCount++;    \n        int i = indexOf(obj);    \n        if (i >= 0) {    \n            removeElementAt(i);    \n            return true;    \n        }    \n        return false;    \n    }    \n   \n    // 删除Vector中的全部元素    \n    public synchronized void removeAllElements() {    \n        modCount++;    \n        // 将Vector中的全部元素设为null    \n        for (int i = 0; i < elementCount; i++)    \n            elementData[i] = null;    \n   \n        elementCount = 0;    \n    }    \n   \n    // 克隆函数    \n    public synchronized Object clone() {    \n        try {    \n            Vector<E> v = (Vector<E>) super.clone();    \n            // 将当前Vector的全部元素拷贝到v中    \n            v.elementData = Arrays.copyOf(elementData, elementCount);    \n            v.modCount = 0;    \n            return v;    \n        } catch (CloneNotSupportedException e) {    \n            // this shouldn\'t happen, since we are Cloneable    \n            throw new InternalError();    \n        }    \n    }    \n   \n    // 返回Object数组    \n    public synchronized Object[] toArray() {    \n        return Arrays.copyOf(elementData, elementCount);    \n    }    \n   \n    // 返回Vector的模板数组。所谓模板数组，即可以将T设为任意的数据类型    \n    public synchronized <T> T[] toArray(T[] a) {    \n        // 若数组a的大小 < Vector的元素个数；    \n        // 则新建一个T[]数组，数组大小是“Vector的元素个数”，并将“Vector”全部拷贝到新数组中    \n        if (a.length < elementCount)    \n            return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());    \n   \n        // 若数组a的大小 >= Vector的元素个数；    \n        // 则将Vector的全部元素都拷贝到数组a中。    \n    System.arraycopy(elementData, 0, a, 0, elementCount);    \n   \n        if (a.length > elementCount)    \n            a[elementCount] = null;    \n   \n        return a;    \n    }    \n   \n    // 获取index位置的元素    \n    public synchronized E get(int index) {    \n        if (index >= elementCount)    \n            throw new ArrayIndexOutOfBoundsException(index);    \n   \n        return (E)elementData[index];    \n    }    \n   \n    // 设置index位置的值为element。并返回index位置的原始值    \n    public synchronized E set(int index, E element) {    \n        if (index >= elementCount)    \n            throw new ArrayIndexOutOfBoundsException(index);    \n   \n        Object oldValue = elementData[index];    \n        elementData[index] = element;    \n        return (E)oldValue;    \n    }    \n   \n    // 将“元素e”添加到Vector最后。    \n    public synchronized boolean add(E e) {    \n        modCount++;    \n        ensureCapacityHelper(elementCount + 1);    \n        elementData[elementCount++] = e;    \n        return true;    \n    }    \n   \n    // 删除Vector中的元素o    \n    public boolean remove(Object o) {    \n        return removeElement(o);    \n    }    \n   \n    // 在index位置添加元素element    \n    public void add(int index, E element) {    \n        insertElementAt(element, index);    \n    }    \n   \n    // 删除index位置的元素，并返回index位置的原始值    \n    public synchronized E remove(int index) {    \n        modCount++;    \n        if (index >= elementCount)    \n            throw new ArrayIndexOutOfBoundsException(index);    \n        Object oldValue = elementData[index];    \n   \n        int numMoved = elementCount - index - 1;    \n        if (numMoved > 0)    \n            System.arraycopy(elementData, index+1, elementData, index,    \n                     numMoved);    \n        elementData[--elementCount] = null; // Let gc do its work    \n   \n        return (E)oldValue;    \n    }    \n   \n    // 清空Vector    \n    public void clear() {    \n        removeAllElements();    \n    }    \n   \n    // 返回Vector是否包含集合c    \n    public synchronized boolean containsAll(Collection<?> c) {    \n        return super.containsAll(c);    \n    }    \n   \n    // 将集合c添加到Vector中    \n    public synchronized boolean addAll(Collection<? extends E> c) {    \n        modCount++;    \n        Object[] a = c.toArray();    \n        int numNew = a.length;    \n        ensureCapacityHelper(elementCount + numNew);    \n        // 将集合c的全部元素拷贝到数组elementData中    \n        System.arraycopy(a, 0, elementData, elementCount, numNew);    \n        elementCount += numNew;    \n        return numNew != 0;    \n    }    \n   \n    // 删除集合c的全部元素    \n    public synchronized boolean removeAll(Collection<?> c) {    \n        return super.removeAll(c);    \n    }    \n   \n    // 删除“非集合c中的元素”    \n    public synchronized boolean retainAll(Collection<?> c)  {    \n        return super.retainAll(c);    \n    }    \n   \n    // 从index位置开始，将集合c添加到Vector中    \n    public synchronized boolean addAll(int index, Collection<? extends E> c) {    \n        modCount++;    \n        if (index < 0 || index > elementCount)    \n            throw new ArrayIndexOutOfBoundsException(index);    \n   \n        Object[] a = c.toArray();    \n        int numNew = a.length;    \n        ensureCapacityHelper(elementCount + numNew);    \n   \n        int numMoved = elementCount - index;    \n        if (numMoved > 0)    \n        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);    \n   \n        System.arraycopy(a, 0, elementData, index, numNew);    \n        elementCount += numNew;    \n        return numNew != 0;    \n    }    \n   \n    // 返回两个对象是否相等    \n    public synchronized boolean equals(Object o) {    \n        return super.equals(o);    \n    }    \n   \n    // 计算哈希值    \n    public synchronized int hashCode() {    \n        return super.hashCode();    \n    }    \n   \n    // 调用父类的toString()    \n    public synchronized String toString() {    \n        return super.toString();    \n    }    \n   \n    // 获取Vector中fromIndex(包括)到toIndex(不包括)的子集    \n    public synchronized List<E> subList(int fromIndex, int toIndex) {    \n        return Collections.synchronizedList(super.subList(fromIndex, toIndex), this);    \n    }    \n   \n    // 删除Vector中fromIndex到toIndex的元素    \n    protected synchronized void removeRange(int fromIndex, int toIndex) {    \n        modCount++;    \n        int numMoved = elementCount - toIndex;    \n        System.arraycopy(elementData, toIndex, elementData, fromIndex,    \n                         numMoved);    \n   \n        // Let gc do its work    \n        int newElementCount = elementCount - (toIndex-fromIndex);    \n        while (elementCount != newElementCount)    \n            elementData[--elementCount] = null;    \n    }    \n   \n    // java.io.Serializable的写入函数    \n    private synchronized void writeObject(java.io.ObjectOutputStream s)    \n        throws java.io.IOException {    \n        s.defaultWriteObject();    \n    }    \n}   \n```\n\n##几点总结\n\nVector的源码实现总体与ArrayList类似，关于Vector的源码，给出如下几点总结：\n\n1、Vector有四个不同的构造方法。无参构造方法的容量为默认值10，仅包含容量的构造方法则将容量增长量（从源码中可以看出容量增长量的作用，第二点也会对容量增长量详细说）明置为0。\n\n2、注意扩充容量的方法ensureCapacityHelper。与ArrayList相同，Vector在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就先看构造方法中传入的容量增长量参数CapacityIncrement是否为0，如果不为0，就设置新的容量为就容量加上容量增长量，如果为0，就设置新的容量为旧的容量的2倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后同样用Arrays.copyof()方法将元素拷贝到新的数组。\n\n3、很多方法都加入了synchronized同步语句，来保证线程安全。\n\n4、同样在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，Vector中也允许元素为null。\n\n5、其他很多地方都与ArrayList实现大同小异，Vector现在已经基本不再使用。 ', '2', '0', '2017-08-04 13:17:59'), ('116', '1', '189', '#HashMap\n---\n\n###HashMap和Hashtable的区别：\n\n1. Hashtable的大部分方法做了同步，HashMap没有，因此，HashMap不是线程安全的。\n2. Hashtable不允许key或者value使用null值，而HashMap可以。\n3. 在内部算法上，它们对key的hash算法和hash值到内存索引的映射算法不同。\n\n###HashMap的实现原理\n\n简单说，HashMap就是将key做hash算法，然后将hash所对应的数据映射到内存地址，直接取得key所对应的数据。在HashMap中。底层数据结构使用的是数组，所谓的内存地址即数组的下标索引。HashMap的高性能需要保证以下几点：\n\n* hash算法必须高效\n* hash值到内存地址(数组索引)的算法是快速的\n* 根据内存地址(数组索引)可以直接取得对应的值\n\n如何保证hash算法高效,hash算法有关的代码如下：\n\n```\nint hash = hash(key.hashCode());\npublic native int hashCode();\nstatic int hash(int h){\n	h ^= (h >>> 20) ^ (h >>> 12);\n	return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n第一行代码是HashMap用于计算key的hash值，它前后调用了Object类的hashCode()方法和HashMap的内部函数hash()。Object类的hashCode()方法默认是native的实现，可以认为不存在性能问题。而hash()函数的实现全部基于位运算，因此，也是高效的。\n\n当取得key的hash值后，需要通过hash值得到内存地址：\n\n```\nint i = indexFor(hash, table.length);\nstatic int indexFor(int h, int length){\n	return h & (length - 1);\n}\n```\n\nindexFor()函数通过将hash值和数组长度按位与直接得到数组索引。\n最后由indexFor()函数返回的数组索引直接通过数组下标便可取得对应的值，直接的内存访问速度也是相当的快，因此，可认为HashMap是高性能的。\n\n###Hash冲突\n\n如图3.11所示，需要存放到HashMap中的两个元素1和2，通过hash计算后，发现对应在内存中的同一个地址，如何处理？\n其实HashMap的底层实现使用的是数组，但是数组内的元素并不是简单的值。而是一个Entry类的对象。因此，对HashMap结构贴切描述如图3.12所示。\n\n![这里写图片描述](http://img.blog.csdn.net/20160509103524275)\n\n\n可以看到，HashMap的内部维护着一个Entry数组，每一个Entry表项包括key、value、next和hash几项。next部分指向另外一个Entry。进一步阅读HashMap的put()方法源码，可以看到当put()操作有冲突时，新的Entry依然会被安放在对应的索引下标内，并替换原有的值。同时为了保证旧值不丢失，会将新的Entry的next指向旧值。这便实现了在一个数组索引空间内存放多个值项。因此，如图3.12所示，HashMap实际上是一个链表的数组。\n\n```\npublic V put(K key, V value){\n	if(key == null)\n		return putForNullKey(value);\n	int hash = hash(key.hashCode());\n	int i = indexFor(hash, table.length);\n	for(Entry<K, V> e = table[i]; e != null; e = e.next){\n		Object k;\n		//如果当前的key已经存在于HashMap中\n		if(e.hash == hash && ((k = e.key) == key || key.equals(k)))\n		{\n			V oldValue = e.value;    //取得旧值\n			e.value = value;\n			e.recordAccess(this);\n			return oldValue;     //返回旧值\n		}\n	}\n	modCount++;\n	addEntry(hash, key, value, i);    //添加当前的表项到i位置\n	return null;\n}\n```\n\naddEntry()方法的实现如下：\n\n```\nvoid addEntry(int hash, K key, V value, int bucketIndex){\n	Entry<K,V> e = table[bucketIndex];\n	//将新增元素放到i的位置，并让它的next指向旧的元素\n	table[bucketIndex] = new Entry<K,V>(hash, key, value, e);\n	if(size++ >= threshold){\n		resize(2 * table.length);\n	}\n}\n```\n\n基于HashMap的这种实现机制，只要hashCode和hash()方法实现的足够好，能够尽可能的减少冲突的产生，那么对HashMap的操作几乎等价于对数组的随机访问操作，具有很好的性能。但是，如果hashCode()或者hash()方法实现较差，在大量冲突产生的情况下，HashMap事实上就退化为几个链表，对HashMap的操作等价于遍历链表，此时性能很差。\n\n###容量参数\n\n除hashCode()的实现外，影响HashMap性能的还有它的容量参数。和ArrayList和Vector一样，这种基于数组的结构，不可避免的需要在数组空间不足时，进行扩展。而数组的重组相对而言较为耗时，因此对其作一定了解有助于优化HashMap的性能。\n\nHashMap提供了两个可以指定初始化大小的构造函数：\n\n```\npublic HashMap(int initialCapacity)\npublic HashMap(int initialCapacity, float loadFactor)\n```\n\n其中initialCapacity指定了HashMap的初始容量，loadFactor指定了其负载因子。初始容量即数组的大小，HashMap会使用大于等于initialCapacity并且是2的指数次幂的最小的整数作为内置数组的大小。负载因子又叫填充比，它是介于0和1之间的浮点数，它决定了HashMap在扩容之前，其内部数组的填充度。默认情况下，HashMap初始大小为16，负载因子为0.75。\n\n**负载因子 ＝ 元素个数/内部数组总大小**\n\n在实际使用中，负载因子也可以设置为大于1的数，但如果这样做，HashMap将必然产生大量冲突，因为这无疑是在尝试往只有10个口袋的包里放15件物品，必然有几只口袋要大于一个物件。因此，通常不会这么使用。\n\n在HashMap内部，还维护了一个threshold变量，它始终被定义为当前数组总容量和负载因子的乘积，它表示HashMap的阈值。当HashMap的实际容量超过阈值时，HashMap便会进行扩容。因此，HashMap的实际容量超过阈值时，HashMap便会进行扩容。因此，HashMap的实际填充率不会超过负载因子。\n\nHashMap扩容的代码如下：\n\n```\nvoid resize(int newCapacity){\n	Entry[] oldTable = table;\n	int oldCapacity= oldTable.length;\n	if(oldCapacity == MAXMUM_CAPACITY){\n		threhold = Integer.MAX_VALUE;\n		return;\n	}\n	//建立新的数组\n	Entry[] newTable = new Entry[newCapacity];\n	//将原有数组转到新的数组中\n	transfer(newTable);\n	table = newTable;\n	//重新设置阈值，为新的容量和负载因子的乘积\n	threshold = (int)(newCapacity * loadFactory);\n}\n```\n\n其中，数组迁移逻辑主要在transfer()函数中实现，该函数实现和注释如下：\n\n```\nvoid transfer(Entry[] newTable){\n	Entry[] src = table;\n	int newCapacity = newTable.length;\n	//遍历数组内所有表项\n	for(int j = 0; j < src.length; j++){\n		Entry<K,V> e = src[j];\n		//当该表项索引有值存在时，则进行迁移\n		if(e != null){\n			src[j] = null;\n			do{\n				//进行数据迁移\n				Entry<K,V> next = e.next;\n				//计算该表现在新数组内的索引，并放置到新的数组中\n				//建立新的链表关系\n				int i = indexFor(e,hash, newCapacity);\n				e.next = newTable[i];\n				newTable[i] = e;\n				e = next;\n			}while(e != null)\n		}\n	}\n}\n```\n\n很明显，HashMap的扩容操作会遍历整个HashMap，应该尽量避免该操作发生，设置合理的初始大小和负载因子，可以有效的减少HashMap扩容的次数。\n\n\n**参考书籍：《Java程序性能优化》**', '2', '0', '2017-08-04 13:19:19'), ('117', '1', '190', '# 反射机制\n\n反射技术：其实就是动态加载一个指定的类，并获取该类中所有的内容。并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。\n\n\n反射的好处：大大增强了程序的扩展性。\n\n反射的基本步骤：\n\n1. 获得Class对象，就是获得指定的名称的字节码文件对象\n2. 实例化对象，获得类的属性、方法或者构造函数\n3. 访问属性、调用方法、调用构造函数创建对象\n\n\n', '2', '0', '2017-08-04 13:19:56'), ('118', '1', '192', '##内存区域\n\nJava虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器，Java虚拟机栈，本地方法栈，Java堆，方法区。下面详细阐述各数据区所存储的数据类型。\n\n![这里写图片描述](http://img.blog.csdn.net/20160401142029373)\n\n**程序计数器（Program Counter Register）**\n\n一块较小的内存空间，它是当前线程所执行的子节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的子节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。\n\n当线程在执行一个Java方法时，该计数器纪录的是正在执行的虚拟机字节吗指令的地址，当线程在执行的是Native方法(调用本地操作系统方法)时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中没有任何OOM（内存溢出：OutOfMemoryError）情况的区域。\n\n**Java虚拟机栈（Java Virtual Machine Stacks）**\n\n该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个帧栈，栈它是用于支持虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码都只针对当前的栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。\n在Java虚拟机规范中，对这个区域规定了两种异常情况：\n\n1.  如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。\n2. 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemory异常。\n\n这两种情况存在着一些互相重叠的部分：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质只是对同一件事情的两种描述而已。其本质上只是对一件事情的两种描述而已。在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemory异常。\n\n下面详细说明栈帧中所存放的各部分信息的作用和数据结构。\n\n局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和returnAddress类型（它指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，即在Java程序被编译成Class文件时，就确定了所需分配的最大局部变量表的容量。当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。\n下面详细说明栈帧中所存放的各部分信息的作用和数据结构。 \n\n1、局部变量表\n局部变量表的容量以变量槽（Slot）为最小单位。在虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小（允许其随着处理器、操作系统或虚拟机的不同而发生变化），一个Slot可以存放一个32位以内的数据类型：boolean、byte、char、short、int、float、reference和returnAddresss。reference是对象的引用类型，returnAddress是为字节指令服务的，它执行了一条字节码指令的地址。对于64位的数据类型（long和double），虚拟机会以高位在前的方式为其分配两个连续的Slot空间。\n\n虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量，对于32位数据类型的变量，索引n代表第n个Slot，对于64位的，索引n代表第n和第n+1两个Slot。\n\n在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），则局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。\n\n局部变量表中的Slot是可重用的，方法体中定义的变量，作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。这样的设计不仅仅是为了节省空间，在某些情况下Slot的复用会直接影响到系统的而垃圾收集行为。\n\n2、操作数栈\n\n操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32位数据类型所占的栈容量为1,64为数据类型所占的栈容量为2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。\n\nJava虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称Java虚拟机是基于栈的，这点不同于Android虚拟机，Android虚拟机是基于寄存器的。\n\n基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差。\n\n3、动态连接\n\n每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。\n\n4、方法返回地址\n\n当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。\n\n方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。\n\n**本地方法栈（Native Method Stacks）**\n\n该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。\n\n**Java堆（Java Heap）**\n\nJava Heap是Java虚拟机所管理的内存中的最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为\"GC堆\"。\n\n根据Java虚拟机的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemory。\n\n**方法区（Method Area）**\n\n方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为\"永久代\"。但着这仅仅对于Sun HotSpot来讲，JRocket和IBMJ9虚拟机中并不存在永久代的概念。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，而且它和Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域比较少出现。该区域的内存回收目标主要针是对废弃常量的和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。\n\n根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。\n\n直接内存（Direct Memory）\n\n直接内存并不是虚拟机运行内存时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，它直接从操作系统中分配内存，因此不受Java堆的大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致OutOfMemoryError异常出现。在Java1.4中新引入了NIO机制，它是一种基于通道与缓冲区的新I/O方式，可以直接从操作系统中分配直接内存，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n\n内存溢出\n\n下面给出个内存区域内存溢出的简单测试方法\n\n![这里写图片描述](http://img.blog.csdn.net/20160401173849014)\n\n这里有一点要重点说明，在多线程情况下，给每个线程的栈分配的内存越大，反而越容易产生内存产生内存溢出一场。操作系统为每个进程分配的内存是有限制的，虚拟机提供了参数来控制Java堆和方法区这两部分内存的最大值，忽略掉程序计数器消耗的内存（很小），以及进程本身消耗的内存，剩下的内存便给了虚拟机栈和本地方法栈，每个线程分配到的栈容量越大，可以建立的线程数量自然就越少。因此，如果是建立过多的线程导致的内存溢出，在不能减少线程数的情况下，就只能通过减少最大堆和每个线程的栈容量来换取更多的线程。\n另外，由于Java堆内也可能发生内存泄露（Memory Leak），这里简要说明一下内存泄露和内存溢出的区别：\n\n内存泄漏是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java中一般不会产生内存泄漏，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们new了对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这就会造成内存泄漏。\n\n内存溢出是指程序所需要的内存超过了系统所能分配的内存（包括动态扩展）的上限。\n\n对象实例化分析\n\n对内存分配情况分析最常见的示例便是对象实例化：\n\n```\nObject obj = new Object();\n```\n\n这段代码的执行会涉及java栈、Java堆、方法区三个最重要的内存区域。假设该语句出现在方法体中，及时对JVM虚拟机不了解的Java使用这，应该也知道obj会作为引用类型（reference）的数据保存在Java栈的本地变量表中，而会在Java堆中保存该引用的实例化对象，但可能并不知道，Java堆中还必须包含能查找到此对象类型数据的地址信息（如对象类型、父类、实现的接口、方法等），这些类型数据则保存在方法区中。\n\n另外，由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄池和直接使用指针。\n\n通过句柄池访问的方式如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20160401175131207)\n\n通过直接指针访问的方式如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20160401175203926)\n\n这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存放的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式的最大好处是速度快，它节省了一次指针定位的时间开销。目前Java默认使用的HotSpot虚拟机采用的便是是第二种方式进行对象访问的。', '2', '0', '2017-08-04 13:21:06'), ('119', '1', '193', '#JVM\n---\n\n**内存模型以及分区，需要详细到每个区放什么。**\n\n[http://blog.csdn.net/ns_code/article/details/17565503](http://blog.csdn.net/ns_code/article/details/17565503)\n\nJVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。\n\n![](http://img.blog.csdn.net/20131226151744250)\n\n程序计数器(Program Counter Register)\n\n一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。\n\n当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中么有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。\n\nJava虚拟机栈（Java Virtual Machine Stacks）\n\n该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。\n\n本地方法栈（Native Method Stacks）\n\n该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。\n\nJava堆（Java Heap）\n\nJava Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。\n\n根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。   \n\n方法区（Method Area）\n\n方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”，但这仅仅对于Sun HotSpot来讲，JRockit和IBM J9虚拟机中并不存在永久代的概念。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，而且它和Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域比较少出现。该区域的内存回收目标主要针是对废弃常量的和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。\n\n根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。\n\n**内存泄漏和内存溢出的差别**\n\n内存泄露是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们new了对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这边会造成内存泄露，\n\n内存溢出是指程序所需要的内存超出了系统所能分配的内存（包括动态扩展）的上限。\n\n**类型擦除**\n\n[http://blog.csdn.net/ns_code/article/details/18011009](http://blog.csdn.net/ns_code/article/details/18011009)\n\nJava语言在JDK1.5之后引入的泛型实际上只在程序源码中存在，在编译后的字节码文件中，就已经被替换为了原来的原生类型，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，`ArrayList<String>`和`ArrayList<Integer>`就是同一个类。所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为伪泛型。\n\n下面是一段简单的Java泛型代码：\n\n```\nMap<Integer,String> map = new HashMap<Integer,String>();  \nmap.put(1,\"No.1\");  \nmap.put(2,\"No.2\");  \nSystem.out.println(map.get(1));  \nSystem.out.println(map.get(2));  \n````\n\n将这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都变回了原生类型，如下面的代码所示：\n\n```\nMap map = new HashMap();  \nmap.put(1,\"No.1\");  \nmap.put(2,\"No.2\");  \nSystem.out.println((String)map.get(1));  \nSystem.out.println((String)map.get(2));  \n```\n\n为了更详细地说明类型擦除，再看如下代码：\n\n```\nimport java.util.List;  \npublic class FanxingTest{  \n    public void method(List<String> list){  \n        System.out.println(\"List String\");  \n    }  \n    public void method(List<Integer> list){  \n        System.out.println(\"List Int\");  \n    }  \n}  \n```\n\n当我用Javac编译器编译这段代码时，报出了如下错误：\n\n\n```\nFanxingTest.java:3: 名称冲突：method(java.util.List<java.lang.String>) 和 method\n\n(java.util.List<java.lang.Integer>) 具有相同疑符\n\npublic void method(List<String> list){\n\n^\n\nFanxingTest.java:6: 名称冲突：method(java.util.List<java.lang.Integer>) 和 metho\n\nd(java.util.List<java.lang.String>) 具有相同疑符\n\npublic void method(List<Integer> list){\n\n^\n```\n\n2 错误\n\n\n这是因为泛型List<String>和List<Integer>编译后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样，在Class类文件结构一文中讲过，Class文件中不能存在特征签名相同的方法。\n\n把以上代码修改如下：\n\n```\nimport java.util.List;  \npublic class FanxingTest{  \n    public int method(List<String> list){  \n        System.out.println(\"List String\");  \n        return 1;  \n    }  \n    public boolean method(List<Integer> list){  \n        System.out.println(\"List Int\");  \n        return true;  \n    }  \n}  \n```\n\n发现这时编译可以通过了（注意：Java语言中true和1没有关联，二者属于不同的类型，不能相互转换，不存在C语言中整数值非零即真的情况）。两个不同类型的返回值的加入，使得方法的重载成功了。这是为什么呢？\n\n    我们知道，Java代码中的方法特征签名只包括了方法名称、参数顺序和参数类型，并不包括方法的返回值，因此方法的返回值并不参与重载方法的选择，这样看来为重载方法加入返回值貌似是多余的。对于重载方法的选择来说，这确实是多余的，但我们现在要解决的问题是让上述代码能通过编译，让两个重载方法能够合理地共存于同一个Class文件之中，这就要看字节码的方法特征签名，它不仅包括了Java代码中方法特征签名中所包含的那些信息，还包括方法返回值及受查异常表。为两个重载方法加入不同的返回值后，因为有了不同的字节码特征签名，它们便可以共存于一个Class文件之中。\n\n**堆里面的分区：Eden，survival from to，老年代，各自的特点。**\n\n\n\n**对象创建方法，对象的内存分配，对象的访问定位。**\n\n对内存分配情况分析最常见的示例便是对象实例化:\n\n```\nObject obj = new Object();\n```\n\n这段代码的执行会涉及java栈、Java堆、方法区三个最重要的内存区域。假设该语句出现在方法体中，及时对JVM虚拟机不了解的Java使用这，应该也知道obj会作为引用类型（reference）的数据保存在Java栈的本地变量表中，而会在Java堆中保存该引用的实例化对象，但可能并不知道，Java堆中还必须包含能查找到此对象类型数据的地址信息（如对象类型、父类、实现的接口、方法等），这些类型数据则保存在方法区中。\n\n另外，由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄池和直接使用指针。\n\n\n\n**GC的两种判定方法：引用计数与引用链。**\n\n引用计数方式最基本的形态就是让每个被管理的对象与一个引用计数器关联在一起，该计数器记录着该对象当前被引用的次数，每当创建一个新的引用指向该对象时其计数器就加1，每当指向该对象的引用失效时计数器就减1。当该计数器的值降到0就认为对象死亡。\n\nJava的内存回收机制可以形象地理解为在堆空间中引入了重力场，已经加载的类的静态变量和处于活动线程的堆栈空间的变量是这个空间的牵引对象。这里牵引对象是指按照Java语言规范，即便没有其它对象保持对它的引用也不能够被回收的对象，即Java内存空间中的本原对象。当然类可能被去加载，活动线程的堆栈也是不断变化的，牵引对象的集合也是不断变化的。对于堆空间中的任何一个对象，如果存在一条或者多条从某个或者某几个牵引对象到该对象的引用链，则就是可达对象，可以形象地理解为从牵引对象伸出的引用链将其拉住，避免掉到回收池中。\n\n**GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？**\n\n标记清除算法是最基础的收集算法，其他收集算法都是基于这种思想。标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，标记完成之后统一清除对象。它的主要缺点：①.标记和清除过程效率不高 。②.标记清除之后会产生大量不连续的内存碎片。\n\n标记整理，标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。\n\n复制算法，它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。主要缺点：内存缩小为原来的一半。\n\n\n**Minor GC与Full GC分别在什么时候发生？**\n\nMinor GC：通常是指对新生代的回收。指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快\n\nMajor GC：通常是指对年老代的回收。\n\nFull GC：Major GC除并发gc外均需对整个堆进行扫描和回收。指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 ParallelScavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程） 。MajorGC 的速度一般会比 Minor GC 慢 10倍以上。\n\n**几种常用的内存调试工具：jmap、jstack、jconsole。**\n\njmap（linux下特有，也是很常用的一个命令）观察运行中的jvm物理内存的占用情况。\n参数如下：\n-heap：打印jvm heap的情况\n-histo：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。\n-histo：live ：同上，但是只答应存活对象的情况\n-permstat：打印permanent generation heap情况\njstack（linux下特有）可以观察到jvm中当前所有线程的运行情况和线程当前状态\njconsole一个图形化界面，可以观察到java进程的gc，class，内存等信息\njstat最后要重点介绍下这个命令。这是jdk命令中比较重要，也是相当实用的一个命令，可以观察到classloader，compiler，gc相关信息\n具体参数如下：\n-class：统计class loader行为信息\n-compile：统计编译行为信息\n-gc：统计jdk gc时heap信息\n-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况\n-gccause：统计gc的情况，（同-gcutil）和引起gc的事件\n-gcnew：统计gc时，新生代的情况\n-gcnewcapacity：统计gc时，新生代heap容量\n-gcold：统计gc时，老年区的情况\n-gcoldcapacity：统计gc时，老年区heap容量\n-gcpermcapacity：统计gc时，permanent区heap容量\n-gcutil：统计gc时，heap情况\n-printcompilation：不知道干什么的，一直没用过。\n\n**类加载的五个过程：加载、验证、准备、解析、初始化。**\n\n类加载过程\n\n类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括加载、验证、准备、解析、初始化、使用、卸载。\n\n其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。\n\n这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：\n\n* 静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。\n* 动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。\n\n“加载”(Loading)阶段是“类加载”(Class Loading)过程的第一个阶段，在此阶段，虚拟机需要完成以下三件事情：\n\n1. 通过一个类的全限定名来获取定义此类的二进制字节流。\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。\n\n验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n\n准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。\n\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。\n\n\n\n**双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。**\n\n1. 启动类加载器，负责将存放在<JAVA_HOME>\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即时放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用。\n2. 扩展类加载器：负责加载<JAVA_HOME>\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用该类加载器。\n3. 应用程序类加载器：负责加载用户路径上所指定的类库，开发者可以直接使用这个类加载器，也是默认的类加载器。\n三种加载器的关系：启动类加载器->扩展类加载器->应用程序类加载器->自定义类加载器。\n\n这种关系即为类加载器的双亲委派模型。其要求除启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不以继承关系实现，而是用组合的方式来复用父类的代码。\n\n双亲委派模型的工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。\n\n好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。\n\n实现：在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。\n\n\n**分派：静态分派与动态分派。**\n\n静态分派与重载有关，虚拟机在重载时是通过参数的静态类型，而不是运行时的实际类型作为判定依据的；静态类型在编译期是可知的；\n动态分派与重写（Override）相关，invokevirtual(调用实例方法)指令执行的第一步就是在运行期确定接收者的实际类型，根据实际类型进行方法调用；\n\n**GC收集器有哪些？CMS收集器与G1收集器的特点。**\n\n\n\n**自动内存管理机制，GC算法，运行时数据区结构，可达性分析工作原理，如何分配对象内存**\n\n**反射机制，双亲委派机制，类加载器的种类**\n\n**Jvm内存模型，先行发生原则，violate关键字作用**', '2', '0', '2017-08-04 13:21:42'), ('120', '1', '194', '#虚拟机类加载机制\n---\n**虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被Java虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。**\n\n类从被加载到虚拟内存中开始，到卸载内存为止，它的整个生命周期包括了：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)七个阶段。其中，验证，准备和解析三个部分统称为连接(Linking)。\n\n###类加载的过程\n类加载的全过程，加载，验证，准备，解析和初始化这五个阶段。\n\n---\n\n####加载\n在加载阶段，虚拟机需要完成以下三件事情：\n\n* 通过一个类的全限定名来获取定义此类的二进制字节流\n* 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构\n* 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口\n\n####验证\n这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能有所不同，但大致上都会完成下面四个阶段的检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。\n\n**文件格式验证**\n\n第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。\n\n**元数据验证**\n\n第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。\n\n**字节码验证**\n\n第三阶段时整个验证过程中最复杂的一个阶段，主要工作是数据流和控制流的分析。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。\n\n**符号引用验证**\n\n最后一个阶段的校验发生在虚拟机将符号引用直接转化为直接引用的时候，这个转化动作将在连接的第三个阶段－解析阶段产生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验。\n\n####准备\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区进行分配。\n\n####解析\n解析阶段是虚拟机将常量池的符号引用转换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。\n\n* 类或接口的解析\n* 字段解析\n* 类方法解析\n* 接口方法解析\n\n####初始化\n前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由Java虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者说初始化阶段是执行类构造器<clinit>()方法的过程。\n\n###类加载器\n---\n####类与类加载器\n虚拟机设计团队把类加载阶段中的\"通过一个类的全限定名来获取描述此类的二进制字节流\"这个动作放到Java虚拟机外部去实现，以便让程序自己决定如何去获取所需的类。实现这个动作的代码模块被称为\"类加载器\"。\n\n####双亲委派模型\n站在Java虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。从Java开发人员的角度来看，类加载器还可以分得更细致一些，绝大部分Java程序都会使用到以下三种系统提供的类加载器：\n\n* 启动类加载器\n* 扩展类加载器\n* 应用程序类加载器\n', '2', '0', '2017-08-04 13:22:32'), ('121', '1', '195', '#垃圾回收算法\n---\n\n1. 引用计数法：缺点是无法处理循环引用问题\n2. 标记-清除法：标记所有从根结点开始的可达对象，缺点是会造成内存空间不连续，不连续的内存空间的工作效率低于连续的内存空间，不容易分配内存\n3. 复制算法：将内存空间分成两块，每次将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块。算法效率高，但是代价是系统内存折半。适用于新生代(存活对象少，垃圾对象多)\n4. 标记－压缩算法：标记－清除的改进，清除未标记的对象时还将所有的存活对象压缩到内存的一端，之后，清理边界所有空间既避免碎片产生，又不需要两块同样大小的内存快，性价比高。适用于老年代。\n5. 分代\n\n', '2', '0', '2017-08-04 13:22:53'), ('122', '1', '199', '# 冒泡排序\n---\n* 背景介绍： 是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。----- 来自 [wikipedia](https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F) \n* 算法规则： 由于算法每次都将一个最大的元素往上冒，我们可以将待排序集合(0...n)看成两部分，一部分为(k..n)的待排序unsorted集合，另一部分为(0...k)的已排序sorted集合，每一次都在unsorted集合从前往后遍历，选出一个数，如果这个数比其后面的数大，则进行交换。完成一轮之后，就肯定能将这一轮unsorted集合中最大的数移动到集合的最后，并且将这个数从unsorted中删除，移入sorted中。\n\n* 代码实现\n```\npublic void sort(int[] arr) {\n	//第一层循环从数组的最后往前遍历\n	for (int i = arr.length - 1; i > 0 ; --i) {\n		//这里循环的上界是 i - 1，在这里体现出 “将每一趟排序选出来的最大的数从sorted中移除”\n		for (int j = 0; j < i; j++) {\n			//保证在相邻的两个数中比较选出最大的并且进行交换(冒泡过程)\n			if (arr[j] > arr[j+1]) {\n				arr[j] = arr[j] ^ arr[j+1];\n				arr[j+1] = arr[j] ^ arr[j+1];\n				arr[j] = arr[j] ^ arr[j+1];\n			}\n		}\n	}\n}\n```\n', '2', '0', '2017-08-04 13:25:28'), ('123', '1', '200', '# 归并排序\n---\n* 背景介绍： 是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 ----- 来自 [wikipedia](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F) \n* **算法规则： 像快速排序一样，由于归并排序也是分治算法，因此可使用分治思想：**<br> 1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br> 2.设定两个指针，最初位置分别为两个已经排序序列的起始位置 <br> 3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 <br> 4.重复步骤3直到某一指针到达序列尾  <br> 5.将另一序列剩下的所有元素直接复制到合并序列尾\n\n* 代码实现\n        \n        public void mergeSort(int[] ints, int[] merge, int start, int end) \n        {\n        	if (start >= end) return;\n    		\n    		int mid = (end + start) >> 1;\n    		\n    		mergeSort(ints, merge, start, mid);\n    		mergeSort(ints, merge, mid + 1, end);\n    \n    		merge(ints, merge, start, end, mid);\n\n	    }\n        \n        private void merge(int[] a, int[] merge, int start, int end,int mid) \n        {\n        	int i = start;\n    		int j = mid+1;\n    		int pos = start;\n    		while( i <= mid || j <= end ){\n    			if( i > mid ){\n    				while( j <= end ) merge[pos++] = a[j++];\n    				break;\n    			}\n    			\n    			if( j > end ){\n    				while( i <= mid ) merge[pos++] = a[i++];\n    				break;\n    			}\n    			\n    			merge[pos++] = a[i] >= a[j] ? a[j++] : a[i++];\n    		}\n    		\n    		for (pos = start; pos <= end; pos++)\n    			a[pos] = merge[pos];\n		\n	    }\n', '2', '0', '2017-08-04 13:25:48'), ('124', '1', '201', '# 快速排序\n---\n* 背景介绍： 又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来 ----- 来自 [wikipedia](https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)  **\n* 算法规则： 本质来说，快速排序的过程就是不断地将无序元素集递归分割，一直到所有的分区只包含一个元素为止。 <br> 由于快速排序是一种分治算法，我们可以用分治思想将快排分为三个步骤：<br> 1.分：设定一个分割值，并根据它将数据分为两部分<br> 2.治：分别在两部分用递归的方式，继续使用快速排序法 <br> 3.合：对分割的部分排序直到完成 \n\n* 代码实现\n```\n        public int dividerAndChange(int[] args, int start, int end) {   \n            //标准值\n        	int pivot = args[start];\n    		while (start < end) {\n    			// 从右向左寻找，一直找到比参照值还小的数值，进行替换\n    			// 这里要注意，循环条件必须是 当后面的数 小于 参照值的时候\n    			// 我们才跳出这一层循环\n    			while (start < end && args[end] >= pivot)\n    				end--;\n    \n    			if (start < end) {\n    				swap(args, start, end);\n    				start++;\n    			}\n    \n    			// 从左向右寻找，一直找到比参照值还大的数组，进行替换\n    			while (start < end && args[start] < pivot)\n    				start++;\n    \n    			if (start < end) {\n    				swap(args, end, start);\n    				end--;\n    			}\n    		}\n    \n    		args[start] = pivot;\n    		return start;\n    	}\n\n    	public void sort(int[] args, int start, int end) {\n    		//当分治的元素大于1个的时候，才有意义\n    		if ( end - start > 1) {\n                int mid = 0;\n    			mid = dividerAndChange(args, start, end);\n    			// 对左部分排序\n    			sort(args, start, mid);\n    			// 对右部分排序\n    			sort(args, mid + 1, end);\n    		}\n    	}\n\n    	private void swap(int[] args, int fromIndex, int toIndex) {\n    		args[fromIndex] = args[toIndex];\n    	}\n```\n', '2', '0', '2017-08-04 13:26:17'), ('125', '1', '202', '# 选择排序\n---\n* 背景介绍： 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 ----- 来自 [wikipedia](https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F) \n* 算法规则： 将待排序集合(0...n)看成两部分，在起始状态中，一部分为(k..n)的待排序unsorted集合，另一部分为(0...k)的已排序sorted集合,在待排序集合中挑选出最小元素并且记录下标i，若该下标不等于k，那么 unsorted[i] 与 sorted[k]交换 ，一直重复这个过程，直到unsorted集合中元素为空为止。 \n\n* 代码实现\n```\npublic void sort(int[] arr) {\n        int len = arr.length;\n        for (int i = 0,k = 0; i < len; i++,k = i) {\n            // 在这一层循环中找最小\n            for (int j = i + 1; j < len; j++) {\n                // 如果后面的元素比前面的小，那么就交换下标，每一趟都会选择出来一个最小值的下标\n                if (arr[k] > arr[j]) k = j;\n    		}\n    \n    		if (i != k) {\n    			arr[i] = arr[k] ^ arr[i];\n				arr[k] = arr[k] ^ arr[i];\n				arr[i] = arr[k] ^ arr[i];\n    		}\n    	}\n}\n```\n', '2', '0', '2017-08-04 13:27:33'), ('126', '1', '203', '查看当前文本文件编码：\n```\nenca 文件名\n```\n\n转码\n```\niconv -c -f GB2312 -t UTF-8 转码前的文件 > 转码后的文件\n-c	忽略无效字符\n-f	from\n-t	to\n```\n```\niconv -l  # 查看icov支持转码的种类\n```', '2', '0', '2017-08-14 10:20:19'), ('127', '1', '204', '```\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * java 模拟死锁\n */\npublic class DeadLockTest implements Runnable {\n    public static void main(String[] args) {\n        DeadLockTest test = new DeadLockTest();\n\n        for (int i = 0; i < 2; i++) {\n            new Thread(test).start();\n        }\n    }\n\n    // 死锁时两把锁在互相抢夺资源，但都互不相让\n    private Lock lock1 = new ReentrantLock();\n    private Lock lock2 = new ReentrantLock();\n\n    private boolean flag = true;\n\n    @Override\n    public void run() {\n        if (flag) {\n            flag = false;\n\n            lock1.lock();\n\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                ;\n            }\n\n            System.out.println(\"flag = true，获取lock1锁\");\n\n                lock2.lock();\n                System.out.println(\"flag = true，获取lock2锁\");\n                lock2.unlock();\n\n            lock1.unlock();\n        } else {\n            flag = true;\n\n            lock2.lock();\n\n            System.out.println(\"flag = false，获取lock2锁\");\n\n                lock1.lock();\n                System.out.println(\"flag = false，获取lock1锁\");\n                lock1.unlock();\n				\n            lock2.unlock();\n        }\n    }\n}\n```\n输出：\n```\nflag = false，获取lock2锁，等待lock1释放锁\nflag = true，获取lock1锁，等待lock2释放锁\n\n=== 然后死锁 ===\n```', '2', '0', '2017-08-22 11:52:44'), ('128', '1', '205', '\n![](http://img.qiqinote.com/2017/8/23/870374f5dac54a889246144f823288ab.png)\n![](http://img.qiqinote.com/2017/8/23/b97b0432e88949d9abf37744eb0bed5b.png)\n![](http://img.qiqinote.com/2017/8/23/6e44742d48fb40e983842b0f2661b180.png)\n![](http://img.qiqinote.com/2017/8/23/bd9e84d5b9294758a2d3390e914dde8a.png)\n![](http://img.qiqinote.com/2017/8/23/1bcb6487cd5545c4aa40b7d9293c1f7a.png)', '2', '0', '2017-08-23 16:55:16'), ('129', '1', '206', '## JVM的工作原理，层次结构以及GC工作原理\n\n[TOC]\n\n### JVM\n```\nJava虚拟机（Java virtual machine, JVM） 是运行Java程序必不可少的机制。JVM实现了Java语言最重要的牲：平台无关性。原理：编译后的Java程序指令并不直接在硬件系统的CPU上执行，而是由JVM执行。JVM屏东了与具体平台相关的信息，使Java语言编译程序只需要生成在JVM上运行的目标字节码（.class），就可以在多种平台不加修改地运行。\nJava虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。它是Java程序能在多平台间进行无缝移植的可靠保证，同时也是Java程序的安全检验引擎（还进行安全检查）。\n\nJVM是编译后的Java程序（.class文件）和硬件系统之间的接口（编译后：javac是收录于JDK中的Java语言编译器。该工具可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。）\n```\n> JVM架构：\n\n![](http://img.qiqinote.com/2017/8/25/5c4dac6b5f914422a819541018d20acc.png)\n\n>  `JVM = 类加载器ClassLoader + 执行引擎 Execution Engine + 运行时数据区域 Runtime Data Area`\nClassLoader把硬盘上的class文件加载到JVM中的运行时数据区域，但是它不负责这个类文件能否执行，而这个是执行引擎负责的。\n\n#### ClassLoader\n\n- **作用：装载.class文件**\n> ClassLoader 有两种装载class的方式（时机）：\n> 1. 隐式：运行过程中，碰到new方式生成对象时，隐式调用ClassLoader到JVM\n> 2. 显式：通过Class.forName()动态加载\n\n- **双亲委派模型（Parent Delegation Model）**\n```\n类的加载过程采用双亲委托机制，这种机制能更好的保证 Java 平台的安全。\n该模型要求除了顶层的Bootstrap class loader启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）\n```\n> 双亲委派模型的工作过程为：\n>> 1. 当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。\n```\n每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。\n```\n>> 2. 当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 BootstrapClassLoader\n```\n当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。\n```\n\n- **使用这种模型来组织类加载器之间的关系的好处**\n```\n主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException\n```\n> 类加载器 classloader 是具有层次结构的，也就是父子关系。其中，Bootstrap 是所有类加载器的父亲。如下图所示：\n![](http://img.qiqinote.com/2017/8/25/e6cf46f0851b424b9a68fc40f0338c1a.png)\n>> Bootstrap class loader： 父类\n>>> 当运行 java 虚拟机时，这个类加载器被创建，它负责加载虚拟机的核心类库，如 java.lang.* 等。例如 java.lang.Object 就是由根类加载器加载的。需要注意的是，这个类加载器不是用 java 语言写的，而是用 C/C++ 写的。\n>>\nExtension class loader：\n>>> 这个加载器加载出了基本 API 之外的一些拓展类。\n>>\n>> AppClass Loader：\n>>> 加载应用程序和程序员自定义的类。\n>>\n>> 除了以上虚拟机自带的加载器以外，用户还可以定制自己的类加载器（User-defined Class Loader）。Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器应该继承 ClassLoader 类。\n>>\n>> 这是JVM分工自治生态系统的一个很好的体现。\n\n#### 执行引擎（Execution Engine）\n> 作用：执行字节码，或者执行本地方法\n\n#### 运行时数据区域（Runtime Data Area）\n```\nJVM 运行时数据区 (JVM Runtime Area) 其实就是指 JVM 在运行期间，其对JVM内存空间的划分和分配。JVM在运行时将数据划分为了6个区域来存储。\n\n程序员写的所有程序都被加载到运行时数据区域中，不同类别存放在heap, java stack, native method stack, PC register, method area.\n```\n\n> 下面对各个部分的功能和存储的内容进行描述：\n![](http://img.qiqinote.com/2017/8/25/3cc7ee35ab284523a2f125dd15cccd91.png)\n>\n> 1、PC程序计数器：\n```\n一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。\n```\n>\n> 2、java虚拟机栈：\n```\n与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n```\n>\n> 3、本地方法栈：\n```\n与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。\n```\n>\n> 4、Java堆：\n```\n被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。\n```\n>> Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。\n>>\nJVM将Heap分为两块：新生代New Generation和旧生代Old Generation\n>>\nNote:\n>>> - 堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因。\n- 鉴于上面的原因，Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间，这块空间又称为TLAB\n- TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效\n>\n> 5、方法区\n```\n方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。\n方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。 XX：PermSize指定大小。\n```\n>\n> 6、运行时常量池\n```\n其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。\n```\n\n### GC\n> 何为GC？\n```\n垃圾回收机制是由垃圾收集器Garbage Collection GC来实现的，GC是后台的守护进程。它的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况动态的调整他的优先级。因此，它是在内存中低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。\n```\n> 为何要这样设计？\n```\n因为GC也是进程，也要消耗CPU等资源，如果GC执行过于频繁会对java的程序的执行产生较大的影响（java解释器本来就不快），因此JVM的设计者们选着了不定期的gc。\n```\n\n```\nGC有关的是: runtime data area 中的 heap（对象实例会存储在这里） 和 gabage collector方法。\n程序运行期间，所有对象实例存储在运行时数据区域的heap中，当一个对象不再被引用（使用），它就需要被收回。在GC过程中，这些不再被使用的对象从heap中收回，这样就会有空间被循环利用。\nGC为内存中不再使用的对象进行回收，GC中调用回收的方法--收集器garbage collector. 由于GC要消耗一些资源和时间，Java 在对对象的生命周期特征（eden or survivor）进行分析之后，采用了分代的方式进行对象的收集，以缩短GC对应用造成的暂停。\n\n在垃圾回收器回收内存之前，还需要一些清理工作。\n因为垃圾回收gc只能回收通过new关键字申请的内存（在堆上），但是堆上的内存并不完全是通过new申请分配的。还有一些本地方法（一般是调用的C方法）。这部分“特殊的内存”如果不手动释放，就会导致内存泄露，gc是无法回收这部分内存的。\n所以需要在finalize中用本地方法(native method)如free操作等，再使用gc方法。显示的GC方法是system.gc()\n```\n\n#### 垃圾回收技术\n- 方法一：引用计数法。简单但速度很慢。缺陷是：不能处理循环引用的情况。\n- 方法二：停止-复制(stop and copy)。效率低，需要的空间大，优点，不会产生碎片。\n- 方法三：标记 - 清除算法 (mark and sweep)。速度较快，占用空间少，标记清除后会产生大量的碎片。\n\n> JAVA虚拟机中是如何做的？\n```\njava的做法很聪明，我们称之为\"自适应\"的垃圾回收器，或者是\"自适应的、分代的、停止-复制、标记-清扫\"式垃圾回收器。它会根据不同的环境和需要选择不同的处理方式。\n```\n\n#### heap组成\n> 由于GC需要消耗一些资源和时间的，Java在对对象的生命周期特征进行分析后，采用了分代的方式来进行对象的收集，即按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停.\nheap 的组成有三区域/世代：(可以理解随着时间，对象实例不断变换heap中的等级，有点像年级)\n>> 1. 新生代 Young Generation\n>>> 1. Eden Space 任何新进入运行时数据区域的实例都会存放在此\n>>> 2. S0 Suvivor Space 存在时间较长，经过垃圾回收没有被清除的实例，就从Eden 搬到了S0\n>>> 3. S1 Survivor Space 同理，存在时间更长的实例，就从S0 搬到了S1\n>>\n>> 2. 旧生代 Old Generation/tenured\n同理，存在时间更长的实例，对象多次回收没被清除，就从S1 搬到了tenured\n>>\n>> 3. Perm 存放运行时数据区的方法区\n>\n> Java 不同的世代使用不同的 GC 算法。\n1. Minor collection：\n新生代 Young Generation 使用将 Eden 还有 Survivor 内的数据利用 semi-space 做复制收集（Copying collection）， 并将原本 Survivor 内经过多次垃圾收集仍然存活的对象移动到 Tenured。\n>\n2. Major collection 则会进行 Minor collection，Tenured 世代则进行标记压缩收集。\n![](http://img.qiqinote.com/2017/8/25/dfcbfda8e9ec48539284508905571744.png)\n> 这个搬运工作都是GC 完成的，这也是garbage collector 的名字来源，而不是叫garbage cleaner. GC负责在heap中搬运实例，以及收回存储空间。\n\n#### GC工作原理\n> JVM 分别对新生代和旧生代采用不同的垃圾回收机制\n\n> 何为垃圾？\nJava中那些不可达的对象就会变成垃圾。那么什么叫做不可达？其实就是没有办法再引用到该对象了。主要有以下情况使对象变为垃圾：\n1. 对非线程的对象来说，所有的活动线程都不能访问该对象，那么该对象就会变为垃圾。\n2. 对线程对象来说，满足上面的条件，且线程未启动或者已停止。\n\n```\n例如： \n(1)改变对象的引用，如置为null或者指向其他对象。 \n   Object x=new Object();//object1 \n   Object y=new Object();//object2 \n   x=y;//object1 变为垃圾 \n   x=y=null;//object2 变为垃圾 \n\n(2)超出作用域 \n   if(i==0){ \n      Object x=new Object();//object1 \n   }//括号结束后object1将无法被引用，变为垃圾 \n(3)类嵌套导致未完全释放 \n   class A{ \n      A a; \n   } \n   A x= new A();//分配一个空间 \n   x.a= new A();//又分配了一个空间 \n   x=null;//将会产生两个垃圾 \n(4)线程中的垃圾 \n   class A implements Runnable{   \n     void run(){ \n       //.... \n     } \n   } \n   //main \n   A x=new A();//object1 \n   x.start(); \n   x=null;//等线程执行完后object1才被认定为垃圾 \n   这样看，确实在代码执行过程中会产生很多垃圾，不过不用担心，java可以有效地处理他们。\n```\n> JVM中将对象的引用分为了四种类型，不同的对象引用类型会造成GC采用不同的方法进行回收：\n1. 强引用：默认情况下，对象采用的均为强引用（GC不会回收）\n2. 软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）\n3. 弱引用：在GC时一定会被GC回收\n4. 虚引用：在GC时一定会被GC回收', '2', '0', '2017-08-25 12:03:58'), ('130', '1', '209', '\n中国近代史开端\n> 19世纪初期 英国发动侵略战争\n\n中国封建社会由盛转衰开始时间\n> 乾隆后期\n\n列强侵华五次战争\n![](http://img.qiqinote.com/2017/9/5/5aa7d9578f644bc9ae8d08b8d448b1b0.png)\n\n中国近代史最主要矛盾\n> 近代中国社会的矛盾有：封建主义和人民大众、帝国主义和中华民族。\n其中：帝国主义与中华民族 是最主要的矛盾\n\n太平天国\n> \n- 时间：1851.1 - 1864.7\n- 1853年冬颁布《天朝田亩制度》\n- 洪仁玕提出《资政新篇》\n\n洋务运动\n> \n- 镇压太平天国与外来入侵\n- 洋务代表人物：奕訢、曾国藩、李鸿章、左宗棠、张之洞。思想教父：冯桂芬\n- 兴办近代企业、建立新式海军、创办新式学堂\n\n> 失败原因\n甲午中日战争后失败，近30年\n>> \n- 具有封建性\n- 对西方具有依赖性\n- 管理腐朽性\n\n戊戌维新变法\n> \n- 代表人物：康有为、梁启超、谭嗣同、严复\n>> \n康有为：《新学伪经考》《孔子改制考》《人类公理》\n梁启超：《变法通义》\n谭嗣同：《仁学》\n严复：翻译了《天演论》\n> \n- 百日戊戌维新变法于1898年，只昙花一现实施了103天就宣告失败\n- 戊戌维新运动的意义\n>> - 是一次爱国救亡运动\n>> - 是资产阶级政治改革运动\n>> - 是一声思想启蒙运动\n>> - 改革社会风气有不可低估的意义\n- 失败原因及教训\n>> - 不敢否定封建主义\n>> - 对帝国主义抱有幻想\n>> - 脱离人民群众\n\n辛亥革命\n> 领导：孙中山\n>> \n- 1894年在檀香山组织了中国第一个资产阶级革命组织 -- 兴中会\n- 1904年发表《中国革命的真解决》强调推翻清政府，建立民国\n- 1905年成立中国第一个资产阶级革命性质政党 -- 同盟会', '2', '0', '2017-09-05 15:00:04'), ('131', '1', '210', '## 爱上备份系统\n\n[TOC]\n\n### 爱上备份系统备份数据导向\n\n- 图片、视频等文件数据\n\n|数据流向，由上到下|描述|\n|:-:\n|`106.3.138.172` 挂载glusterfs集群|挂载目录：`/data/lovetv_mount`|\n|⬇︎|\n|`106.3.138.172:/data/lovetv/`|定向备份数据到本地|\n\n- mysql数据\n\n|数据流向，由上到下|描述|\n|:-:\n|210.73.218.167|mysql主数据先流向从服务器|\n|⬇︎|\n|210.73.218.166|备服务器汇总mysql主从数据|\n|⬇︎|\n|106.3.138.172|`/data/backup/mysql`|\n\n- mongodb数据\n\n|数据流向，由上到下|描述|\n|:-:\n|210.73.218.169|mongodb集群数据导出到本地|\n|⬇︎|\n|106.3.138.172|`/data/backup/mongodb`|\n\n- redis数据\n\n|数据流向，由上到下|描述|\n|:-:\n|210.73.218.169|redis数据导出到本地|\n|⬇︎|\n|106.3.138.172|`/data/backup/redis`|\n\nps：\n- 数据备份都是用`rsync`同步，全部是用`crontab`执行脚本\n- 备份数据全部放于`/data/backup`目录，除图片视频等文件数据，但也都在`/data`\n\n### 外网备份系统\n> mysql、mongodb、redis等一系列服务与程序全部部署到`223.202.198.6`，数据来源于`106.3.138.172`\n\n### 内网备份系统\n> 内网数据来源于`223.202.198.6`\n\n||LVS|KeepAlived|Nginx|Tomcat|ChatServer|MySQL|Redis|Mongodb|ActiveMQ|GlusterFS|\n|-\n|10.10.10.242|√主|√主|--|--|--|--|--|--|--|--|\n|10.10.10.243|√从|√从|--|--|--|--|√主|√集群(仲裁者)|√集群|--|\n|10.10.10.244(1.8T)|--|--|√|√|√|--|--|--|--|√集群|\n|10.10.10.246|--|--|--|--|--|√主|√从|√集群|√集群|--|\n|10.10.10.247(1.8T)|--|--|√|√|√|--|--|--|--|√集群|\n|10.10.10.251|--|--|--|--|--|√从|--|√集群|√集群|--|', '2', '0', '2017-09-06 10:59:57'), ('132', '1', '212', '##### 公司地址\n```\n北京市朝阳区工体北路4号院 79 office 4层 410室\n```\n\n##### wifi\n```\nzg_new	zhugeio@）！%\n\nzg_new_5G	zhugeio@)!%\n```\n##### 翻墙\n```\nhttp://xduotai.com/7ThSVuH_A.pac\n\nexport http_proxy=http://duotai:7ThSVuH_A@team.h.xduotai.com:16433 \nexport https_proxy=$http_proxy \n\n```\n##### 邮箱\n```\nzoufanqi@zhugeio.com\n```\n', '2', '0', '2017-09-14 09:54:15'), ('133', '1', '213', '\n- 面向对象的核心三大块\n> 封装、继承、多态\n\n- Java八大基本类型\n> short、int、long、float、double、byte、boolean、char\n> String 不是基本类型\n\n- int与Integer区别\n> 基本类型与包装类\n\n- & 与 &&、| 与 || 会经常在基础题中考\n\n- ArrayList 与 LinkedList 底层数据模型以及它们的应用场景？\n> ArrayList：数组  LinkedList：链表\n\n- HashMap 与 TreeMap 底层实现以及它们的应用场景？\n> HashMap：数组+链表  TreeMap：红黑树\n\n- HashMap中的put()方法得大致了解\n\n- ConcurrentHashMap、HashMap、Hashtable 区别？\n\n- 如何让一个集合类（如：HashMap）\n\n- 堆、栈 数据结构？\n> 堆：先进先出  栈：先进后出\n\n- JVM 如何调优？（这问题很广，但会问）\n\n- 说说Java的类加载\n\n- 多线程实现方法？\n> 1、继承Thread  2、实现Runnable\n\n- 同步的方法\n> synchronized、Lock\n\n- 死锁的产生条件？如何避免死锁？\n\n- NIO、BIO\n\n- 常用排序算法（冒泡一定要会代码实现，其它了解）\n\n- Servlet的生命同期\n\n- 简述Spring\n> 从它的作用，到它主要实现场景（AOP、IOC），再到它底层主要运用（反射+动态代理）\n\n- Spring 的 scope\n\n- Spring 与 SpringMVC 的区别\n\n- mybatis 中 #与$ 的区别\n\n- 数据库四大事务、事务隔离级别\n\n- 数据库行锁、块锁、表锁（主要对照InnoDB引擎）\n\n- 乐观锁与悲观锁\n\n- 项目运用的框架并简述框架作用与实现\n\n- 项目中有哪些比较棘手的问题，你是怎么解决的？\n\n- 平时是怎么接触一个新技术并如何掌握它？\n\n', '2', '0', '2017-09-15 10:07:35'), ('134', '1', '215', '```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\nLicensed to the Apache Software Foundation (ASF) under one\nor more contributor license agreements.  See the NOTICE file\ndistributed with this work for additional information\nregarding copyright ownership.  The ASF licenses this file\nto you under the Apache License, Version 2.0 (the\n\"License\"); you may not use this file except in compliance\nwith the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied.  See the License for the\nspecific language governing permissions and limitations\nunder the License.\n-->\n\n<!--\n | This is the configuration file for Maven. It can be specified at two levels:\n |\n |  1. User Level. This settings.xml file provides configuration for a single user, \n |                 and is normally provided in ${user.home}/.m2/settings.xml.\n |\n |                 NOTE: This location can be overridden with the CLI option:\n |\n |                 -s /path/to/user/settings.xml\n |\n |  2. Global Level. This settings.xml file provides configuration for all Maven\n |                 users on a machine (assuming they\'re all using the same Maven\n |                 installation). It\'s normally provided in \n |                 ${maven.home}/conf/settings.xml.\n |\n |                 NOTE: This location can be overridden with the CLI option:\n |\n |                 -gs /path/to/global/settings.xml\n |\n | The sections in this sample file are intended to give you a running start at\n | getting the most out of your Maven installation. Where appropriate, the default\n | values (values used when the setting is not specified) are provided.\n |\n |-->\n<settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" \n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n          xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\">\n  <!-- localRepository\n   | The path to the local repository maven will use to store artifacts.\n   |\n   | Default: ${user.home}/.m2/repository\n  <localRepository>/path/to/local/repo</localRepository>\n  -->\n  <!-- interactiveMode\n   | This will determine whether maven prompts you when it needs input. If set to false,\n   | maven will use a sensible default value, perhaps based on some other setting, for\n   | the parameter in question.\n   |\n   | Default: true\n  <interactiveMode>true</interactiveMode>\n  -->\n\n  <!-- offline\n   | Determines whether maven should attempt to connect to the network when executing a build.\n   | This will have an effect on artifact downloads, artifact deployment, and others.\n   |\n   | Default: false\n  <offline>false</offline>\n  -->\n\n  <!-- pluginGroups\n   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.\n   | when invoking a command line like \"mvn prefix:goal\". Maven will automatically add the group identifiers\n   | \"org.apache.maven.plugins\" and \"org.codehaus.mojo\" if these are not already contained in the list.\n   |-->\n  <pluginGroups>\n    <!-- pluginGroup\n     | Specifies a further group identifier to use for plugin lookup.\n    <pluginGroup>com.your.plugins</pluginGroup>\n    -->\n	<pluginGroup>org.springframework.boot</pluginGroup>\n  </pluginGroups>\n\n  <!-- proxies\n   | This is a list of proxies which can be used on this machine to connect to the network.\n   | Unless otherwise specified (by system property or command-line switch), the first proxy\n   | specification in this list marked as active will be used.\n   |-->\n  <proxies>\n    <!-- proxy\n     | Specification for one proxy, to be used in connecting to the network.\n     |\n    <proxy>\n      <id>optional</id>\n      <active>true</active>\n      <protocol>http</protocol>\n      <username>proxyuser</username>\n      <password>proxypass</password>\n      <host>proxy.host.net</host>\n      <port>80</port>\n      <nonProxyHosts>local.net|some.host.com</nonProxyHosts>\n    </proxy>\n	-->\n  </proxies>\n\n  <!-- servers\n   | This is a list of authentication profiles, keyed by the server-id used within the system.\n   | Authentication profiles can be used whenever maven must make a connection to a remote server.\n   |-->\n  <servers>\n    <!-- server\n     | Specifies the authentication information to use when connecting to a particular server, identified by\n     | a unique name within the system (referred to by the \'id\' attribute below).\n     | \n     | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are \n     |       used together.\n     |\n    <server>\n      <id>deploymentRepo</id>\n      <username>repouser</username>\n      <password>repopwd</password>\n    </server>\n    -->\n    \n    <!-- Another sample, using keys to authenticate.\n    <server>\n      <id>siteServer</id>\n      <privateKey>/path/to/private/key</privateKey>\n      <passphrase>optional; leave empty if not used.</passphrase>\n    </server>\n    -->\n<server>\n	<id>zhugeio</id>\n	<username>admin</username>\n	<password>admin123</password>\n</server>\n<!-- <server>\n        <id>37degree</id>\n        <username>deployment</username>\n        <password>37degree141110!$!</password>  \n	</server>-->\n  </servers>\n\n  <!-- mirrors\n   | This is a list of mirrors to be used in downloading artifacts from remote repositories.\n   | \n   | It works like this: a POM may declare a repository to use in resolving certain artifacts.\n   | However, this repository may have problems with heavy traffic at times, so people have mirrored\n   | it to several places.\n   |\n   | That repository definition will have a unique id, so we can create a mirror reference for that\n   | repository, to be used as an alternate download site. The mirror site will be the preferred \n   | server for that repository.\n   |-->\n  <mirrors>\n    <!-- mirror\n     | Specifies a repository mirror site to use instead of a given repository. The repository that\n     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used\n     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.\n     |\n    <mirror>\n      <id>mirrorId</id>\n      <mirrorOf>repositoryId</mirrorOf>\n      <name>Human Readable Name for this Mirror.</name>\n      <url>http://my.repository.com/repo/path</url>\n    </mirror>\n     <mirror>\n        <id>37degree</id>\n        <name>37degree repository</name>\n        <url>http://maven.37degree.com/nexus/content/groups/com.37degree/</url> \n        <mirrorOf>*</mirrorOf> \n     </mirror>\n<mirror>\n      <id>central_mirror</id>\n      <name>internal central_mirror epository</name>\n      <url>http://repo1.maven.org/maven2/</url>\n      <mirrorOf>central</mirrorOf>    \n</mirror>\n<mirror>  \n      <id>repo2</id>  \n      <mirrorOf>central</mirrorOf>  \n      <name>Human Readable Name for this Mirror.</name>  \n      <url>http://repo2.maven.org/maven2/</url>  \n    </mirror>  \n<mirror>  \n      <id>net-cn</id>  \n      <mirrorOf>central</mirrorOf>  \n      <name>Human Readable Name for this Mirror.</name>  \n      <url>http://maven.net.cn/content/groups/public/</url>   \n    </mirror>  \n<mirror>  \n      <id>ui</id>  \n      <mirrorOf>central</mirrorOf>  \n      <name>Human Readable Name for this Mirror.</name>  \n     <url>http://uk.maven.org/maven2/</url>  \n    </mirror>  \n<mirror>  \n      <id>ibiblio</id>  \n      <mirrorOf>central</mirrorOf>  \n      <name>Human Readable Name for this Mirror.</name>  \n     <url>http://mirrors.ibiblio.org/pub/mirrors/maven2/</url>  \n    </mirror>  \n<mirror>  \n      <id>jboss-public-repository-group</id>  \n      <mirrorOf>central</mirrorOf>  \n      <name>JBoss Public Repository Group</name>  \n     <url>http://repository.jboss.org/nexus/content/groups/public</url>  \n	</mirror>\n	<mirror>\n			<id>apache.nexus</id>\n			<mirrorOf>central</mirrorOf>\n		   <name>ASF Nexus Staging</name>\n           <url>https://repository.apache.org/content/groups/staging/</url>\n	</mirror>-->\n    <mirror>\n        <id>central</id>\n        <mirrorOf>*</mirrorOf>\n        <name>central-mirror</name>\n        <url>http://gl.zhugeio.com:8081/nexus/content/groups/public/</url>\n	</mirror>\n	<mirror>\n		<id>apache.nexus</id>\n		<name>ASF Nexus Staging</name>\n		<mirrorOf>*</mirrorOf>\n		<url>https://repository.apache.org/content/groups/staging/</url>\n	</mirror>\n\n</mirrors>\n  \n  <!-- profiles\n   | This is a list of profiles which can be activated in a variety of ways, and which can modify\n   | the build process. Profiles provided in the settings.xml are intended to provide local machine-\n   | specific paths and repository locations which allow the build to work in the local environment.\n   |\n   | For example, if you have an integration testing plugin - like cactus - that needs to know where\n   | your Tomcat instance is installed, you can provide a variable here such that the variable is \n   | dereferenced during the build process to configure the cactus plugin.\n   |\n   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles\n   | section of this document (settings.xml) - will be discussed later. Another way essentially\n   | relies on the detection of a system property, either matching a particular value for the property,\n   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a \n   | value of \'1.4\' might activate a profile when the build is executed on a JDK version of \'1.4.2_07\'.\n   | Finally, the list of active profiles can be specified directly from the command line.\n   |\n   | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact\n   |       repositories, plugin repositories, and free-form properties to be used as configuration\n   |       variables for plugins in the POM.\n   |\n   |-->\n<!--   <profiles>\n -->     \n <profiles>\n    <!-- profile\n     | Specifies a set of introductions to the build process, to be activated using one or more of the\n     | mechanisms described above. For inheritance purposes, and to activate profiles via <activatedProfiles/>\n     | or the command line, profiles have to have an ID that is unique.\n     |\n     | An encouraged best practice for profile identification is to use a consistent naming convention\n     | for profiles, such as \'env-dev\', \'env-test\', \'env-production\', \'user-jdcasey\', \'user-brett\', etc.\n     | This will make it more intuitive to understand what the set of introduced profiles is attempting\n     | to accomplish, particularly when you only have a list of profile id\'s for debug.\n     |\n     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.\n    <profile>\n      <id>jdk-1.4</id>\n\n      <activation>\n        <jdk>1.4</jdk>\n      </activation>\n\n      <repositories>\n        <repository>\n          <id>jdk14</id>\n          <name>Repository for JDK 1.4 builds</name>\n          <url>http://www.myhost.com/maven/jdk14</url>\n          <layout>default</layout>\n          <snapshotPolicy>always</snapshotPolicy>\n        </repository>\n      </repositories>\n    </profile>\n    -->\n       <profile>         \n            <id>jdk-1.8</id>         \n            <activation>         \n                <activeByDefault>true</activeByDefault>         \n                <jdk>1.8</jdk>         \n            </activation>         \n            <properties>         \n                <maven.compiler.source>1.8</maven.compiler.source>         \n                <maven.compiler.target>1.8</maven.compiler.target>         \n                <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>         \n            </properties>         \n    </profile>        \n</profiles>    \n    <!--\n     | Here is another profile, activated by the system property \'target-env\' with a value of \'dev\',\n     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration\n     | might hypothetically look like:\n     |\n     | ...\n     | <plugin>\n     |   <groupId>org.myco.myplugins</groupId>\n     |   <artifactId>myplugin</artifactId>\n     |   \n     |   <configuration>\n     |     <tomcatLocation>${tomcatPath}</tomcatLocation>\n     |   </configuration>\n     | </plugin>\n     | ...\n     |\n     | NOTE: If you just wanted to inject this configuration whenever someone set \'target-env\' to\n     |       anything, you could just leave off the <value/> inside the activation-property.\n     |\n    <profile>\n      <id>env-dev</id>\n\n      <activation>\n        <property>\n          <name>target-env</name>\n          <value>dev</value>\n        </property>\n      </activation>\n\n      <properties>\n        <tomcatPath>/path/to/tomcat/instance</tomcatPath>\n      </properties>\n    </profile>\n    -->\n  <!-- </profiles> -->\n\n  <!-- activeProfiles\n   | List of profiles that are active for all builds.\n   |\n  <activeProfiles>\n    <activeProfile>alwaysActiveProfile</activeProfile>\n    <activeProfile>anotherAlwaysActiveProfile</activeProfile>\n  </activeProfiles>\n  -->\n</settings>\n\n```', '2', '0', '2017-09-15 12:04:03');
INSERT INTO `note_detail` VALUES ('135', '1', '214', '```\napi/sdkv   rs.master -> zoufanqi\napi   real.kpt.master -> real.kpt.master.zoufanqi\n```\n\n```\nhi,凡奇：\n       你好，已为你开通跳板机登录账号，信息如下：\n    ip：    103.17.40.176\n    port：3344 \n    user：zoufanqi\n备注： 不需要密码，服务器上已添加上你的公钥\n \n测试环境登录权限开通：\n      在你跳板机用户下已打通与test3服务器和实时测试服务器的登录通道，可直接登录，登录方式为： \n  test3：     ssh test3  \n  实时测试： ssh realtime-1\n备注： 登录后都为centos用户，可sudo su - 切换为root  \n```\n\n```\ngit@gl.zhugeio.com:server/zhugeio-api.git\ngit@gl.zhugeio.com:tangxingcai/zhugesdkv.git\ngit@gl.zhugeio.com:dongyongqiang/webapp-publish.git\ngit@gl.zhugeio.com:hebin/user-behavior-path-analysis.git\ngit@gl.zhugeio.com:server/behaviorpath.git\n```', '2', '0', '2017-09-15 17:33:44'), ('136', '1', '216', '- docker ps\n> 查看正在运行docker列表\n\n- docker ps -a\n> 查看全部docker列表\n\n- docker exec -it `names` bash\n> 进入某个docker，name为docker的名称\n\n-  docker inspect `names`\n> 查看配置\n\n- docker restart `names`\n> 重启\n\n- 创建服务：`java -jar zhugesdkv_sem_job.jar`\n\n```\ndocker run -i -t -d --name zhugeio_normal_sem -v /data/zhugeio_normal_sem/:/zhuge -e LC_ALL=\"en_US.UTF-8\" zgio/jdk8:v1  /usr/bin/java -jar /zhuge/zhugesdkv_sem_job.jar\n\n-- 以下为有端口映射的\ndocker run -d -p 0.0.0.0:7810:4443 -p 0.0.0.0:8090:8080 -t -i  --name=\"zhugeio_balance_1\" -v /data/localization/tomcat/web:/zhuge -e LC_ALL=\"en_US.UTF-8\" zgio/jdk8:v1 /zhuge/tomcat.1/bin/catalina.sh run\n\ndocker run -d -p 0.0.0.0:7811:4443 -p 0.0.0.0:8091:8080 -t -i  --name=\"zhugeio_api_1\" -v /data/localization/tomcat/api:/zhuge -e LC_ALL=\"en_US.UTF-8\" zgio/jdk8:v1 /zhuge/tomcat.1/bin/catalina.sh run\n```', '2', '0', '2017-09-15 18:20:38'), ('137', '1', '217', '```\n20170619	大哥大	支付宝	10000\n20170918	小兵叔叔	微信	10000\n\n```', '2', '0', '2017-09-18 14:09:40'), ('138', '1', '218', '- ab\n> ab -n 1000 -c 10 url\n>> -n 总请求数\n-c 并发数\n\n- http_load\n> http_load -f 1000 -p 10 urls.txt\n>> -f 总请求数\n-p 并发数', '2', '0', '2017-09-18 15:05:01'), ('139', '1', '222', '### 1. 安装Arc\n#### 1.1 安装Arcanist\n```\n$ mkdir somewhere/\n$ cd somewhere/\nsomewhere/ $ git clone https://github.com/phacility/libphutil.git\nsomewhere/ $ git clone https://github.com/phacility/arcanist.git\n```\n#### 1.2 修改环境变量\n```\n$ vi ~/.bash_profile\n添加：\nexport PATH=\"$PATH:/somewhere/arcanist/bin/\"\n\n$ source ~/.bash_profile\n```\n\n### 2. 配置项目与命令使用\n#### 2.1 添加配置文件\n在项目工作目录下创建配置文件 `.arcconfig`\n```\n$ cd yourproject/\nyourproject/ $ vi .arcconfig\nyourproject/ $ cat .arcconfig\n{\n  \"phabricator.uri\" : \"https://ph.zhugeio.com/\"\n}\n```\n\n#### 2.2 安装Arcanist证书\n```\n$ cd yourproject/\nyourproject/ $ arc install-certificate\n\n执行安装证书命令\n```\n![](http://img.qiqinote.com/2017/9/25/dd3dc1a5fbc343a79d6b58fd1807ed23.png)\n![](http://img.qiqinote.com/2017/9/25/be4d50759ee04ddea7ea0d1f26e76121.png)\n![](http://img.qiqinote.com/2017/9/25/ee7e29db51e046f998a1741b1404ea83.png)\n![](http://img.qiqinote.com/2017/9/25/12da68834da9438c94bb7bdb33ce95b3.png)\n![](http://img.qiqinote.com/2017/9/25/a92f384a1c4c4bbab013717ad6243ae3.png)\n![](http://img.qiqinote.com/2017/9/25/8a008a9a28014c00b4cb17b3df297daa.png)', '2', '0', '2017-09-25 12:09:27'), ('140', '1018', '224', '### HTML&CSS\n\n###### **1. 常用那几种浏览器测试？有哪些内核(Layout Engine)?****1. 常用那几种浏览器测试？有哪些内核(Layout Engine)?**\n(Q1)浏览器：IE，Chrome，FireFox，Safari，Opera。\n(Q2)内核：Trident，Gecko，Presto，Webkit。\n###### **2.说下行内元素和块级元素的区别？行内块元素的兼容性使用？**（IE8 以下）\n(Q1)行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。\n块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。\n(Q2)兼容性：display:inline-block;*display:inline;*zoom:1;\n###### **3.清除浮动有哪些方式？比较好的方式是哪一种？**\n(Q1)\n（1）父级div定义height。\n（2）结尾处加空div标签clear:both。\n（3）父级div定义伪类:after和zoom。\n（4）父级div定义overflow:hidden。\n（5）父级div定义overflow:auto。\n（6）父级div也浮动，需要定义宽度。\n（7）父级div定义display:table。\n（8）结尾处加br标签clear:both。\n(Q2)比较好的是第3种方式，好多网站都这么用。\n###### **4.box-sizing常用的属性有哪些？分别有什么作用？**\n(Q1)box-sizing: content-box|border-box|inherit;\n(Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。\nborder-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。\n###### **5.Doctype作用？标准模式与兼容模式各有什么区别?**\n(Q1)<!DOCTYPE>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。\n(Q2)标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。\n###### **6.HTML5 为什么只需要写 <!DOCTYPE HTML>？**\nHTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。\n而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。\n###### **7.页面导入样式时，使用link和@import有什么区别？**\n（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;\n（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;\n（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;\n###### **8.介绍一下你对浏览器内核的理解？**\n主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。\n渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\nJS引擎则：解析和执行javascript来实现网页的动态效果。\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n###### **9.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？****9.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？**\n（Q1） \nHTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n(1)绘画 canvas;\n(2)用于媒介回放的 video 和 audio 元素;\n(3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\n(4)sessionStorage 的数据在浏览器关闭后自动删除;\n(5)语意化更好的内容元素，比如 article、footer、header、nav、section;\n(6)表单控件，calendar、date、time、email、url、search;\n(7)新的技术webworker, websocket, Geolocation;\n(Q2)\nIE8/IE7/IE6支持通过document.createElement方法产生的标签，\n可以利用这一特性让这些浏览器支持HTML5新标签，\n浏览器支持新标签后，还需要添加标签默认的样式。\n当然也可以直接使用成熟的框架、比如html5shim;\n```javascript\n<script> \nsrc=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"\n</script>\n```\n###### **10.简述一下你对HTML语义化的理解？**\n用正确的标签做正确的事情。\nhtml语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;\n搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;\n使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n\n### JavaScript\n\n###### 1.介绍js的基本数据类型\nUndefined、Null、Boolean、Number、String\n###### 2.js有哪些内置对象？\n数据封装类对象：Object、Array、Boolean、Number 和 String\n其他对象：Function、Arguments、Math、Date、RegExp、Error\n###### 3.this对象的理解\nthis总是指向函数的直接调用者（而非间接调用者）；\n如果有new关键字，this指向new出来的那个对象；\n在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；\n###### 4.eval是做什么的？\n它的功能是把对应的字符串解析成JS代码并运行；\n应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。\n由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(\'(\'+ str +\')\');\n###### 5.DOM怎样添加、移除、移动、复制、创建和查找节点\n```javascript\n// 创建新节点\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n// 添加、移除、替换、插入\nappendChild()\nremoveChild()\nreplaceChild()\ninsertBefore() //在已有的子节点前插入一个新的子节点\n// 查找\ngetElementsByTagName()    //通过标签名称\ngetElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)\ngetElementById()    //通过元素Id，唯一性\n```\n\n###### 6.null和undefined的区别？\nnull是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。\nundefined：\n（1）变量被声明了，但没有赋值时，就等于undefined。\n（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n（3）对象没有赋值的属性，该属性的值为undefined。\n（4）函数没有返回值时，默认返回undefined。\nnull：\n（1） 作为函数的参数，表示该函数的参数不是对象。\n（2） 作为对象原型链的终点。\n###### 7.new操作符具体干了什么呢?\n（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n（2）属性和方法被加入到 this 引用的对象中。\n（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n###### 8.JSON 的了解？\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。\n格式：采用键值对，例如：{\'age\':\'12\', \'name\':\'back\'}\n###### 9.call() 和 apply() 的区别和作用？\napply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。\n如：function.apply(this,[1,2,3]);\ncall()的第一个参数是上下文，后续是实例传入的参数序列。\n如：function.call(this,1,2,3);\n###### 10.如何获取UA？\n```javascript\n function whatBrowser() {  \n	 document.Browser.Name.value=navigator.appName;  \n	 document.Browser.Version.value=navigator.appVersion;  \n	 document.Browser.Code.value=navigator.appCodeName;  \n	 document.Browser.Agent.value=navigator.userAgent;  \n }  \n```\n\n\n### 其他\n\n###### 1.HTTP状态码知道哪些？\n100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n200  OK   正常返回信息\n201  Created  请求成功并且服务器创建了新的资源\n202  Accepted  服务器已接受请求，但尚未处理\n301  Moved Permanently  请求的网页已永久移动到新位置。\n302 Found  临时性重定向。\n303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。\n304  Not Modified  自从上次请求后，请求的网页未修改过。\n400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n401 Unauthorized  请求未授权。\n403 Forbidden  禁止访问。\n404 Not Found  找不到如何与 URI 相匹配的资源。\n500 Internal Server Error  最常见的服务器端错误。\n503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n###### 2.你有哪些性能优化的方法？\n（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\n（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\n（4） 当需要设置的样式很多时设置className而不是直接操作style。\n（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。\n（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。\n（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。\n###### 3.什么叫优雅降级和渐进增强？\n优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.\n渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。\n###### 4.哪些常见操作会造成内存泄漏？\n内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。\n垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。\nsetTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n###### 5.线程与进程的区别\n一个程序至少有一个进程,一个进程至少有一个线程. \n线程的划分尺度小于进程，使得多线程程序的并发性高。 \n另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 \n线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 \n从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。', '2', '0', '2017-09-27 10:49:42'), ('141', '1018', '225', '### HTML&CSS\n\n###### 1.请描述一下 cookies，sessionStorage 和 localStorage 的区别？\ncookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。\ncookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\nsessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n存储大小：\ncookie数据大小不能超过4k。\nsessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n有期时间：\nlocalStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\nsessionStorage  数据在当前浏览器窗口关闭后自动删除。\ncookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n###### 2.iframe有那些缺点？\niframe会阻塞主页面的Onload事件；\n搜索引擎的检索程序无法解读这种页面，不利于SEO;\niframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。\n###### 3.如何实现浏览器内多个标签页之间的通信?\nWebSocket、SharedWorker\n也可以调用localstorge、cookies等本地存储方式。\nlocalstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。\n注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常。\n###### 4.如何在页面上实现一个圆形的可点击区域？\n（1）map+area或者svg\n（2）border-radius\n（3）纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等\n###### 5.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n（1）有两种， IE 盒子模型、W3C 盒子模型。\n（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)。\n（3）区  别： IE的content部分把 border 和 padding计算了进去。\n###### 6.CSS优先级算法如何计算？\n优先级就近原则，同权重情况下样式定义最近者为准;\n载入样式以最后载入的定位为准;\n优先级为:\n!important >  id > class > tag\nimportant比内联优先级高(style)\n###### 7.为什么要使用CSS sprites\nCSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background-position”的组合进行背景定位，这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是如果请求太多会给服务器增加很大的压力。\n###### 8.display:none和visibility:hidden的区别？\ndisplay:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\nvisibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n###### 9.position的absolute与fixed区别\nabsolute浮动定位是相对于父级中设置position为relative或者absolute最近的父级元素\nfixed浮动定位是相对于浏览器视窗的\n###### 10.IE 8以下版本的浏览器中的盒模型有什么不同？\nIE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框\n\n### JavaScript\n###### 1.JS数组去重\n以下是展示三种方法：\n```javascript\nArray.prototype.unique1 = function () {\n  var n = []; //一个新的临时数组\n  for (var i = 0; i < this.length; i++) //遍历当前数组\n  {\n    //如果当前数组的第i已经保存进了临时数组，那么跳过，\n    //否则把当前项push到临时数组里面\n    if (n.indexOf(this[i]) == -1) n.push(this[i]);\n  }\n  return n;\n}\n\nArray.prototype.unique2 = function()\n{\n    var n = {},r=[]; //n为hash表，r为临时数组\n    for(var i = 0; i < this.length; i++) //遍历当前数组\n    {\n        if (!n[this[i]]) //如果hash表中没有当前项\n        {\n            n[this[i]] = true; //存入hash表\n            r.push(this[i]); //把当前数组的当前项push到临时数组里面\n        }\n    }\n    return r;\n}\n\nArray.prototype.unique3 = function()\n{\n    var n = [this[0]]; //结果数组\n    for(var i = 1; i < this.length; i++) //从第二项开始遍历\n    {\n        //如果当前数组的第i项在当前数组中第一次出现的位置不是i，\n        //那么表示第i项是重复的，忽略掉。否则存入结果数组\n        if (this.indexOf(this[i]) == i) n.push(this[i]);\n    }\n    return n;\n}\n```\n\n###### 2.js操作获取和设置cookie\n```javascript\n//创建cookie\nfunction setCookie(name, value, expires, path, domain, secure) {\n    var cookieText = encodeURIComponent(name) + \'=\' + encodeURIComponent(value);\n    if (expires instanceof Date) {\n        cookieText += \'; expires=\' + expires;\n    }\n    if (path) {\n        cookieText += \'; expires=\' + expires;\n    }\n    if (domain) {\n        cookieText += \'; domain=\' + domain;\n    }\n    if (secure) {\n        cookieText += \'; secure\';\n    }\n    document.cookie = cookieText;\n}\n\n//获取cookie\nfunction getCookie(name) {\n    var cookieName = encodeURIComponent(name) + \'=\';\n    var cookieStart = document.cookie.indexOf(cookieName);\n    var cookieValue = null;\n    if (cookieStart > -1) {\n        var cookieEnd = document.cookie.indexOf(\';\', cookieStart);\n        if (cookieEnd == -1) {\n            cookieEnd = document.cookie.length;\n        }\n        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));\n    }\n    return cookieValue;\n}\n\n//删除cookie\nfunction unsetCookie(name) {\n    document.cookie = name + \"= ; expires=\" + new Date(0);\n}\n```\n\n###### 3.ajax 有那些优缺点?如何解决跨域问题?\n（Q1）\n优点：\n（1）通过异步模式，提升了用户体验.\n（2）优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\n（3）Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\n（4）Ajax可以实现动态不刷新（局部刷新）\n缺点：\n（1）安全问题 AJAX暴露了与服务器交互的细节。\n（2）对搜索引擎的支持比较弱。\n（3）不容易调试。\n（Q2）jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面。\n###### 4.JavaScript原型，原型链 ? 有什么特点？\n（1）原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。\n（2）原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。\n###### 5.GET和POST的区别，何时使用POST？\nGET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符\nPOST：一般用于修改服务器上的资源，对所发送的信息没有限制。\nGET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，\n也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\n然而，在以下情况中，请使用 POST 请求：\n无法使用缓存文件（更新服务器上的文件或数据库）\n向服务器发送大量数据（POST 没有数据量限制）\n发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n###### 6.请解释一下 JavaScript 的同源策略\n概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。\n这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。\n指一段脚本只能读取来自同一来源的窗口和文档的属性。\n为什么要有同源限制？\n我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。\n###### 7.Flash、Ajax各自的优缺点，在使用中如何取舍？\nFlash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。\nAjax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。\n共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM\n###### 8.什么是闭包？\n闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点：\n（1）作为一个函数变量的一个引用，当函数返回时，其处于激活状态。\n（2） 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。\n简单的说，Javascript允许使用内部函数---即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。\n###### 9.javascript里面的继承怎么实现，如何避免原型链上面的对象共享\n用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量\n###### 10.ajax过程\n(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.\n(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.\n(3)设置响应HTTP请求状态变化的函数.\n(4)发送HTTP请求.\n(5)获取异步调用返回的数据.\n(6)使用JavaScript和DOM实现局部刷新.\n\n### 其他\n\n###### 1.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？\n（1）查找浏览器缓存\n（2）DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求\n（3）进行HTTP协议会话\n（4）客户端发送报头(请求报头)\n（5）服务器回馈报头(响应报头)\n（6）html文档开始下载\n（7）文档树建立，根据标记请求所需指定MIME类型的文件\n（8）文件显示\n###### 2.为什么换工作？\n###### 3.你常用的开发工具是什么，为什么？\n###### 4.对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？\n###### 5.加班的看法？', '2', '0', '2017-09-27 10:54:26'), ('142', '1018', '226', '### HTML相关问题\n\n##### 1.XHTML和HTML有什么区别\n\nHTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言\n最主要的不同：\nXHTML 元素必须被正确地嵌套。\nXHTML 元素必须被关闭。\n标签名必须用小写字母。\nXHTML 文档必须拥有根元素。\n##### 2.什么是语义化的HTML?\n\n直观的认识标签 对于搜索引擎的抓取有好处，用正确的标签做正确的事情！\nhtml语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；\n在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。\n使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n##### 3.常见的浏览器内核有哪些？\nTrident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\nPresto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]\n##### 4.HTML5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？\n\nHTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n绘画 canvas\n用于媒介回放的 video 和 audio 元素\n本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\nsessionStorage 的数据在浏览器关闭后自动删除\n语意化更好的内容元素，比如 article、footer、header、nav、section\n表单控件，calendar、date、time、email、url、search\n新的技术webworker, websockt, Geolocation\n移除的元素\n纯表现的元素：basefont，big，center，font, s，strike，tt，u；\n对可用性产生负面影响的元素：frame，frameset，noframes；\n支持HTML5新标签：\nIE8/IE7/IE6支持通过document.createElement方法产生的标签，\n可以利用这一特性让这些浏览器支持HTML5新标签，\n浏览器支持新标签后，还需要添加标签默认的样式：\n##### 5.请描述一下 cookies，sessionStorage 和 localStorage 的区别？\n\ncookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会\nsessionStorage和localStorage的存储空间更大；\nsessionStorage和localStorage有更多丰富易用的接口；\nsessionStorage和localStorage各自独立的存储空间；\n##### 6.如何实现浏览器内多个标签页之间的通信?\n\n调用localstorge、cookies等本地存储方式\n##### 7.HTML5 为什么只需要写 !DOCTYPE HTML？\n\nHTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。\n##### 8.Doctype作用？标准模式与兼容模式各有什么区别?\n\n!DOCTYPE声明位于位于HTML文档中的第一行，处于html 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。\n标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。\n##### 9.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?\n用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档。\n加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的Bug。\n\n##### 10.请描述一下 cookies，sessionStorage 和 localStorage 的区别？\n\ncookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会\nsessionStorage和localStorage的存储空间更大；\nsessionStorage和localStorage有更多丰富易用的接口；\nsessionStorage和localStorage各自独立的存储空间；\n##### 11.如何实现浏览器内多个标签页之间的通信?\n\n调用localstorge、cookies等本地存储方式\n\n\n### CSS相关问题\n\n##### 1.CSS实现垂直水平居中\n\n一道经典的问题，实现方法有很多种，以下是其中一种实现：\nHTML结构：\n```html\n<div class=\"wrapper\">\n    <div class=\"content\"></div>\n</div>\n\nCSS：\n\n.wrapper{position:relative;}\n    .content{\n        background-color:#6699FF;\n        width:200px;\n        height:200px;\n        position: absolute;        //父元素需要相对定位\n        top: 50%;\n        left: 50%;\n        margin-top:-100px ;   //二分之一的height，width\n        margin-left: -100px;\n    }\n```\n\n##### 2.display有哪些值？说明他们的作用。\n\nblock         块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\n  none          缺省值。象行内元素类型一样显示。\n  inline        行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。\n  inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。\n  list-item     象块类型元素一样显示，并添加样式列表标记。\n  table         此元素会作为块级表格来显示。\n  inherit       规定应该从父元素继承 display 属性的值。\n\n##### 3.行内元素有哪些?块级元素有哪些?CSS的盒模型?\n块级元素：div,p,h1,form,ul,li;\n行内元素 : span>,a,label,input,img,strong,em;\nCSS盒模型:内容，border ,margin，padding\n\n##### 4.CSS引入的方式有哪些? link和@import的区别是?\n内联 内嵌 外链 导入\n区别 ：同时加载\n前者无兼容性，后者CSS2.1以下浏览器不支持\nLink 支持使用javascript改变样式，后者不可\n\n##### 5.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?\n标签选择符 类选择符 id选择符\n继承不如指定 Id>class>标签选择\n后者优先级高\n\n##### 6.CSS清除浮动的几种方法（至少两种）\n\n使用带clear属性的空元素\n使用CSS的overflow属性；\n使用CSS的:after伪元素；\n使用邻接元素处理；\n##### 7.CSS居中（包括水平居中和垂直居中）\n\n内联元素居中方案\n水平居中设置：\n1.行内元素\n设置 text-align:center；\n2.Flex布局\n设置display:flex;justify-content:center;(灵活运用,支持Chroime，Firefox，IE9+)\n\n垂直居中设置：\n1.父元素高度确定的单行文本（内联元素）\n设置 height = line-height；\n2.父元素高度确定的多行文本（内联元素）\na:插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle；\nb:先设置 display:table-cell 再设置 vertical-align:middle；\n块级元素居中方案\n\n水平居中设置：\n1.定宽块状元素\n设置 左右 margin 值为 auto；\n2.不定宽块状元素\na:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto；\nb:给该元素设置 displa:inine 方法；\nc:父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%；\n\n垂直居中设置：\n使用position:absolute（fixed）,设置left、top、margin-left、margin-top的属性;\n利用position:fixed（absolute）属性，margin:auto这个必须不要忘记了;\n利用display:table-cell属性使内容垂直居中;\n使用css3的新属性transform:translate(x,y)属性;\n使用:before元素;\n\n##### 8.在书写高效 CSS 时会有哪些问题需要考虑？8.在书写高效 CSS 时会有哪些问题需要考虑？\nreset。参照上题“描述下 “reset” CSS 文件的作用和使用它的好处”的答案。\n规范命名。尤其对于没有语义化的html标签，例如div，所赋予的class值要特别注意。\n抽取可重用的部件，注意层叠样式表的“优先级”。\n\n\n\n### JS相关问题\n\n##### 1.谈一谈JavaScript作用域链\n当执行一段JavaScript代码（全局代码或函数）时，JavaScript引擎会创建为其创建一个作用域又称为执行上下文（Execution Context），在页面加载后会首先创建一个全局的作用域，然后每执行一个函数，会建立一个对应的作用域，从而形成了一条作用域链。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。\n\n作用域链的作用是用于解析标识符，当函数被创建时（不是执行），会将this、arguments、命名参数和该函数中的所有局部变量添加到该当前作用域中，当JavaScript需要查找变量X的时候（这个过程称为变量解析），它首先会从作用域链中的链尾也就是当前作用域进行查找是否有X属性，如果没有找到就顺着作用域链继续查找，直到查找到链头，也就是全局作用域链，仍未找到该变量的话，就认为这段代码的作用域链上不存在x变量，并抛出一个引用错误（ReferenceError）的异常。\n\n\n\n##### 2.如何理解JavaScript原型链\nJavaScript中的每个对象都有一个prototype属性，我们称之为原型，而原型的值也是一个对象，因此它也有自己的原型，这样就串联起来了一条原型链，原型链的链头是object,它的prototype比较特殊，值为null。\n\n原型链的作用是用于对象继承，函数A的原型属性(prototype property)是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例，比如我们新建一个数组，数组的方法便从数组的原型上继承而来。\n\n当访问对象的一个属性时, 首先查找对象本身, 找到则返回; 若未找到, 则继续查找其原型对象的属性(如果还找不到实际上还会沿着原型链向上查找, 直至到根). 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined\n\n\n\n##### 3.JavaScript如何实现继承？\n构造继承\n原型继承\n实例继承\n拷贝继承\n原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。\n```javascript\nfunction Parent(){\n	this.name = \'wang\';\n}\n\nfunction Child(){\n	this.age = 28;\n}\nChild.prototype = new Parent();//继承了Parent，通过原型\nvar demo = new Child();\nalert(demo.age);\nalert(demo.name);//得到被继承的属性\n```\n\n\n##### 4.JavaScript的typeof返回哪些数据类型\n\nＯbject number function boolean underfind;\n##### 5.例举3种强制类型转换和2种隐式类型转换?\n\n强制（parseInt,parseFloat,number）隐式（== – ===）；\n##### 6.split() join() 的区别\n\n前者是切割成数组的形式，后者是将数组转换成字符串\n\n##### 7.数组方法pop() push() unshift() shift()\n\nPush()尾部添加 pop()尾部删除\nUnshift()头部添加 shift()头部删除\n\n##### 8.IE和DOM事件流的区别\n执行顺序不一样、\n参数不一样\n事件加不加on\nthis指向问题\n\n##### 9.ajax请求的时候get 和post方式的区别\n一个在url后面 一个放在虚拟载体里面\n有大小限制\n安全问题\n应用不同 一个是论坛等只需要请求的，一个是类似修改密码的\n\n##### 10.IE和标准下有哪些兼容性的写法\nVar ev = ev || window.event\ndocument.documentElement.clientWidth || document.body.clientWidth\nVar target = ev.srcElement||ev.target\n\n##### 11.ajax请求时，如何解释json数据\n\n使用eval parse,鉴于安全性考虑 使用parse更靠谱;\n##### 12.事件委托是什么\n\n让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！\n##### 13.闭包是什么，有什么特性，对页面有什么影响?简要介绍你理解的闭包\n\n闭包就是能够读取其他函数内部变量的函数。\n##### 14.添加 删除 替换 插入到某个接点的方法\n\nobj.appendChidl()\nobj.innersetBefore\nobj.replaceChild\nobj.removeChild\n\n##### 15..”==”和“===”的不同\n\n前者会自动转换类型，后者不会\n\n##### 16.编写一个b继承a的方法\n\n```javascript\nfunction A(name){\n    this.name = name;\n    this.sayHello = function(){alert(this.name+” say Hello!”);};\n}\nfunction B(name,id){\n    this.temp = A;\n    this.temp(name);        //相当于new A();\n    delete this.temp;       \n     this.id = id;   \n    this.checkId = function(ID){alert(this.id==ID)};\n}\n```\n\n##### 17.如何阻止事件冒泡和默认事件\n\n```javascript\nfunction stopBubble(e)\n{\n    if (e && e.stopPropagation)\n        e.stopPropagation()\n    else\n        window.event.cancelBubble=true\n}\nreturn false\n```\n\n##### 18.下面程序执行后弹出什么样的结果?\n\n```javascript\nfunction fn() {\n    this.a = 0;\n    this.b = function() {\n        alert(this.a)\n    }\n}\nfn.prototype = {\n    b: function() {\n        this.a = 20;\n        alert(this.a);\n    },\n    c: function() {\n        this.a = 30;\n        alert(this.a);\n    }\n}\nvar myfn = new fn();\nmyfn.b();\nmyfn.c();\n```\n\n##### 19.谈谈This对象的理解。\n\nthis是js的一个关键字，随着函数使用场合不同，this的值会发生变化。\n但是有一个总原则，那就是this指的是调用函数的那个对象。\nthis一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象\n\n##### 20.下面程序的结果\n\n```javascript\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);\nvar b = fun(0).fun(1).fun(2).fun(3);\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);\n\n//答案：\n\n//a: undefined,0,0,0\n//b: undefined,0,1,2\n//c: undefined,0,1,1\n```\n\n##### 21.下面程序的输出结果\n\n```javascript\nvar name = \'World!\';\n(function () {\n    if (typeof name === \'undefined\') {\n        var name = \'Jack\';\n        console.log(\'Goodbye \' + name);\n    } else {\n        console.log(\'Hello \' + name);\n    }\n})();\n```\n\n##### 22.了解Node么？Node的使用场景都有哪些？\n\n高并发、聊天、实时消息推送\n##### 23.介绍下你最常用的一款框架\n\njquery,rn,angular等;\n##### 24.对于前端自动化构建工具有了解吗？简单介绍一下\n\nGulp,Grunt等；\n##### 25.说一下什么是JavaScript的同源策略？\n\n一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合\n\n\n### 代码相关的问题\n\n##### 1.说说最近最流行的一些东西吧？常去哪些网站？\n\nNode.js、MVVM、React-native,Angular,Weex等\nCSDN,Segmentfault,博客园,掘金,Stackoverflow,伯乐在线等\n##### 2.如果今年你打算熟练掌握一项新技术，那会是什么？\n\nvia开发单页webapp的技术。\nSAP能够是页面与页面之间无缝连接，避免出现白页，且带有动态效果，提高用户体验。同时SAP，有JavaScript渲染页面，然后在从服务器获取小量的数据显示，如此反复，请求的数据无需要服务器处理，减少服务器负荷。\nSAP对技术要求高。要考虑首屏加载事件过长；动画效果要考虑低端手机；垃圾收集，需要自己释放资源，避免页面变卡。', '2', '0', '2017-09-27 11:03:02'), ('143', '1', '229', '[TOC]\n\n#### SEM表概述\n> - SEM帐户表`sem_account`\n>> `mysql -> sdkv（库） -> sem_account（表）`\n```\n前端配置数据，后台通过该表信息定时获取SEM帐户下的Meta和KPIs数据入库\n```\n>\n> - KPI创意域名与城市对应表`domain_region_device_map`\n>> `mysql -> sdkv（库） -> domain_region_device_map（表）`\n```\n定时任务获取KPIs数据时，如果创意有URL，则会解析出URL的域名然后与该表进行匹配，获取到对应城市的信息。对应定时任务：com.sdk.cron.normal.SemKpiTask\n```\n>\n> - SEM元数据表`kudu_sem_meta`\n>> `kudu -> zhugeio（库）-> kudu_sem_meta（表）`\n```\n定时任务从`sem_account`表中获取帐户信息，然后通过帐户获取对应utm_source的元数据（帐户、计划、单元、关键词、创意等）。对应定时任务：com.sdk.cron.normal.SemMetaTask\n```\n>\n> - SEM KPIs数据表`kudu_sem_kpi`\n>> `kudu -> zhugeio（库） -> kudu_sem_kpi（表）`\n```\n定时任务从`sem_account`表中获取帐户信息，然后通过帐户获取对应utm_source的KPIs数据（关键词和<或>创意的展示量、点击量、费用等）。对应定时任务：com.sdk.cron.normal.SemKpiTask\n```\n\n#### SEM定时任务\n> - SemMetaTask\n>> `zhugesdkv -> com.sdk.cron.normal.SemMetaTask`\n```\n周期：每天的6:30\n概述：定时获取SEM元数据\n数据导向：\n	`mysql: sem_account`获取帐户信息 ->\n	对应utm_source获取元数据 ->\n	`kudu: kudu_sem_meta`\n```\n>\n> - SemKpiTask\n>> `zhugesdkv -> com.sdk.cron.normal.SemKpiTask`\n```\n周期：2小时一次\n概述：定时更新当天的SEM的关键词和<或>创意的KPIs数据（搜狗与360不支持获取当天KPIs数据）\n数据导向：\n	`mysql: sem_account`获取帐户信息 ->\n	对应utm_source获取KPIs数据/通过KPIs中的创意URL解析出域名与`mysql: domain_region_device_map`表匹配获取城市数据 ->\n	`kudu: kudu_sem_kpi`\n```\n>\n> - SemKpiManualTask\n>> `zhugesdkv -> com.sdk.cron.normal.SemMetaManualTask`\n```\n周期：十分钟一次\n概述：作用与SemKpiTask相同，可指定日期更新某天的数据（每个平台支持最长时间不一，建议数据在三个月以内）\n```\n\n#### SEM代码\n##### 抽象代码概述\n> - 位置\n>> `zhugesdkv -> com.sdk.sem.*` `zhugesdkv -> com.sdk.util.ExceptionUtil`\n\n> - sdk\n>> - 百度、神马的sdk在`POM.xml`中指定\n>> - 360、搜狗修改了部分源码，存储位置：`~.sdk.*`\n\n> - 怎样调用？\n>> 通过`~.SemFactory.getSemInstance(.)`生成SEM实例，调用`~.Sem`抽象类中提供的方法。\n\n> - 异常\n>> 统一返回`~.SemException`\n\n##### SEM对接第三方API请求头\n||username|password|token|apiKey|apiSecret|\n|:-:\n|百度|√|√|√|-|-|\n|搜狗|√|√|√|-|-|\n|360|√|√|-|√|√|\n|神马|√|√|√|-|-|\n\n##### 后台存储第三方API请求头（表：sem_ccount）\n||username|password|token|\n|:-:\n|百度|username|password|token|\n|搜狗|username|password|token|\n|360|username|password|token|\n|神马|username|password|apiKey,apiSecret|\n\n##### `POM.xml`引用\n> - 注意点一：除了 `wolong-api-sdk`(神马) `sogou-cxf`(搜狗) `sogou-api-java`(搜狗) 这三个依赖要单独添加库外，其他都可以`mvnrepository.com`中找到版本\n> - 注意点二：以下依赖是大致的，可能之前就有用到，所以视项目增减\n\n```\n<dependency>\n	<groupId>commons-codec</groupId>\n	<artifactId>commons-codec</artifactId>\n	<version>1.10</version>\n</dependency>\n<dependency>\n	<groupId>commons-lang</groupId>\n	<artifactId>commons-lang</artifactId>\n	<version>2.6</version>\n</dependency>\n<dependency>\n	<groupId>commons-logging</groupId>\n	<artifactId>commons-logging</artifactId>\n	<version>1.2</version>\n</dependency>\n\n<dependency>\n	<groupId>sogou-cxf</groupId>\n	<artifactId>sogou-cxf</artifactId>\n	<version>2.4.1</version>\n</dependency>\n\n<dependency>\n	<groupId>drapi</groupId>\n	<artifactId>drapi</artifactId>\n	<version>1.0</version>\n</dependency>\n\n<dependency>\n	<groupId>org.apache.ant</groupId>\n	<artifactId>ant</artifactId>\n	<version>1.9.6</version>\n</dependency>\n<dependency>\n	<groupId>neethi</groupId>\n	<artifactId>neethi</artifactId>\n	<version>3.0.0</version>\n</dependency>\n<dependency>\n	<groupId>sogou-api-java</groupId>\n	<artifactId>sogou-api-java</artifactId>\n	<version>2.2.0</version>\n</dependency>\n<dependency>\n	<groupId>wsdl4j</groupId>\n	<artifactId>wsdl4j</artifactId>\n	<version>1.6.3</version>\n</dependency>\n<dependency>\n	<groupId>org.apache.ws.xmlschema</groupId>\n	<artifactId>xmlschema-core</artifactId>\n	<version>2.0.3</version>\n</dependency>\n\n<dependency>\n	<groupId>commons-httpclient</groupId>\n	<artifactId>commons-httpclient</artifactId>\n	<version>3.1-rc1</version>\n</dependency>\n<dependency>\n	<groupId>com.fasterxml.jackson.core</groupId>\n	<artifactId>jackson-databind</artifactId>\n	<version>2.5.1</version>\n</dependency>\n<dependency>\n	<groupId>org.reflections</groupId>\n	<artifactId>reflections</artifactId>\n	<version>0.9.9-RC1</version>\n</dependency>\n<dependency>\n	<groupId>org.ow2.asm</groupId>\n	<artifactId>asm-all</artifactId>\n	<version>4.1</version>\n</dependency>\n\n<dependency>\n	<groupId>com.sm.cpc</groupId>\n	<artifactId>wolong-api-sdk</artifactId>\n	<version>1.0.3</version>\n</dependency>\n```\n\n#### SEM数据报告注意点\n##### 关键词与<或>创意KPIs数据报告\n- 分设备获取数据：PC、移动端\n\n- 百度报告关键词与创意共同存在，其他要么只有关键词要么只有创意\n\n- 百度当天数据：（关键词id+创意id+设备）是唯一；其它当天数据：(关键词id+设备)唯一，(创意id+设备)唯一\n> 搜狗、360、神马关键词与创意报告是分开的，所以一天的关键词id与创意id是唯一。百度则是关键词id+创意id为唯一\n\n- 百度关键词不唯一，多个相同的关键词平均排名数据只会存在一个\n> 关键词平均排名：百度因为与创意数据一起，创意+关键词才是唯一，所以它是没有关键词平均排名数据，其它三家都有。百度排名是单独再通过关键词报告获取一遍排名数据然后赋值。但因为百度关键词id不是唯一的，所以多个相同关键词id时只有一个关键词会对应有排名数据\n\n- kpi获取城市字段数据为空，出现该问题可能的情况\n> 1. 获取的创意url为空（如：神马创意url删除了，但当天的kpi数据还有，但神马返回的创意则没有想关数据）\n> 2. 因为除百度之外其他平台的数据，关键词与创意都是分开的。所以当获取关键词数据的时候，创意url是不存在的，所以城市数据自然不存在\n> 3. 创意url获取到了，但表`domain_region_device_map `无对应映射城市\n\n- 百度与神马能获取当天数据，其它只能获取昨天以及之前的数据\n\n##### 搜索词KPIs数据报告\n- 分设备获取数据：PC、移动端\n\n- 搜狗无点击量数据\n> 搜狗获取搜索词报告数据无点击量，设置默认值为0。所以用求点击率时注意分母为0的情况\n\n- keywordId：百度有；其它可能有（没有的概率较低）\n> 除百度外，搜狗、360和神马搜索词报告中都不含keywordId。所以会先获取`关键词与<或>创意KPIs数据报告`，然后把keywordId填入到搜索词中。当搜索词的keywordId未在SemKpi报告中找到，则搜索词的keywordId不存在（概率很低）\n\n- 创意url：百度有；神马可能有；360和搜狗一定没有\n\n- 神马的标题可能没有或标题中含有描述，创意url可能没有\n> 神马返回的创意标题、描述和url是在一起的，只能分割出（标题=标题+描述）、创意url。之后会通过创意id再去获取一次创意数据，但神马的部分创意id是无效的，不能返回创意数据。所以，如果能通过创意id获取到创意数据则创意数据保持完整，其它则可能丢失标题和url或标题过长（包括了标题和描述）\n\n- 百度能获取当天数据，其它只能获取昨天以及之前的数据\n\n#### 配额问题\n- 百度、搜狗、360、神马都有配额限制\n- 调用它们的API会消耗一定配额。配额的多少每家规则不一，消耗度也不一样\n- 当配额不足时，则无法调用API\n- 配额会在每周六重新分配。\n\n> 以下是四家消耗配额参考数据\n\n||百度|搜狗|360|神马|\n|-\n|检测帐号是否可用|<10|<10|<10|<10|\n|获取元数据<配额（数据量）>|>300（15K）|>21K（21.5K）|>350（8.7K）|>40（10.1K）|\n|获取KPIs<配额（关键词与创意+搜索词）>|>6000（1.5K+250）|>30（210+40）|>10（260+75）|>25（80+95）|\n\n> 配额是动态的，以下都是东易日盛的帐号，配额总数的一个参考值\n>> 百度帐号：`baidu-lz东易日盛2111191`\n>> 搜狗帐号：`wzdyrs@yeah.com`\n>> 360 帐号：`东易温州2015`\n>> 神马帐号：`东易温州`\n\n||2017-10-10|2017-10-17|2017-10-23|2017-10-30|\n|:-:\n|百度|707365|582348|465878|372702|\n|搜狗|281428|292644|287311|247206|\n|360|-|-|1999974|1995080|\n|神马|-|-|499981|499876|\n\n||2017-11-06|2017-11-13|2017-11-20|\n|:-:\n|百度|285572|699176(上周增加到81万)|552004|\n|搜狗|255387|257672|147404|\n|360|1998904|1998927|1998291|\n|神马|499931|499933|499832|\n\n||2017-12-04|\n|:-:\n|百度|289880|\n|搜狗|299209|\n|360|221256|\n|神马|499999|\n\n#### SEM整体报表相关\n- 新增表\n> mysql\n> - sem_cus_ser_meiqia_account\n>> 美洽帐号配置表，用于美洽`完成在线咨询`事件打点，APPKEY 由美洽返回数据中给出\n> - sem_whole_event_type_map\n>> 指定事件与事件id之间的映射关系表\n> - sem_whole_task_num\n>> app中`有效线索`与`量房`任务数与定制月之间的配置表\n> - sem_whole_user_app_relation\n>> 用户与app关系表，appId的数据来源`domain_region_device_map`表\n>\n> kudu\n> - kudu_sem_customer_month_map\n>> 定制月全量表（最小到dayId，即一年的定制月会有365条数据）\n\n- 修改表\n> mysql\n> - domain_region_device_map\n>> 城市与appId对应关系表\n> - sem_account\n>> 添加`app_id`，将sem帐号关联到app中，而不再是公司范围\n\n- 新增一个应用所要做的事\n1. 将`app_id`在表`domain_region_device_map`中与城市对应\n2. 在表`sem_whole_event_type_map`中配置事件类型与事件id（或事件中属性）对应数据\n3. 在表`sem_whole_task_num`添加事件对应定制月的任务数量\n4. 公司-用户-成员 中将用户与新加城市(appId)关联\n\n```\n# SEM整体报表自动添加事件映射的sql\n\n# 总对话(1, false, \"完成在线咨询｛访客消息数 > 0｝\"),\n# 有效对话(2, false, \"完成在线咨询｛有效对话 = 有效｝\"),\n# IM线索(3, false, \"完成在线咨询｛已留对话 = 已留｝\"),\n# 总报名(4, true, \"报名表单提交_成功\"),\n# 有效报名(5, true, \"报名审核\"),\n# 有效线索(6, true, \"销售-成为有效线索\"),\n# 精准线索(7, true, \"销售-成为精准线索\"),\n# 见面数(8, true, \"销售-见面\"),\n# 量房数(9, true, \"销售-量房\");\n\n\n# 总对话\nselect CONCAT(\"upsert into kudu_sem_whole_event_type_map values(\",app_id,\",\",event_type,\",\'\",event_desc,\"\',\",event_id,\",\'\",event_attr_col,\"\',\",\"\'\",event_attr_val,\"\',\",\"from_timestamp(current_timestamp(), \'yyyy-MM-dd HH:mm:ss\'));\") from \n(select e.app_id,1 AS event_type,concat(e.event_name, \"-\", r.attr_name, \"(总对话)\") AS event_desc,e.id AS event_id,r.column_name AS event_attr_col,concat(\'CAST(\',r.column_name,\' AS INT)>0\') AS event_attr_val from event e join event_attr r on r.event_id=e.id where e.app_id in (select app_id from domain_region_device_map where app_id is not null group by app_id order by app_id asc) and e.event_name=\'完成在线咨询\' and r.attr_name=\'访客对话条数\' group by e.app_id) as d;\n\n# 有效对话\nselect CONCAT(\"upsert into kudu_sem_whole_event_type_map values(\",app_id,\",\",event_type,\",\'\",event_desc,\"\',\",event_id,\",\'\",event_attr_col,\"\',\",\"\'\",event_attr_val,\"\',\",\"from_timestamp(current_timestamp(), \'yyyy-MM-dd HH:mm:ss\'));\") from \n(select e.app_id,2 AS event_type,concat(e.event_name, \"-\", r.attr_name, \"(有效对话)\") AS event_desc,e.id AS event_id,r.column_name AS event_attr_col,concat(r.column_name,\"=\\\\\'有效\\\\\'\") AS event_attr_val from event e join event_attr r on r.event_id=e.id where e.app_id in (select app_id from domain_region_device_map where app_id is not null group by app_id order by app_id asc) and e.event_name=\'完成在线咨询\' and r.attr_name=\'有效对话\' group by e.app_id) as d;\n\n# IM线索\nselect CONCAT(\"upsert into kudu_sem_whole_event_type_map values(\",app_id,\",\",event_type,\",\'\",event_desc,\"\',\",event_id,\",\'\",event_attr_col,\"\',\",\"\'\",event_attr_val,\"\',\",\"from_timestamp(current_timestamp(), \'yyyy-MM-dd HH:mm:ss\'));\") from \n(select e.app_id,3 AS event_type,concat(e.event_name, \"-\", r.attr_name,\"(IM线索)\") AS event_desc,e.id AS event_id,r.column_name AS event_attr_col,concat(r.column_name,\"=\\\\\'已留\\\\\'\") AS event_attr_val from event e join event_attr r on r.event_id=e.id where e.app_id in (select app_id from domain_region_device_map where app_id is not null group by app_id order by app_id asc) and e.event_name=\'完成在线咨询\' and r.attr_name=\'已留对话\' group by e.app_id) as d;\n\n# 总报名\nselect CONCAT(\"upsert into kudu_sem_whole_event_type_map values(\",app_id,\",\",event_type,\",\'\",event_desc,\"\',\",event_id,\",NULL\",\",NULL\",\",from_timestamp(current_timestamp(), \'yyyy-MM-dd HH:mm:ss\'));\") from \n(select app_id,4 AS event_type,concat(event_name, \"(总报名)\") AS event_desc,id AS event_id from event where app_id in (select app_id from domain_region_device_map where app_id is not null group by app_id order by app_id asc) and event_name=\'报名表单提交_成功_服务端\' group by app_id) as d;\n\n# 有效报名\nselect CONCAT(\"upsert into kudu_sem_whole_event_type_map values(\",app_id,\",\",event_type,\",\'\",event_desc,\"\',\",event_id,\",\'\",event_attr_col,\"\',\",\"\'\",event_attr_val,\"\',\",\"from_timestamp(current_timestamp(), \'yyyy-MM-dd HH:mm:ss\'));\") from \n(select e.app_id,5 AS event_type,concat(e.event_name, \"-\", r.attr_name, \"(有效报名)\") AS event_desc,e.id AS event_id,r.column_name AS event_attr_col,concat(r.column_name,\" IN(\\\\\'有效\\\\\',\\\\\'见面\\\\\',\\\\\'签单\\\\\')\") AS event_attr_val from event e join event_attr r on r.event_id=e.id where e.app_id in (select app_id from domain_region_device_map where app_id is not null group by app_id order by app_id asc) and e.event_name=\'报名审核\' and r.attr_name=\'审核结果\' group by e.app_id) as d;\n\n# 有效线索\nselect CONCAT(\"upsert into kudu_sem_whole_event_type_map values(\",app_id,\",\",event_type,\",\'\",event_desc,\"\',\",event_id,\",NULL\",\",NULL\",\",from_timestamp(current_timestamp(), \'yyyy-MM-dd HH:mm:ss\'));\") from \n(select app_id,6 AS event_type,concat(event_name, \"(有效线索)\") AS event_desc,id AS event_id from event where app_id in (select app_id from domain_region_device_map where app_id is not null group by app_id order by app_id asc) and event_name=\'销售-成为有效线索\' group by app_id) as d;\n\n# 精准线索\nselect CONCAT(\"upsert into kudu_sem_whole_event_type_map values(\",app_id,\",\",event_type,\",\'\",event_desc,\"\',\",event_id,\",NULL\",\",NULL\",\",from_timestamp(current_timestamp(), \'yyyy-MM-dd HH:mm:ss\'));\") from \n(select app_id,7 AS event_type,concat(event_name, \"(精准线索)\") AS event_desc,id AS event_id from event where app_id in (select app_id from domain_region_device_map where app_id is not null group by app_id order by app_id asc) and event_name=\'销售-成为精准线索\' group by app_id) as d;\n\n# 见面数\nselect CONCAT(\"upsert into kudu_sem_whole_event_type_map values(\",app_id,\",\",event_type,\",\'\",event_desc,\"\',\",event_id,\",NULL\",\",NULL\",\",from_timestamp(current_timestamp(), \'yyyy-MM-dd HH:mm:ss\'));\") from \n(select app_id,8 AS event_type,concat(event_name, \"(见面数)\") AS event_desc,id AS event_id from event where app_id in (select app_id from domain_region_device_map where app_id is not null group by app_id order by app_id asc) and event_name=\'销售-见面\' group by app_id) as d;\n\n# 量房数\nselect CONCAT(\"upsert into kudu_sem_whole_event_type_map values(\",app_id,\",\",event_type,\",\'\",event_desc,\"\',\",event_id,\",NULL\",\",NULL\",\",from_timestamp(current_timestamp(), \'yyyy-MM-dd HH:mm:ss\'));\") from \n(select app_id,9 AS event_type,concat(event_name, \"(量房数)\") AS event_desc,id AS event_id from event where app_id in (select app_id from domain_region_device_map where app_id is not null group by app_id order by app_id asc) and event_name=\'销售-量房\' group by app_id) as d;\n```\n\n- 注意点\n1. 定制月需要定期更新\n2. 任务数量需要定期更新\n\n\n#### impala::kudu_sem_whole_event_type_map\n> 事件类型与事件id映射表\n```\nCREATE TABLE IF NOT EXISTS  kudu_sem_whole_event_type_map(\napp_id int,\nevent_type int,\nevent_desc string,\nevent_id int,\nevent_attr_col string,\nevent_attr_val string,\ncreate_datetime string,\nPRIMARY KEY (app_id,event_type)\n)PARTITION BY HASH(app_id) PARTITIONS 2 STORED AS KUDU;\n```', '2', '0', '2017-10-25 11:25:49'), ('144', '1', '230', '修改`%TOMCAT_HOME%/conf/server.xml`\nps：压缩使用`GZIP`\n```\n<Connector port=\"80\" protocol=\"HTTP/1.1\" \n           connectionTimeout=\"20000\" \n           redirectPort=\"8443\" executor=\"tomcatThreadPool\" URIEncoding=\"utf-8\" \n		   compression=\"on\" \n		   compressionMinSize=\"50\" noCompressionUserAgents=\"gozilla, traviata\" \n		   compressableMimeType=\"text/html,text/xml,text/javascript,text/css,text/plain,application/json\" />\n```\n```\ncompression=\"on\" 打开压缩功能\ncompressionMinSize=\"50\" 启用压缩的输出内容大小，默认为2KB\nnoCompressionUserAgents=\"gozilla, traviata\" 对于这些浏览器，不启用压缩\ncompressableMimeType=\"text/html,text/xml,text/javascript,text/css,text/plain,application/json\"　哪些资源类型需要压缩\n```', '2', '0', '2017-10-25 15:21:52'), ('145', '1', '231', '#### 东易日盛\n##### 文档\n```\n文档：https://docs.google.com/document/d/1GThZdpig2QmydilVyku6Vrcwrf9bGijzL7rQWQiDKYI/edit#heading=h.troj69632ab2\n一期原型：http://hoi83p.axshare.com/#g=1&p=原型-通配符配置\n二期原型：http://jq7rni.axshare.com/#g=1&p=定制sem报告入口\n```\n##### SEM帐号\n```\n百度：bj-诸葛云游      ZHUGEio20!%\n百度账户：baidu-lz东易日盛2111191	LZdy0606	2957c60c94a685d6e500d8564e50dd03\n360账户：东易温州2015	ghF4F3gd	apiKey：1ucj6lds5zertvxpxu6g7k59bwaxbuwv	apiSecret：1mxwyga4m3nb5yswtf82byr4avtvyc2k\n搜狗账户：wzdyrs@yeah.com	tu45G5h4g	863f545bad1bfb0e6841fd4075ac1314\n神马账户：东易温州	h5dhY56T	583beb8e-f55e-4d55-8c75-8f5041eaff13\n```\n##### 客服\n- 全国乐语：xiaoyu	99tangshisan2019\n- 温州美洽：miaozhicai@dyrs.com.cn	tx123456\n\n```\n美洽key\n\nenterprise id: 30437\nenterprise name: 东易日盛装饰公司\nkey: conversations\nappid: 0e164cccab0a8b9f4aa218a33f5e7076\nsign: 1e8cfacb1be26a1239044468fad37b00\nend\n\nenterprise id: 30437\nenterprise name: 东易日盛装饰公司\nkey: tickets\nappid: 0ec2879d95a99c51a08014522304ce68\nsign: 79548cfb92961098095ddd634ddf9156\nend\n\n\nenterprise id: 68717\nenterprise name: 东易日盛-温州\nkey: conversations\nappid: 6becece7a3565d6198dd3bcd96ca976b\nsign: ce847b21a0723442307fdfc2b82ae251\nend\n\nenterprise id: 68717\nenterprise name: 东易日盛-温州\nkey: tickets\nappid: 8c3554cc8162a99aafd3fd5c9f71ce68\nsign: 456b4a4591cf477952fca4d95310fd9f\nend\n\nenterprise id: 68711\nenterprise name: 东易日盛-兰州\nkey: conversations\nappid: e62cc7e885f58716fbd34842370aa5ff\nsign: 8e3d31573ced4e0b1f0dc93bbca12cb1\nend\n\nenterprise id: 68711\nenterprise name: 东易日盛-兰州\nkey: tickets\nappid: bee1f8b3ba0ff3d56904dad4746f698f\nsign: 24c2170a3b95f18dce15080c82680656\nend \n```', '2', '0', '2017-10-31 09:54:02'), ('146', '1', '232', '### iTerm2主题配置与常用技巧\n\n[TOC]\n\n#### 序\n- 系统：macOS Sierra 10.12.6\n- iTerm2版本：3.1.4\n\n> 最终效果：\n![](http://img.qiqinote.com/2017/11/3/4f6e32d397eb4704ae3701a493fc0625.png)\n\n#### 下载安装\n1. 官网下载压缩包：http://www.iterm2.com/downloads.html\n2. 双击解压，将`iTerm2.app`拷贝到`应用程序` 完成安装!\n\n#### 配置主题\n- 打开iTerm2\n- 执行命令：`curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh`\n- 执行命令：`sudo easy_install pip`\n- 执行命令：`pip install powerline-status`\n- 安装字体库\n> - git地址：https://github.com/powerline/fonts\n> - 下载解压后，执行`./install.sh`\n> - 在iTerm2中配置\n![](http://img.qiqinote.com/2017/11/3/b22c5bae17e6447b8d474ee1143feb55.png)\n\n- 安装配色方案\n> - git地址：https://github.com/altercation/solarized\n> - 下载解压后，找到iTerm2的配色方案：`solarized/iterm2-colors-solarized`\n>> 双击 `Solarized Dark.itermcolors`\n>\n> - 在iTerm2中配置(若未找到，重启iTerm2)\n![](http://img.qiqinote.com/2017/11/3/7b826e7901a944a4b437e1672f36fae2.png)\n\n- 配置agnoster主题\n> - git地址：https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor\n> - 下载解压后执行里面的`install`文件\n> - 修改文件：`vi ~/.zshrc`\n>> \n```\nZSH_THEME=\"agnoster\"\n```\n\n- 配置指令高亮（zsh-syntax-highlighting）\n> - git地址：https://github.com/zsh-users/zsh-syntax-highlighting\n> 下载解压压缩文件，拷贝目录所有文件到自定义目录，如：~/zsh-syntax-highlighting\n> 修改文件：`vi ~/.zshrc`，在文件最后添加：\n>> \n```\nsource ~/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\nplugins=(zsh-syntax-highlighting)\n```\n>\n> - 重启iTerm2，若在最上文没有错误或警告则表示配置成功\n\n- 完成！\n\nps: 配置后，`~/.zshrc`相当于文件：`~/.bash_profile`\n\n#### 常用命令\n|命令|描述|\n|-\n|⌘ + n|新建窗口|\n|⌘ + t|新建标签页|\n|⌘ + w|关闭当前页|\n|⌘ + 数字 或 ⌘ + 方向键|切换标签页|\n|⌘ + enter|切换全屏|\n|⌘ + d|左右分屏|\n|⇧⌘ + d|上下分屏|\n|⌘ + ;|自动补全历史记录|\n|⇧⌘ + h|自动补全剪贴板历史|\n|⌥⌘ + e|查找所有来定位某个标签页|\n|⌘ + r 或 ⌃ + l|清屏|\n|⌘ + /|显示光标位置|\n|⌥⌘ + b|历史回放|\n|⌘ + f|查找，然后用 tab 和 ⇧ + tab 可以向右和向左补全，补全之后的内容会被自动复制， 还可以用 ⌥ + enter 将查找结果输入终端|\n|⌘ + o 或 ⇧⌘ + b|打个profile列表|\n|⇧⌘ + e|打开/关闭操作时间轴|\n\n#### 设置自动SSH远程登录服务器\n- 创建脚本文件，名称任意（如：`touch ~/.ssh/login`）添加内容：\n```\n#!/usr/bin/expect\nset timeout 30\nspawn ssh -p [lindex $argv 3] [lindex $argv 1]@[lindex $argv 0]\nexpect {\n        \"(yes/no)?\"\n        {send \"yes\\n\";exp_continue}\n        \"password:\"\n        {send \"[lindex $argv 2]\\n\"}\n}\ninteract\n```\n- 打开iTerm2配置页，添加一个`profile`，在`Command`中输入：\n```\n脚本绝对路径 ip地址 用户名 密码 端口号\n如：\nexpect ~/.ssh/login 127.0.0.1 root root123 22\n```\n如图所示：\n![](http://img.qiqinote.com/2017/11/3/e355e8beadb3405a8d6310ceebb0bacc.png)\n> 注意: 上图第3步中，命令开头少了`expect `\n\n- 右击iTerm2内容框找到新建的`profile`即可连接\n\n#### 设置rzsz\n参考：http://blog.csdn.net/citywolf4/article/details/49071679\n\n- 安装lrzsz\n> - mac：`$ brew install lrzsz`\n> - linux：`$ yum install lrzsz` 或 `$ apt-get install lrzsz`\n\n- 下载zmoden脚本\n1. git：https://github.com/mmastrac/iterm2-zmodem\n2. 下载：iterm2-send-zmodem.sh（上传脚本）/ iterm2-recv-zmodem.sh（下载脚本）\n> 本文提供俩脚本具体内容：\n\n```\n#!/bin/bash\n# Author: Matt Mastracci (matthew@mastracci.com)\n# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script\n# licensed under cc-wiki with attribution required \n# Remainder of script public domain\n\nosascript -e \'tell application \"iTerm2\" to version\' > /dev/null 2>&1 && NAME=iTerm2 || NAME=iTerm\nif [[ $NAME = \"iTerm\" ]]; then\n	FILE=`osascript -e \'tell application \"iTerm\" to activate\' -e \'tell application \"iTerm\" to set thefile to choose file with prompt \"Choose a file to send\"\' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\nelse\n	FILE=`osascript -e \'tell application \"iTerm2\" to activate\' -e \'tell application \"iTerm2\" to set thefile to choose file with prompt \"Choose a file to send\"\' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\nfi\nif [[ $FILE = \"\" ]]; then\n	echo Cancelled.\n	# Send ZModem cancel\n	echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18\n	sleep 1\n	echo\n	echo \\# Cancelled transfer\nelse\n	/usr/local/bin/sz \"$FILE\" -e -b\n	sleep 1\n	echo\n	echo \\# Received $FILE\nfi\n```\n> &uarr;&uarr;&uarr; `iterm2-send-zmodem.sh`\n\n```\n#!/bin/bash\n# Author: Matt Mastracci (matthew@mastracci.com)\n# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script\n# licensed under cc-wiki with attribution required \n# Remainder of script public domain\n\nosascript -e \'tell application \"iTerm2\" to version\' > /dev/null 2>&1 && NAME=iTerm2 || NAME=iTerm\nif [[ $NAME = \"iTerm\" ]]; then\n	FILE=`osascript -e \'tell application \"iTerm\" to activate\' -e \'tell application \"iTerm\" to set thefile to choose folder with prompt \"Choose a folder to place received files in\"\' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\nelse\n	FILE=`osascript -e \'tell application \"iTerm2\" to activate\' -e \'tell application \"iTerm2\" to set thefile to choose folder with prompt \"Choose a folder to place received files in\"\' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\nfi\n\nif [[ $FILE = \"\" ]]; then\n	echo Cancelled.\n	# Send ZModem cancel\n	echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18\n	sleep 1\n	echo\n	echo \\# Cancelled transfer\nelse\n	cd \"$FILE\"\n	/usr/local/bin/rz -E -e -b\n	sleep 1\n	echo\n	echo\n	echo \\# Sent \\-\\> $FILE\nfi\n```\n> &uarr;&uarr;&uarr; `iterm2-recv-zmodem.sh`\n\n- 将俩脚本放到自定义目录，如：\n```\n/User/vanki/iterm2_conf/iterm2-send-zmodem.sh\n/User/vanki/iterm2_conf/iterm2-recv-zmodem.sh\n```\n\n- 配置iterm2 trigger\n1. 打开iterm2 \n2. 快捷键`command + ,`打开配置 -> `Profiles` ->  `Default` -> `Advanced` -> `Triggers`的`Edit`按钮，在弹出的界面配置以下参数：\n\n|Regular Expression|Action|Parameters|Instant|\n|-\n|\\*\\*B0100|Run Silent Coprocess|/User/vanki/iterm2_conf/iterm2-send-zmodem.sh|`选中`|\n|\\*\\*B00000000000000|Run Silent Coprocess|/User/vanki/iterm2_conf/iterm2-recv-zmodem.sh|`选中`|\n\n如图：\n![](http://img.qiqinote.com/2017/11/30/b84431010773490ead5d3c99c8010697.png)\n> ps：可以快捷将选中的profile配置复制给其它profile中，操作如下：\n>> 快捷键`command + ,`打开配置 -> `Profiles` > 左下角：Other Actions -> Bulk Copy From Selected Profile...', '2', '0', '2017-11-03 16:56:33'), ('147', '1024', '233', '**1、图片懒加载**\n\n**2、实现页面加载进度条**\n\n**3、事件委托：事件冒泡原理**\n\n**4、实现extends函数**\n\n**5、json.pase(将字符串转为json)  json.stringfy(将json转化为字符串)**\n\n**6、实现拖拽**\n\n**7、es6特性**\n\n##### a、箭头操作 #\n```javascript\nvar arr=[1,2,3]\narr.forEach(function(v,i,a){\nconsole.log(v)\n})//传统写法\n||\narr.forEach(v=>console.log(v)) //es6写法\n```\n\n##### b、类的支持 #\n```javascript\nclass A{\n        //es6中的新型构造器\n        constructor(name){\n            this.name=name;\n        }\n\n        //实类方法\n        sayHlloe(){\n            console.log(\'hello \'+this.name)\n        }\n    }\n\n    //类的继承\n    class P extends A{\n        constructor(name){\n\n            //直接调用父类构造器初始化\n            super(name)\n        }\n\n        psayHi(){\n            console.log(\'hi \'+this.name)\n        }\n    }\n\n    //测试类\n    var newa=new A(\'eric\')\n    var newp=new P(\'chris\')\n    newa.sayHlloe()\n    newp.psayHi()\n    newp.sayHlloe()\n```\n\n\n\n##### c、增强对象自变量\n\n```javascript\n\n    var arr={\n    \n     breate(){\n     console.log(\'我是对象1\')\n     }\n    }\n    \n    var worker={\n    _proto_:arr,\n    work:function(){\n    console.log(\'我是对象2\')\n    }\n    }\n    \n    worker.work()\n    worker.breate()\n```\n\n##### d、字符串模板·helloe ${chris}·\n\ne、不定参数，默认参数值\n```javascript\nfunction a(name=\'dingding\'){\n\nconsole.log(`${name}`)\n}\n```\n\n\n##### 8、同源策略：防止跨站脚本的访问（协议，主机名，端口号不同的）     \n                                                                   \n##### 9、js原型链  js中万物都是对象，每个对象都有__proto__属性,所以形成一条链，递归地访问__proto__,最终的尽头是null，js查找对象属性时，先查对象本身是否存在，不存在就在原型链上查找，\n#####                                                        属性proto=>null\n                                                       \n原型属性__proto__roto__属性原型属性__proto__===>原型对象function.prototype===》constuctor\n\n##### 10、跨域请求\n##### jsonp  window.name\n\n##### 11、this，js特权方法()\n特权方法可以在类的外部被调用，可以访问类的私有属性和方法以及共有属性和方法，特权方法必须在类的内部声明定义 this关键字声明特权方法特权方法可以在类的外部被调用，可以访问类的私有属性和方法以及共有属性和方法，特权方法必须在类的内部声明定义 this关键字声明特权方法\n\n```javascript\nfunction students（）{\nthis.myPrivte()=function (){\n}\n}\n```\n\n##### 公有方法：父类生成的所有实例方法 prototype\n```javascript\nfunction user(name){\n   this.name=name\n}\n\nuser.prototype={\ngetinfo:function(){\nreturn this.name\n}\n}\nvar  zhang=new user(\'zhang\')\nuser.getinfo();\n```\n\n\n##### 私有方法：只有父类可以访问其属性和方法\nfunction(){\n\nfunction a(){}\n}\n\n\n##### 特权方法：既可以访问私有方法和属性又可以访问公有方法和属性\n```javascript\nfunction user(name){\nthis.name=name;\nthis.getinfo=function(){\nconsole.log(this.name)\n}\n}\n\nvar zhang =new user(\'zhang\')\nzhang.getinfo();\n```\n\n\n##### 12、闭包(一个函数可以使用其他函数内部的变量)\n\n\n##### 13、单页面应用()\n\n\n##### 14、js的继承  \n\n##### a、原型链的方式继承\n```javascript\nfunction person(name,age){\nthis.name=name;\nthis.age=age\n}\n\nfunction man(){\nthis.fearch=\'hello\'\n}\n\nman.prototype=new person();//man继承person\n\nvar newman=new man(\'zhang\',20);\n\nconsole.log(newman.name)\n```\n\n##### b、appy的方法继承\n\n```javascript\nfunction person(){\nthis.name=\'ting\',\nthis.age=20\n}\n\nfunction man(){\nperson.apply(this,[])\nthis.fearch=\'hi\'\n}																				\n\nvar newman=new man();\nconsole.log(newman.name)\nconsole.log(newman.age)\nconsole.log(newman.fearch)\n```', '2', '0', '2017-11-30 11:24:02'), ('148', '1', '235', '#### 安装插件管理器\n```\nimport urllib.request,os,hashlib; h = \'6f4c264a24d933ce70df5dedcf1dcaee\' + \'ebe013ee18cced0ef93d5f746d80ef60\'; pf = \'Package Control.sublime-package\'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( \'http://packagecontrol.io/\' + pf.replace(\' \', \'%20\')).read(); dh = hashlib.sha256(by).hexdigest(); print(\'Error validating download (got %s instead of %s), please try manual install\' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), \'wb\' ).write(by)\n```\n> 参考：https://packagecontrol.io/installation', '2', '0', '2017-11-30 11:56:33'), ('149', '1', '237', '1. 查看表结构\n```\nshow create table 表名\n```\n\n2. 添加列\n> 参考：https://www.cloudera.com/documentation/cdh/5-0-x/Impala/Installing-and-Using-Impala/ciiu_alter_table.html\n```\nalter table 表名 add columns (create_datetime bigint, update_datetime bigint);\n```\n\n3. 删除列\n> 参考：https://www.cloudera.com/documentation/cdh/5-0-x/Impala/Installing-and-Using-Impala/ciiu_alter_table.html\n```\nalter table 表名 drop create_datetime;\n```\n\n4. 取分组后按时间倒序第一条数据(窗口函数)\n```\nSELECT *\nFROM\n  (SELECT begin_date,\n          begin_time_id,\n          zg_id,\n          row_number() over(partition BY zg_id ORDER BY begin_date DESC) AS rw\n   FROM b_user_event_attr_55 ) AS t\nWHERE t.rw = 1;\n```', '2', '0', '2017-12-18 11:17:25'), ('150', '1', '239', '[TOC]\n\n#### 登录\n> \n||', '2', '0', '2017-12-25 18:28:26'), ('151', '1', '241', '[TOC]\n\n文档创建于: 2018-01-12\n\n> 宏泽接口：https://ph.zhugeio.com/w/%E8%90%A5%E9%94%80%E4%BA%91/%E5%BE%AE%E4%BF%A1%E6%97%A5%E6%8A%A5%E6%8E%A5%E5%8F%A3/\n\n#### 登录\n- 地址：`wx_subscribe/login.jsp`\n- 请求：POST\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|datas|是|字符串|json字符串|与PC登录接口传参一致，只是加了`code`或`open_id`|\n> datas 参数示例：\n```\n{\n    \"code\": \"微信code，用于获取openid\",\n	\"open_id\": \"code只能用一次，所以第一次绑定时会返回该字段，再次请求时code可不传，将open_id传过来\"\n    \"username\": \"zhuge@zhugeio.com\",\n    \"password\": \"wo7DqcOPwrgww7fDpQ==\",\n    \"type\": 0,\n    \"location\": \"\"\n}\n```\n\n- 结果：\n> - 成功\n>> 重定向到登录接口\n>\n> - 失败\n>> 响应数据：\n```\n	{\n		flag: -101,\n		msg: \"open_id未绑定用户\",\n		wxOpenId: \"xxx\", 	<!--只当 flag= -101 时才会有该字段, 放置在user中-->\n		wxNickname: \"xxx\" 	<!--只当 flag= -101 时且是首次绑定时才会有该字段, 放置在user中-->\n	}\n```\n>> 其他错误code码：\n>>> - `-101` -> 该微信号未绑定用户\n>>> - `-102` -> 参数错误\n>>> - `-103` -> 用户不存在\n>>> - `-104` -> 密码错误\n>>> - `-105` -> 已绑定的已用户不存在\n>>> - `-106` -> 该微信号已绑定过帐号\n>>> - `-107` -> 获取微信openid失败\n\n#### 添加或更新微信与看板关系\n- 地址：`wx_subscribe/upsertWxPanelRelation.jsp`\n- 请求：POST\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|open_id|否|字符串|微信open_id|当未登录时，该字段必填|\n|panel_id|是|整数|看板id||\n|send_period|是|字符串|发送周期|||\n\n- 结果\n> - 成功\n>> 响应数据：\n```JSON\n	{\n		flag: 101,\n		msg: \"success\"\n	}\n```\n>\n> - 失败\n>> 响应数据：\n```JSON\n	{\n		flag: -101,\n		msg: \"fail\"\n	}\n```\n\n#### 解除用户与微信绑定关系\n- 地址：`wx_subscribe/deleteWxUserRelation.jsp`\n- 请求：POST\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|open_id|是|字符串|微信id||\n|user_id|否|字符串|用户id|||\n\n- 结果\n> - 成功\n>> 响应数据：\n```JSON\n	{\n		flag: 101,\n		msg: \"success\"\n	}\n```\n>\n> - 失败\n>> 响应数据：\n```JSON\n	{\n		flag: -101,\n		msg: \"fail\"\n	}\n```\n\n#### 删除微信与看板关系\n- 地址：`wx_subscribe/deleteWxPanelRelation.jsp`\n- 请求：POST\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|panel_id|是|字符串|看板id|||\n\n- 结果\n> - 成功\n>> 响应数据：\n```JSON\n	{\n		flag: 101,\n		msg: \"success\"\n	}\n```\n>\n> - 失败\n>> 响应数据：\n```JSON\n	{\n		flag: -101,\n		msg: \"fail\"\n	}\n```\n\n#### 删除微信与看板关系（批量）\n- 地址：`wx_subscribe/deleteWxPanelRelations.jsp`\n- 请求：POST\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|panel_ids|是|字符串|看板id|多个以`,`分隔|\n\n- 结果\n> - 成功\n>> 响应数据：\n```JSON\n	{\n		flag: 101,\n		msg: \"success\"\n	}\n```\n>\n> - 失败\n>> 响应数据：\n```JSON\n	{\n		flag: -101,\n		msg: \"fail\"\n	}\n```\n\n#### 是否订阅看板\n- 地址：`wx_subscribe/isSubscribe.jsp`\n- 请求： GET\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|open_id|是|字符串|微信id||\n|panel_id|是|字符串|看板id|||\n\n- 结果\n> - 已订阅\n>> 响应数据：\n```JSON\n	{\n		\"msg\": \"success\",\n		\"flag\": 101,\n		\"data\": {\n			\"name\": \"看板名称\"\n		}\n	}\n```\n>\n> - 未订阅\n>> 响应数据：\n```JSON\n	{\n		\"flag\": -101,\n		\"msg\": \"fail\",\n		\"data\": {\n			\"name\": \"看板名称\"\n		}\n	}\n```\n\n#### 是否有订阅看板权限\n- 地址：`wx_subscribe/isPermission.jsp`\n- 请求： GET\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|user_id|是|整数|用户id||\n|panel_id|是|字符串|看板id|||\n\n- 结果\n> - 已订阅\n>> 响应数据：\n```JSON\n	{\n		\"msg\": \"success\",\n		\"flag\": 101,\n		\"data\": {\n			\"name\": \"看板名称\"\n		}\n	}\n```\n>\n> - 未订阅\n>> 响应数据：\n```JSON\n	{\n		\"flag\": -101,\n		\"msg\": \"fail\",\n		\"data\": {\n			\"name\": \"看板名称\"\n		}\n	}\n```\n\n#### 获取微信订阅看板列表\n- 地址：`wx_subscribe/getWxSubscribePanelList.jsp`\n- 请求：GET\n- 参数：无\n- 结果：\n```\n	{\n	  \"msg\": \"success\",\n	  \"flag\": 101,\n	  \"datas\": [\n		{\n		  \"appId\": 461,\n		  \"appName\": \"诸葛io\",\n		  \"panelId\": 51549,\n		  \"panelName\": \"韩重明\",\n		  \"panelPlatform\": 3,\n		  \"panelOpenType\": 1,\n		  \"sendPeriod\": \"day 9:00\",\n		  \"createDatetime\": 1514450303000\n		},\n		{\n		  \"appId\": 461,\n		  \"appName\": \"诸葛io\",\n		  \"panelId\": 50373,\n		  \"panelName\": \"姚月光看板\",\n		  \"panelPlatform\": 3,\n		  \"panelOpenType\": 1,\n		  \"sendPeriod\": \"day 9:00\",\n		  \"createDatetime\": 1514450300000\n		},\n		{\n		  \"appId\": 461,\n		  \"appName\": \"诸葛io\",\n		  \"panelId\": 50279,\n		  \"panelName\": \"邵佳楠\",\n		  \"panelPlatform\": 3,\n		  \"panelOpenType\": 1,\n		  \"sendPeriod\": \"day 9:00\",\n		  \"createDatetime\": 1514443328000\n		}\n	  ]\n	}\n```\n\n#### 获取微信订阅看板用户信息\n- 地址：`wx_subscribe/getWxSubscribeUserInfoList.jsp`\n- 请求：GET\n- 参数：无\n- 备注：只有管理员能看到公司下所有订阅微信成员\n- 结果：\n```\n	{\n	  \"msg\": \"success\",\n	  \"flag\": 101,\n	  \"users\": [\n		{\n		  \"id\": 4,\n		  \"userId\": 178,\n		  \"openId\": \"o_d9A0t2h2HeBAWKKR_EbB4SaMj8\",\n		  \"createDatetime\": 1514271009000,\n		  \"username\": \"诸葛io\",\n		  \"telphone\": \"18201082929\",\n		  \"email\": \"zhuge@zhugeio.com\",\n		  \"wxInfo\": {\n			\"subscribe\": 1,\n			\"openid\": \"o_d9A0t2h2HeBAWKKR_EbB4SaMj8\",\n			\"nickname\": \"Chihz\",\n			\"sex\": 1,\n			\"language\": \"zh_CN\",\n			\"city\": \"\",\n			\"province\": \"\",\n			\"country\": \"North Korea\",\n			\"headimgurl\": \"http://wx.qlogo.cn/mmopen/PiajxSqBRaEIbIy7Lvm3juKcbWmzOSdjTO3W0ibVoVexOZ9Xm2KIqIkzVPxkjr9p7T6WDZ6x6r6PLwlzCq1U3gWw/0\",\n			\"subscribe_time\": 1510640311,\n			\"remark\": \"\",\n			\"groupid\": 0,\n			\"tagid_list\": []\n		  }\n		},\n		{\n		  \"id\": 5,\n		  \"userId\": 178,\n		  \"openId\": \"o_d9A0kTzQD_siidwOXFAFMU8s_A\",\n		  \"createDatetime\": 1514271007000,\n		  \"username\": \"诸葛io\",\n		  \"telphone\": \"18201082929\",\n		  \"email\": \"zhuge@zhugeio.com\",\n		  \"wxInfo\": {\n			\"subscribe\": 1,\n			\"openid\": \"o_d9A0kTzQD_siidwOXFAFMU8s_A\",\n			\"nickname\": \"Emery?\",\n			\"sex\": 1,\n			\"language\": \"en\",\n			\"city\": \"Chaoyang\",\n			\"province\": \"Beijing\",\n			\"country\": \"China\",\n			\"headimgurl\": \"http://wx.qlogo.cn/mmopen/dr66W8j9auevkR50u9hHoDoEc6yQjaic7RxnXw4bhFB4k8Dvjiaia9B0rGdjxqricGdBuich7KetNBj7x9bsg10icEF7jEia58Rw1aO/0\",\n			\"subscribe_time\": 1513233122,\n			\"remark\": \"\",\n			\"groupid\": 0,\n			\"tagid_list\": []\n		  }\n		}]\n	}\n```\n\n#### 获取微信二维码带参图片\n- 地址：`wx_subscribe/getWxQrCodeImage.jsp`\n- 请求：GET\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|app_id|是|整数|应用id||\n|platform|是|整数|平台类型||\n|panel_id|是|整数|看板id|||\n\n- 结果\n> - 成功\n>> 返回图片地址\n>\n> - 失败\n>> 响应数据：\n```JSON\n	{\n		flag: -101,\n		msg: \"fail\"\n	}\n```\n\n#### 获取微信jsapi签名\n- 地址：`wx_subscribe/getWxJsApiSignature.jsp`\n- 请求：GET\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|url|是|字符串|url|||\n\n- 结果\n> - 成功\n>> 响应数据：\n```\n	{\n		\"msg\": \"success\",\n		\"flag\": 101,\n		\"data\": {\n			\"noncestr\": \"tmCoA2XZ\",\n			\"signature\": \"2fcbd13f8a636e3f802a888d3a3df8caec33745c\",\n			\"timestamp\": 1514888256,\n			\"url\": \"http://www.zhugeio.com\"\n		}\n	}\n```\n>\n> - 失败\n>> 响应数据：\n```JSON\n	{\n		flag: -101,\n		msg: \"获取微信jsapi_ticket失败\"\n	}\n```\n\n#### 新增表\n- 微信与用户关联表\n```\nCREATE TABLE `wx_user_relation` (\n  `id` int(20) NOT NULL AUTO_INCREMENT,\n  `company_id` int(11) DEFAULT NULL,\n  `user_id` int(11) DEFAULT NULL,\n  `open_id` varchar(128) DEFAULT NULL COMMENT \'微信唯一id\',\n  `create_datetime` datetime DEFAULT NULL,\n  `is_delete` int(2) DEFAULT \'0\' COMMENT \'是否删除。0否，1是\',\n  PRIMARY KEY (`id`),\n  KEY `user_id` (`user_id`,`open_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n```\n\n- 微信用户订阅看板表\n```\nCREATE TABLE `wx_user_panel_subscribe_relation` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `wx_user_relation_id` int(11) DEFAULT NULL COMMENT \'微信与用户关联表id\',\n  `panel_id` int(11) DEFAULT NULL,\n  `send_period` varchar(32) DEFAULT NULL COMMENT \'发送周期\',\n  `create_datetime` datetime DEFAULT NULL,\n  `is_delete` int(2) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n```', '2', '0', '2017-12-26 18:33:40'), ('152', '1', '243', '- 前端请求接口返回数据乱码\n> 在`VM options`添加\n```\n-Dfile.encoding=UTF-8\n```', '2', '0', '2017-12-28 14:20:53'), ('153', '1', '244', '### mysql\n#### sem_account\n> sem帐号信息表\n```\nCREATE TABLE `sem_account` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `company_id` int(11) DEFAULT NULL COMMENT \'公司id\',\n  `app_id` int(11) DEFAULT NULL,\n  `utm_source` varchar(10) DEFAULT NULL COMMENT \'来源，如：baidu、sogou、360、sm\',\n  `sem_account` varchar(32) DEFAULT NULL COMMENT \'sem帐户\',\n  `sem_password` varchar(64) DEFAULT NULL COMMENT \'sem密码\',\n  `sem_token` varchar(100) DEFAULT NULL COMMENT \'sem密钥，baidu、sogou、sm都是token，360则为（apiKey,apiSecret）\',\n  `create_datetime` datetime DEFAULT NULL,\n  `is_delete` tinyint(4) DEFAULT \'0\' COMMENT \'是否删除。0否，1是\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT\n```\n\n#### sem_fail_log\n> sem错误日志表(可用于重试)\n```\nCREATE TABLE `sem_fail_log` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `sem_account_id` int(11) DEFAULT NULL,\n  `utm_source` varchar(10) DEFAULT NULL,\n  `sem_account` varchar(64) DEFAULT NULL,\n  `day_id` int(11) DEFAULT NULL,\n  `type` int(2) DEFAULT NULL COMMENT \'1.meta  2.kpi和queryWordKpi\',\n  `status` int(2) DEFAULT \'0\' COMMENT \'0只记录　1待获取　2获取成功　3取消获取\',\n  `retry_count` int(11) DEFAULT \'0\' COMMENT \'重试次数\',\n  `msg` varchar(5000) DEFAULT NULL,\n  `create_datetime` datetime DEFAULT NULL,\n  `update_datetime` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `status` (`status`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n```\n\n### impala\n#### kudu_sem_meta\n> sem元数据表\n```\nCREATE TABLE IF NOT EXISTS  kudu_sem_meta(\ncompany_id int          ,\ncampaign_id string      ,\nadgroup_id string       ,\nkeyword_id string       ,\ncreative_id string      ,\nutm_medium string       ,\nutm_source string       ,\nsem_account string      ,\ncampaign string         ,\nadgroup string          ,\nkeyword string          ,\ncreative string         ,\nPRIMARY KEY (company_id,campaign_id,adgroup_id,keyword_id,creative_id)\n)PARTITION BY HASH(campaign_id) PARTITIONS 2 STORED AS KUDU;\n```\n\n#### kudu_sem_kpi\n> sem kpi数据表\n```\nCREATE TABLE IF NOT EXISTS  kudu_sem_kpi(\nday_id int            ,\ncampaign_id string    ,\nadgroup_id   string   ,\nkeyword_id string     ,\ncreative_id string    ,\ncompany_id int        ,\ndevice_type_int int   ,\nbegin_date bigint     ,\nutm_medium string     ,\nutm_source string     ,\nsem_account string    ,\ncampaign      string  ,\nadgroup        string ,\nkeyword string        ,\ncreative string       ,\nimpression int        ,\nctr string            ,\nclick int             ,\ncost string           ,\ntarget_domain string  ,\ncity   string         ,\ndevice_type string    ,\nkeyword_rank string   ,\nPRIMARY KEY (day_id,campaign_id,adgroup_id,keyword_id,creative_id,company_id,device_type_int)\n)PARTITION BY HASH(day_id) PARTITIONS 2 STORED AS KUDU;\n```\n\n#### kudu_sem_query_word_kpi\n> sem搜索词数据表\n```\nCREATE TABLE IF NOT EXISTS  kudu_sem_query_word_kpi(\nday_id int            ,\ncampaign_id string    ,\nadgroup_id   string   ,\nkeyword_id string     ,\ncreative_id string    ,\ncompany_id int        ,\ndevice_type_int int   ,\nbegin_date bigint     ,\nutm_medium string     ,\nutm_source string     ,\nsem_account string    ,\ncampaign      string  ,\nadgroup        string ,\nkeyword string        ,\ncreative string       ,\nimpression int        ,\nctr string            ,\nclick int             ,\ncost string           ,\ntarget_domain string  ,\ncity   string         ,\ndevice_type string    ,\nquery_word string     ,\nPRIMARY KEY (day_id,campaign_id,adgroup_id,keyword_id,creative_id,company_id,device_type_int)\n)PARTITION BY HASH(day_id) PARTITIONS 2 STORED AS KUDU;\n```', '2', '0', '2018-01-15 18:08:10'), ('154', '1', '246', '[TOC]\n\n### Kotlin + SpringBoot + JPA(Hibernate) + Repository自定义方法\n```\nJPA是java为整合对数据库操作定义的一系列接口方案, 操作非常简单方便. 但有时需要自定义复杂sql操作的时候, 则可能需要对JPA方法扩展. 但若直接实现JPARepository接口, 则需实现它一系列方法, 这显然是不可取的.本文则记录如何简单的扩展自定义方法\n```\n\n#### `pom.xml`\n```\n<project>\n	<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.5.9.RELEASE</version>\n    </parent>\n\n    <properties>\n        <druid.version>1.0.22</druid.version>\n        <jackson-module-kotlin.version>2.9.3</jackson-module-kotlin.version>\n        <java.version>1.8</java.version>\n        <junit.version>4.12</junit.version>\n        <kotlin.version>1.2.10</kotlin.version>\n        <mysql.version>5.1.29</mysql.version>\n        <mybatis-spring-boot-starter.version>1.3.1</mybatis-spring-boot-starter.version>        <org.springframework.boot.version>1.5.9.RELEASE</org.springframework.boot.version>\n        <spring-boot-starter-log4j.version>1.3.8.RELEASE</spring-boot-starter-log4j.version>\n\n        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>${junit.version}</version>\n            <scope>test</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>com.fasterxml.jackson.module</groupId>\n            <artifactId>jackson-module-kotlin</artifactId>\n            <version>${jackson-module-kotlin}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.springframework.boot</groupId>\n                    <artifactId>spring-boot-starter-logging</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-log4j</artifactId>\n            <version>${spring-boot-starter-log4j.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-stdlib-jre8</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-reflect</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n		\n		<dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>${druid.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>${mysql.version}</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <sourceDirectory>${project.basedir}/src/main/kotlin</sourceDirectory>\n        <testSourceDirectory>${project.basedir}/src/test/kotlin</testSourceDirectory>\n        <plugins>\n            <plugin>\n                <artifactId>kotlin-maven-plugin</artifactId>\n                <groupId>org.jetbrains.kotlin</groupId>\n                <version>${kotlin.version}</version>\n                <configuration>\n                    <compilerPlugins>\n                        <plugin>spring</plugin>\n                    </compilerPlugins>\n                    <jvmTarget>1.8</jvmTarget>\n                </configuration>\n                <executions>\n                    <execution>\n                        <id>compile</id>\n                        <phase>compile</phase>\n                        <goals>\n                            <goal>compile</goal>\n                        </goals>\n                    </execution>\n                    <execution>\n                        <id>test-compile</id>\n                        <phase>test-compile</phase>\n                        <goals>\n                            <goal>test-compile</goal>\n                        </goals>\n                    </execution>\n                </executions>\n                <dependencies>\n                    <dependency>\n                        <groupId>org.jetbrains.kotlin</groupId>\n                        <artifactId>kotlin-maven-allopen</artifactId>\n                        <version>${kotlin.version}</version>\n                    </dependency>\n                </dependencies>\n            </plugin>\n        </plugins>\n    </build>\n</project\n```\n\n#### `application-jpa.properties`\n```\nspring.datasource.url=jdbc:mysql://localhost:3306/vanki2?characterEncoding=utf8&characterSetResults=utf8\nspring.datasource.username=root\nspring.datasource.password=zoufanqi\n\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.name=mysqldb\n\n# 初始化大小，最小，最大\nspring.datasource.initialSize=5\nspring.datasource.minIdle=5\nspring.datasource.maxActive=20\n# 配置获取连接等待超时的时间\nspring.datasource.maxWait=60000\n# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒\nspring.datasource.timeBetweenEvictionRunsMillis=60000\n# 配置一个连接在池中最小生存的时间，单位是毫秒\nspring.datasource.minEvictableIdleTimeMillis=300000\nspring.datasource.validationQuery=SELECT 1 FROM DUAL\nspring.datasource.testWhileIdle=true\nspring.datasource.testOnBorrow=false\nspring.datasource.testOnReturn=false\n# 打开PSCache，并且指定每个连接上PSCache的大小\nspring.datasource.poolPreparedStatements=true\nspring.datasource.maxPoolPreparedStatementPerConnectionSize=20\n# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，\'wall\'用于防火墙\nspring.datasource.filters=stat,wall,log4j\n# 通过connectProperties属性来打开mergeSql功能；慢SQL记录\nspring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n# 合并多个DruidDataSource的监控数据\n#spring.datasource.useGlobalDataSourceStat=true\n\nspring.jpa.database=MYSQL\nspring.jpa.show-sql=true\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect\n```\n\n#### 类\n##### 目录结构\n```\ncom.qiqinote.repository.base.BaseRepository\n\ncom.qiqinote.repository.customize.UserCustomizeRepository\ncom.qiqinote.repository.customize.impl.UserRepository\n\ncom.qiqinote.repository.UserRepository\n```\n\n##### `BaseRepository.kt`\n```\npackage com.qiqinote.repository.base\n\nimport org.springframework.data.repository.NoRepositoryBean\nimport org.springframework.data.repository.PagingAndSortingRepository\nimport java.io.Serializable\n\n/**\n * Created by vanki on 2018/1/23 14:49.\n */\n@NoRepositoryBean\ninterface BaseRepository<T, ID : Serializable?> : PagingAndSortingRepository<T, ID> {\n}\n```\n\n##### `UserRepositoryImpl.kt`\n```\npackage com.qiqinote.repository.customize\n\nimport com.qiqinote.entity.User\n\n/**\n * Created by vanki on 2018/1/23 14:44.\n */\ninterface UserCustomizeRepository {\n    fun test(name: String): MutableList<User?>?\n}\n```\n\n##### `UserRepositoryImpl.kt`\n> ***注意***\n>> 1. 实现 `UserCustomizeRepository`\n>> 2. 名称必须与对外接口名对应(加上`Impl`), 或者注解加上bean名称 `@Repository(\"userRepositoryImpl\")`\n\n```\npackage com.qiqinote.repository.customize.impl\n\nimport com.qiqinote.entity.User\nimport com.qiqinote.repository.customize.UserCustomizeRepository\nimport org.springframework.stereotype.Repository\nimport javax.persistence.EntityManager\nimport javax.persistence.PersistenceContext\n\n/**\n * Created by vanki on 2018/1/23 14:38.\n */\n@Repository\nclass UserRepositoryImpl : UserCustomizeRepository {\n\n    @PersistenceContext\n    private lateinit var entityManager: EntityManager\n\n    override fun test(name: String): MutableList<User?>? {\n        val sql = \"select * from user where alias=?1\"\n        val query = this.entityManager.createNativeQuery(sql, User::class.java)\n        query.setParameter(1, name)\n        return query.resultList as MutableList<User?>?\n    }\n}\n```\n\n##### `UserRepository`\n> 对外的接口\n\n```\npackage com.qiqinote.repository\n\nimport com.qiqinote.entity.User\nimport com.qiqinote.repository.base.BaseRepository\nimport com.qiqinote.repository.customize.UserCustomizeRepository\n\n/**\n * Created by vanki on 2018/1/23 14:04.\n */\ninterface UserRepository : BaseRepository<User, Long>, UserCustomizeRepository {\n}\n```\n\n#### Application.kt\n```\npackage com.qiqinote\n\nimport org.springframework.boot.SpringApplication\nimport org.springframework.boot.autoconfigure.SpringBootApplication\nimport org.springframework.context.annotation.ComponentScan\nimport org.springframework.context.annotation.PropertySource\n\n/**\n * Created by vanki on 2018/1/17 21:46.\n */\n@SpringBootApplication\n@ComponentScan(basePackages = arrayOf(\"com.qiqinote.repository\"))\n@PropertySource(value = \"classpath:application-jpa.properties\")\nclass Application\n\nfun main(args: Array<String>) {\n    SpringApplication.run(Application::class.java, *args);\n}\n```\n\n#### 测试类\n```\npackage com.qiqinote.repository\n\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.boot.test.context.SpringBootTest\nimport org.springframework.test.context.junit4.SpringRunner\n\n/**\n * Created by vanki on 2018/1/18 18:00.\n */\n@RunWith(SpringRunner::class)\n@SpringBootTest\nclass TestUserRepository {\n    @Autowired\n    private lateinit var userRepository: UserRepository\n\n    @Test\n    fun t1() {\n        val test = this.userRepository.test(\"name2\")\n    }\n}\n```', '2', '0', '2018-01-23 17:53:27');
INSERT INTO `note_detail` VALUES ('155', '1', '249', '- 安装brew\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n- 安装node.js\n```\nbrew install nodejs\n```\n\n- 安装淘宝镜像\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n- 安装webpack\n```\ncnpm install webpack -g\n```\n\n- 安装vue脚手架\n```\nnpm install vue-cli -g\n```\n\n- 根据模板创建项目\n```\ncd 目录路径\nvue init webpack-simple 项目名<项目名不能用中文>\n```\n\n- 安装项目依赖\n```\ncd 工程目录路径\nnpm install	# 注意, 不是cnpm\n```\n\n- 安装 vue 路由模块`vue-router`和网络请求模块`vue-resource`\n```\ncnpm install vue-router vue-resource --save\n```\n\n- 启动项目\n```\nnpm run dev\n```', '2', '0', '2018-01-26 16:18:34'), ('156', '1', '250', '[TOC]\n\n文档创建于: 2018-01-29\n\n### 获取用户年终盘点数据\n- 地址：`year_inventory/getByAccount.jsp`\n- 请求： GET\n- 参数：\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|account|是|字符串|用户登录帐号|手机号/邮箱, 用户登录后会自动获取|\n\n- 结果\n> - 获取到年终盘点数据\n>> 响应数据：\n```JSON\n	{\n	  \"flag\": 101,\n	  \"data\": {\n		\"zg_id\": 590275,\n		\"app_user_id\": \"18925010936\",\n		\"周均访问天数\": null,\n		\"会话总次数\": 100,\n		\"会话总时长(min)\": 740,\n		\"最晚时间\": 1517191997000,\n		\"使用习惯等级\": \"G1\",\n		\"使用习惯标签\": \"业精于勤、数据SENSE\",\n		\"研究用户次数\": 34,\n		\"分析用户真实案例次数\": 97,\n		\"用户研究等级\": \"A1\",\n		\"用户研究标签\": \"心系用户、阅人无数\",\n		\"分析行为次数\": 299,\n		\"分析漏斗次数\": 44,\n		\"分析留存次数\": null,\n		\"分析能力等级\": \"B2\",\n		\"分析能力标签\": \"入门分析\",\n		\"访问概览次数\": null,\n		\"概览等级\": \"D2\",\n		\"概览标签\": \"\",\n		\"获取次数\": null,\n		\"获取等级\": \"E2\",\n		\"获取标签\": \"\",\n		\"创建看板次数\": 2,\n		\"看板等级\": \"F1\",\n		\"看板标签\": \"有条不紊\",\n		\"account\": \"18925010936\"\n	  },\n	  \"msg\": \"success\"\n	}\n```\n>\n> - 未获取到年终盘点数据\n>> 响应数据：\n```JSON\n	{\n	  \"flag\": 101,\n	  \"data\": {\n		\"account\": \"1020699930@qq.com\",\n		\"createDatetime\": 1416538263000\n	  },\n	  \"msg\": \"success\"\n	}\n```\n\n', '2', '0', '2018-01-29 17:05:17'), ('157', '1', '251', '[TOC]\n\n### sdkv\n#### deploy-zoufanqi.sh\n```\n#!/bin/bash\n\n####################\ndocker_name=zg2_sdkv\ntomcat_path=../tomcat\nproject_path=./zhugesdkv\nwar_path=./zhugesdkv/zhugesdkv-web/target\nwar_name=zhugesdkv.war\ngit_branch=rs.master.zoufanqi\n####################\n\nshell_path=`pwd`\n\ncd $shell_path/$project_path\ngit checkout $git_branch\ngit pull origin $git_branch\nmvn clean package -T 1C -Dmaven.test.skip=true -Dmaven.compile.fork=true\n\ncd $shell_path/$war_path\ntomcat_path=$shell_path/$tomcat_path/\ncp -rf *.war $tomcat_path/webapps/$war_name\nrm -rf $tomcat_path/ROOT\n\ndocker restart $docker_name\n```\n\n#### just-compile.sh\n```\n#!/bin/bash\n\n####################\nproject_path=./zhugesdkv\ngit_branch=rs.master.zoufanqi\n####################\n\nshell_path=`pwd`\n\ncd $shell_path/$project_path\ngit checkout $git_branch\ngit pull origin $git_branch\nmvn clean package -T 1C -Dmaven.test.skip=true -Dmaven.compile.fork=true\n```\n\n#### deploy-scp-test3-war.sh\n```\n#!/bin/bash\n\n####################\ndocker_name=zg2_sdkv\ntomcat_path=../tomcat\nwar_path=test3:/data/zhugeio_gp/deploy/zhugesdkv/zhugesdkv-web/target\nwar_name=zhugesdkv.war\n####################\n\nshell_path=`pwd`\n\ntomcat_path=$shell_path/$tomcat_path/\nscp -r $war_path/*.war $tomcat_path/webapps/$war_name\nrm -rf $tomcat_path/ROOT\n\ndocker restart $docker_name\n```\n\n### api\n#### deploy-zoufanqi.sh\n```\n#!/bin/bash\n\n####################\ndocker_name=zg2_api\ntomcat_path=../tomcat\nproject_path=./zhugeio-api\nwar_path=./zhugeio-api/zhugeio-api-web/target\nwar_name=zhugeio-api.war\ngit_branch=rs.master.zoufanqi\n####################\n\nshell_path=`pwd`\n\ncd $shell_path/$project_path\ngit checkout $git_branch\ngit pull origin $git_branch\nmvn clean package -T 1C -Dmaven.test.skip=true -Dmaven.compile.fork=true\n\ncd $shell_path/$war_path\ntomcat_path=$shell_path/$tomcat_path/\ncp -rf *.war $tomcat_path/webapps/$war_name\nrm -rf $tomcat_path/ROOT\n\ndocker restart $docker_name\n```\n\n#### just-compile.sh\n```\n#!/bin/bash\n\n####################\nproject_path=./zhugeio-api\ngit_branch=rs.master.zoufanqi\n####################\n\nshell_path=`pwd`\n\ncd $shell_path/$project_path\ngit checkout $git_branch\ngit pull origin $git_branch\nmvn clean package -T 1C -Dmaven.test.skip=true -Dmaven.compile.fork=true\n```\n\n#### deploy-scp-test3-war.sh\n```\n#!/bin/bash\n\n####################\ndocker_name=zg2_api\ntomcat_path=../tomcat\nwar_path=test3:/data/zhugeio_api_gp/deploy/zhugeio-api/zhugeio-api-web/target\nwar_name=zhugeio-api.war\n####################\n\nshell_path=`pwd`\n\ntomcat_path=$shell_path/$tomcat_path/\nscp -r $war_path/*.war $tomcat_path/webapps/$war_name\nrm -rf $tomcat_path/ROOT\n\ndocker restart $docker_name\n```', '2', '0', '2018-01-29 17:36:56'), ('158', '1', '252', '[TOC]\n\n文档创建于: 2018-01-31\n\n### 接口\n#### 标记/取消标记 重要事件(废弃)\n- 请求地址: `event/updateEventMarkType.jsp (接口已废弃)`\n\n#### 添加/修改 事件组\n- 请求地址: `eventgroup/upsertEventGroup.jsp`\n- 登录请求: `是`\n- 请求类型: `POST`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整型|应用id||\n|platform|是|整型|平台类型|与事件平台类型对应|\n|eventGroupName|是|字符串|事件组名称||\n|eventGroupId|否/是|整型|事件组id|添加时为空, 修改时必填|\n\n- 结果\n> - 成功\n```JSON\n	{\n	  \"code\": 10001,\n	  \"msg\": \"success\",\n	  \"eventGroupId\": 1\n	}\n```\n>\n> - 失败 - 无操作权限：\n```JSON\n	{\n	  \"code\": -10001,\n	  \"msg\": \"无权限\"\n	}\n```\n>\n> - 失败 - 事件组名称长度不符\n>> 响应数据：\n```JSON\n	{\n	  \"code\": -10008,\n	  \"msg\": \"事件组名称长度不符\"\n	}\n```\n>\n> - 失败 - 事件组重名\n>> 响应数据：\n```JSON\n	{\n	  \"code\": -10008,\n	  \"msg\": \"事件组已存在\"\n	}\n```\n>\n> - 失败\n>> 响应数据：\n```JSON\n	{\n	  \"code\": -10008,\n	  \"msg\": \"参数错误\"\n	}\n```\n\n#### 删除事件组\n- 请求地址: `eventgroup/deleteEventGroup.jsp`\n- 登录请求: `是`\n- 请求类型: `POST`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整型|应用id||\n|eventGroupId|是|整型|事件组id|||\n\n- 结果\n> - 成功\n```JSON\n	{\n	  \"code\": 10001,\n	  \"msg\": \"success\"\n	}\n```\n>\n> - 失败 - 无操作权限：\n```JSON\n	{\n	  \"code\": -10001,\n	  \"msg\": \"无权限\"\n	}\n```\n>\n> - 失败\n```JSON\n	{\n	  \"code\": -10008,\n	  \"msg\": \"参数错误\"\n	}\n```\n\n#### 事件与事件组关联关系相关操作\n- 请求地址: `eventgroup/operateGroupRelations.jsp`\n- 登录请求: `是`\n- 请求类型: `POST`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整型|应用id||\n|eventGroupId|是/否|整型|事件组id|添加/修改必填, 删除(未分组)关联关系时传`null`或`-1`|\n|eventIds|是|字符串|事件id|多个以`,`分隔|\n\n- 结果\n> - 成功 - 添加或修改\n```JSON\n	{\n	  \"code\": 10001,\n	  \"msg\": \"success\",\n	  \"eventIdAndRelationIdMap\": { <!-- 事件id: 事件组与事件关联id -->\n		\"24051236\": 2,\n		\"24051237\": 3\n	  }\n	}\n```\n>\n> - 成功 - 删除\n```JSON\n	{\n	  \"code\": 10001,\n	  \"msg\": \"success\",\n	  \"eventIdAndRelationIdMap\": { <!-- 事件id: 1删除成功, 0删除失败 -->\n		\"24051236\": 1,\n		\"24051237\": 1\n	  }\n	}\n```\n>\n> - 失败\n```JSON\n	{\n	  \"code\": -10008,\n	  \"msg\": \"参数错误\"\n	}\n```\n>\n> - 失败 - 无操作权限：\n```JSON\n	{\n	  \"code\": -10001,\n	  \"msg\": \"无权限\"\n	}\n```\n\n#### 事件组列表\n- 请求地址: `eventgroup/listOfEventGroup.jsp`\n- 登录请求: `是`\n- 请求类型: `GET`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整型|应用id||\n|platform|是|整型|平台类型|与事件平台类型对应||\n\n- 结果\n> - 成功\n```JSON\n	{\n	  \"code\": 10001,\n	  \"msg\": \"success\",\n	  \"data\": [\n				{\n				  \"groupId\": 3,\n				  \"groupName\": \"group1\"\n				},\n				{\n				  \"groupId\": 4,\n				  \"groupName\": \"group2\"\n				}\n			  ]\n	}\n```\n>\n> - 失败\n```JSON\n	{\n	  \"code\": -10001,\n	  \"msg\": \"参数错误\"\n	}\n```\n\n#### 事件数据分组\n- 请求地址: `data/queryEventMetasOfGroup.jsp`\n- 登录请求: `是`\n- 请求类型: `GET`\n\n***与原接口`data/queryEventMetas.jsp`参数与code码处理一致, 只是成功返回值数据结构变动***\n\n- 结果\n> - 成功\n```JSON\n	{\n	  \"code\": 10001,\n	  \"msg\": \"success\",\n	  \"data\": [\n		{	<!-- 正常分组信息 -->\n			\"groupId\": 2,\n			\"groupName\": \"group1\",\n			\"eventList\": [\n			{\n				\"click_analysis\": false,\n				\"event_id\": 24051236,\n				\"event_name\": \"线下报名(CRM端)\",\n				\"event_hidden\": 0,\n				\"event_type\": 0,\n				\"is_stop\": 0,\n				\"alias_name\": \"\",\n				\"event_attrs\": [\n				{\n					\"hidden\": 0,\n					\"dimension_sub\": \"event_attr\",\n					\"encryption_type\": 0,\n					\"attr_id\": 29647707,\n					\"attr_name\": \"价格名称\",\n					\"event_id\": 24051236,\n					\"prop_type\": 1,\n					\"is_stop\": 0\n				}],\n				\"stop_date_time\": null,\n				\"insert_time\": \"2018-01-03 10:27:10\"\n			}]\n		},\n		{	<!-- 未分组信息 -->\n			\"groupId\": -1,\n			\"groupName\": null,\n			\"eventList\": [\n			{\n				\"click_analysis\": false,\n				\"event_id\": 24051234,\n				\"event_name\": \"查看课程详情\",\n				\"event_hidden\": 0,\n				\"event_type\": 0,\n				\"is_stop\": 0,\n				\"alias_name\": \"\",\n				\"event_attrs\": [\n				{\n					\"hidden\": 0,\n					\"dimension_sub\": \"event_attr\",\n					\"encryption_type\": 0,\n					\"attr_id\": 29647671,\n					\"attr_name\": \"课程名称\",\n					\"event_id\": 24051234,\n					\"prop_type\": 1,\n					\"is_stop\": 0\n				}],\n				\"stop_date_time\": null,\n				\"insert_time\": \"2018-01-03 10:27:06\"\n			}]\n		}]\n	}\n```\n>\n> - 失败\n```JSON\n	{\n	  \"code\": -10008,\n	  \"msg\": \"参数错误\"\n	}\n```\n\n### mysql库表\n> 库: sdkv\n\n#### 修改表\n\n- 事件表: `event`\n```\n新增字段sql:\nalter table `event` add `mark_type` int(2) DEFAULT NULL COMMENT \'事件标记类型. 1重要事件\';\n```\n\n#### 新增表\n- 事件组表\n> 表结构:\n```\nCREATE TABLE `event_group` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `app_id` int(11) DEFAULT NULL COMMENT \'应用id\',\n  `create_user_id` int(11) DEFAULT NULL,\n  `group_name` varchar(64) DEFAULT NULL COMMENT \'组名称\',\n  `platform` int(2) DEFAULT NULL COMMENT \'所属平台, 与事件所属平台对应\',\n  `create_datetime` datetime DEFAULT NULL,\n  `update_datetime` datetime DEFAULT NULL,\n  `is_delete` int(2) DEFAULT \'0\',\n  PRIMARY KEY (`id`),\n  KEY `app_id` (`app_id`,`group_name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n```\n```\n上面创建表结构如果添加则忽略\nalter table `event_group` add `platform` int(2) DEFAULT NULL COMMENT \'所属平台, 与事件所属平台对应\';\n```\n\n- 事件与事件组关联关系表\n> 表结构:\n```\nCREATE TABLE `event_group_relation` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `event_group_id` int(11) DEFAULT NULL,\n  `app_id` int(11) DEFAULT NULL,\n  `event_id` int(11) DEFAULT NULL,\n  `operate_user_id` int(11) DEFAULT NULL COMMENT \'最后操作用户\',\n  `create_datetime` datetime DEFAULT NULL,\n  `is_delete` int(2) DEFAULT \'0\',\n  PRIMARY KEY (`id`),\n  KEY `event_group_id` (`event_group_id`,`app_id`,`event_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n```', '2', '0', '2018-01-31 15:47:23'), ('159', '1', '256', '# 智能触达项目设计\n\n\n![image](http://7d9rmc.com1.z0.glb.clouddn.com/%E6%99%BA%E8%83%BD%E8%A7%A6%E8%BE%BE%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1.png)\n\n## 工作流概述\n\n智能触达的核心是工作流调度，允许用户按照自己的需要来随意编排自动化营销流程（参见hubspot）。\n\n一个工作流的核心抽象组件\n\n1. Trigger - 触发器：规定了以何种方式来启动工作流实例，比如通过表单触发或者通过事件匹配。\n2. WorkUnit - 工作单元：工作单元是工作流的具体执行逻辑分解，可以方便的复用，基本包括以下类型：a. 执行单元 b. 事件匹配单元 c. 逻辑分支单元。通常，工作单元的执行都应该是异步非阻塞的，通过接收一组参数(可能来自上下文，也可能来自静态绑定)，进行计算，然后决定工作流的下一步走向。工作单元有起始点(start_point)，并且能够静态(通过goto关键字)或动态的方式来指定下一步要执行的工作单元。\n3. Context - 上下文: 上下文为工作流实例维持了一组变量，供工作单元之间共享数据使用，也可以动态渲染工作单元参数。另外Context目前也提供了流程控制API来控制流程走向(但事实证明这样设计很糟糕……)\n4. FlowInstanceStatus - 工作流实例状态：RUNNING - 运行中/WAITING - 等待目标事件中/FAILURE - 业务性的失败/ERROR - 系统性的错误/FINISHED - 顺利执行完毕\n5. FlowDefinitionListener: 基于工作流定义状态变化的Listener\n6. FlowRuntimeListener: 基于工作流实例状态变化的Listener\n7. Config: 单独针对工作流的配置，这些配置会影响调度行为。\n8. Event - 事件: 整套工作流的执行都是通过各种事件来驱动的，比如诸葛的用户行为事件会触发一个工作流的执行，各种工作单元的执行通常并不是真的由它自身去完成任务，而是通过向其它服务发送事件来达成目标。\n9. EventBus - 事件总线：事件的传播途径，通常是各种消息队列系统。\n10. Timer - 时间调度器：工作流的执行有诸多方面与时间相关，比如纯粹等待到某一个时间点再去执行或者规定某个事件的超时时间等，需要一个专门的时间调度器来处理这些事情。时间调度器往往也是通过事件通知或者逻辑异步回调的方式来达成目标。\n11. FlowDefinition - 工作流定义：通常由Trigger、WorkUnit、FlowDefinitionListener、FlowInstanceListener、Config这几部分组合而成，可以由各种数据格式进行描述，目前是JSON格式。\n12. FlowInstance - 工作流实例：如果把FlowDefinition看做是程序，那么FlowInstance就是进程，FlowInstance也像进程描述符那样拥有各种属性。\n\n\n\n以触发类的执行为例，看工作流的执行，目前一个触发类的定义：\n\n```\n{\n  \"version\": \"1.0\",\n  \"triggers\": [\n    {\n      \"name\": \"zhuge_event_trigger\",\n      \"type\": \"zhuge_event_trigger\",\n      \"user_range\": [\n        {\n          \"property_name\": \"手机号\",\n          \"operator\": \"=\",\n          \"params\": [\n            \"17600817832\"\n          ]\n        }\n      ],\n      \"event\": {\n        \"event_name\": \"登录-登录成功\",\n        \"event_properties\": [\n          {\n            \"property_name\": \"邮箱\",\n            \"operator\": \"=\",\n            \"params\": [\n              \"chihongze@zhugeio.com\"\n            ]\n          }\n        ]\n      }\n    }\n  ],\n  \"units\": [\n    {\n      \"name\": \"web_hook\",\n      \"type\": \"web_hook\",\n      \"args\": {\n        \"url\": \"http://localhost:1219/v1/webhook\",\n        \"waiting\": \"1 minute\"\n      },\n      \"start_point\": true,\n      \"goto\": \"waiting_trans_event\"\n    },\n    {\n      \"name\": \"waiting_trans_event\",\n      \"type\": \"waiting_trans_event\",\n      \"args\": {\n        \"timeout\": \"1 days\",\n        \"event\": {\n          \"event_name\": \"看板-进入模块\",\n          \"event_properties\": [\n            {\n              \"property_name\": \"看板数目\",\n              \"operator\": \">\",\n              \"params\": [\n                10\n              ]\n            }\n          ]\n        }\n      }\n    }\n  ]\n}\n```\n\n执行逻辑\n\n<b>创建工作流定义部分</b>\n\n1. web端将用户提交的表单拼接为工作流定义，并将定义通过API传递给clockwork\n2. clockwork解析定义，检查定义的合法性，为其生成ID标识，并保存该定义到数据库(MySQL)\n3. 回调com.zhugeio.clockwork.mkt.trigger.ZhugeEventTrigger的onFlowDefinitionCreated方法，注册事件到SSDB\n\n如果把工作流看作更高级别的程序，那么这个过程可以理解为编译和安装的过程。\n\n<b>触发执行</b>\n\n1. etl-cloud将事件同SSDB当中工作流定义所注册的事件进行对比，如果匹配，那么附加上工作流定义ID转发给clockwork-api\n2. clockwork-api通过事件和zg\\_id来匹配出工作流定义和实例对象(com.zhugeio.clockwork.mkt.ZhugeUserEventDispatcher)\n3. 如果没有匹配到工作流实例，则将事件作为参数，传递给ZhugeEventTrigger.startFlowInstance()方法，ZhugeEventTrigger会匹配传入事件和用户属性(缓存在SSDB中，可以快速匹配)是否符合启动新实例的要求，如果符合，则启动新实例(即向状态SSDB中增加一个新的FlowInstance记录，并依据start\\_point开始执行新的单元)，ZhugeEventTrigger会增加触发数 + 1。\n4. 开始执行第一个工作单元web\\_hook(com.zhugeio.clockwork.mkt.unit.SyncWebHook)，如果单元中有waiting选项，则先在timer中注册一个定时通知。web\\_hook单元其实并不会自己去调用指定的webhook连接，甚至连用户属性它都不会去取，而是向Postman系统发送一个事件，然后工作流就进入了waiting状态。\n5. 等Postman发送成功，会通过FlowScheduler.handleEvent来回馈发送成功/失败事件，web\\_hook工作单元会进行发送成功/失败的计数，并且决策工作流走向，如果失败，就不再执行了，如果成功，就会进入下一个waiting\\_trans\\_event。\n6. waiting\\_trans\\_event单元会使工作流进入waiting状态，直到通过ZhugeUserEventDispatcher捕获了目标事件或者超时。waiting\\_trans\\_event会记录转化计数。\n\n转化类也一样，只不过多了一个等待单元。\n\n## 工作流组件细节\n\n<b>FlowDefinition</b>\n\n工作流定义\n\n```\n核心包：com.zhugeio.clockwork.definition\n\n工作流定义Domain对象：\ncom.zhugeio.clockwork.definition.FlowDefinition\n\n工作流管理接口：\ncom.zhugeio.clockwork.definition.FlowDefinitionService\n\n工作流定义编解码器：\ncom.zhugeio.clockwork.definition.codec\n```\n\n<b>FlowScheduler</b>\n\n工作流调度\n\n```\n核心包：com.zhugeio.clockwork.runtime\n\n上下文：com.zhugeio.clockwork.runtime.context\n\n事件抽象：com.zhugeio.clockwork.runtime.event\n\n调度器抽象：com.zhugeio.clockwork.runtime.FlowScheduler\n\nFlowInstance Domain: com.zhugeio.clockwork.runtime.FlowInstance\n\nUnitInstance Domain:\ncom.zhugeio.clockwork.runtime.UnitInstance\n```\n\n<b>Trigger</b>\n\n```\ncom.zhugeio.clockwork.trigger.FlowTrigger\n```\n\n<b>WorkUnit</b>\n\n```\ncom.zhugeio.clockwork.unit.WorkUnit\n```\n\n<b>EventDispatcher</b>\n\n```\ncom.zhugeio.clockwork.mkt.ZhugeUserEventDispatcher\n```\n\n## 时间调度器\n\n```\ncom.zhugeio.clockwork.timer\n\n时间调度器客户端\ncom.zhugeio.clockwork.timer.DirectTimerClient\n\n时间任务Domain对象\ncom.zhugeio.clockwork.timer.TimerTask\n\n时间调度器\ncom.zhugeio.clockwork.timer.SingleProcessTimer\n```\n\n时间调度器的基本原理就是将任务按照执行时间戳存储在有序集合中，比如各种查找树、SkipList等，然后根据需要，周期性的从该集合中获取早于当前时间点的任务，然后根据任务类型进行回调执行。\n\nclockwork的时间调度器使用redis的zset(时间复杂度为O(LogN))对任务进行保存，通过简单的hash算法来进行分布式扩展。\n\n1. 每个存储时间任务的zset作为一个bucket，每个bucket的连接信息在配置文件中配置。\n2. 每次添加调度任务，用taskId % bucketSize获得目标bucket编号并存入。\n3. 每次TimerScheduler会抢占一个bucket进行消费。\n\n可以随意扩展TimerScheduler的数目，也可以随意扩展bucket的数量(不像缓存，需要根据key来精确的获取value，时间调度器只要能批量获取到当前时间点可调度的任务就可以了)，但目前大bucket中的任务无法自动迁移到小bucket。\n\n## Postman\n\n```\ncom.zhugeio.clockwork.postman\n```\n\nPostman负责了所有具体的渠道发送工作，发短信、发推送、发webhook、发微信……\n\n总体逻辑是从消息队列周期拉取一波FlowTask(周期时间以不影响业务实时性为基准，且又能批量处理，目前性能，单机(4核8G)日300w触发以下可抗)，将任务解码成相应的SendRequest，然后发送到不同的Channel批量发送后批量返回结果。\n\n![image](http://7d9rmc.com1.z0.glb.clouddn.com/postman.png)\n\n## 工程相关\n\n代码组织：代码级的Integration，没有用依赖注入……\n\n单元测试\n\n集成测试：http://gl.zhugeio.com/marketing-cloud/clockwork\\_api\\_test\n\n编码规范：Google Java Style，每次提交代码之前，通过gradle来格式化代码\n\n本地测试\n\n测试环境\n\n测试环境部署\n\nSaas环境部署\n\n私有部署\n\n持续集成\n\n自动化部署与持续交付\n\n## 下一步技术上要做的事情\n\n### 优化工作流引擎\n\n智能触达不像分析，有诸如Spark、Hadoop这样现成的框架可用，市面上没有现成的开源框架可用，需要自己造轮子。\n\n1. 工作流控制API\n2. 优化状态存储、上下文存储，需要与分布式扩展方案一并考虑\n3. 一切事件化、异步化，更好的事件类型层次和事件处理抽象，工作流调度要与其它系统解耦，全部通过事件来通信。\n4. 更细致的调度选项，比如锁选项、Mailbox、FlowInstanceLocator等等\n5. 细化触发器和工作单元，工作单元Faas化，提升工作单元的可复用率。\n6. 开拓场景，工作流的本质是调度万物，辅助产品进行更多的场景探索，比如与AI和机器学习系统的结合等等。\n7. 其它种种性能优化细节，比如ID生成……\n\n\n工作流引擎的目标：性能有大幅提升(要在允许的成本之下扛过某个最低指标，指标待定，但当前性能上可提升的点实在太多)、API设计简洁且易用、工作单元具有极高的可服用率以及极低的开发成本(为下一步的各种随意拖拽做准备)\n\n计划：维护两个分支，一个正式分支，一个实验分支，用实验分支实验新特性，然后向正式分支迁移，让正式分支越来越好，实验分支可考虑未来开源。\n\n多从Erlang、Akka以及各种操作系统内核借鉴灵感，工作流与它们在本质上是一样的，只不过它是在更高的业务层次上去抽象。\n\n\n工作单元细化后的触发类定义：\n\n```\n{\n  \"version\": \"1.0\",\n  \"triggers\": [\n    {\n      \"name\": \"zhuge_event_trigger\",\n      \"type\": \"zhuge_event_trigger\",\n      \"user_range\": [\n        {\n          \"property_name\": \"手机号\",\n          \"operator\": \"=\",\n          \"params\": [\n            \"17600817832\"\n          ]\n        }\n      ],\n      \"event\": {\n        \"event_name\": \"登录-登录成功\",\n        \"event_properties\": [\n          {\n            \"property_name\": \"邮箱\",\n            \"operator\": \"=\",\n            \"params\": [\n              \"chihongze@zhugeio.com\"\n            ]\n          }\n        ]\n      }\n    }\n  ],\n  \"units\": [\n    {\n        \"name\": \"add_trigger_count\",\n        \"type\": \"counter\",\n        \"args\": {\n            \"counter_item\": \"trigger_count\",\n            \"async\": true\n        },\n        \"description\": \"增加触发数\",\n        \"start_point\": true,\n        \"goto\": \"waiting_send_webhook\"\n    },\n    {\n        \"name\": \"waiting_send_webhook\",\n        \"type\": \"sleep\",\n        \"args\": {\n            \"time\": \"1 minute\"\n        },\n        \"description\": \"\",\n        \"goto\": \"is_flow_definition_paused\"\n    },\n    {\n        \"name\": \"is_flow_definition_paused\",\n        \"type\": \"switch\",\n        \"args\": {\n            \"expr\": \"$flow_definition.status\",\n            \"cases\": [\n                {\n                    \"value\": \"paused\",\n                    \"goto\": \"finish_flow\"\n                },\n                {\n                    \"value\": \"common\",\n                    \"goto\": \"judge_time_scope\"\n                }\n            ]\n        }\n    },\n    {\n        \"name\": \"judge_time_scope\",\n        \"type\": \"judge_time_scope\",\n        \"args\": {\n            \"min_time\": \"09:00\",\n            \"max_time\": \"21:00\",\n            \"out_of_scope_action\": \"waiting\"\n        },\n        \"goto\": \"web_hook\"\n    },\n    {\n      \"name\": \"web_hook\",\n      \"type\": \"web_hook\",\n      \"args\": {\n        \"url\": \"http://localhost:1219/v1/webhook\"\n      },\n      \"goto\": \"waiting_trans_event\"\n    },\n    {\n      \"name\": \"waiting_trans_event\",\n      \"type\": \"waiting_trans_event\",\n      \"args\": {\n        \"timeout\": \"1 days\",\n        \"event\": {\n          \"event_name\": \"看板-进入模块\",\n          \"event_properties\": [\n            {\n              \"property_name\": \"看板数目\",\n              \"operator\": \">\",\n              \"params\": [\n                10\n              ]\n            }\n          ]\n        }\n      }\n    }\n  ]\n}\n```\n\n每一个WorkUnit都是一个极度专业的小应用，只做好一件事情，从而达到高度可复用。\n\n### 扩展性与高可用\n\n1. 敲定一个快速有效的分布式扩展方案\n2. 高可用：事件回放、状态备份、主从切换、自动故障恢复\n3. 关注各种分布式调度平台(K8s、Mesos)\n4. 关注各种Faas平台(Aws Lambda、阿里云Faas、OpenFaas(VMWare收购)、Fn(Oracle研发))的发展，未来的后端业务主要的开发方式即用工作流语言调度各种Faas小程序，从而人人都是后端？\n\n![image](http://7d9rmc.com1.z0.glb.clouddn.com/viewfile.jpg)\n\n### 工程\n\n1. 优化代码层次的集成\n2. 项目拆解\n3. 本地集成测试环境\n4. 持续集成、版本规范\n5. 自动化部署、灰度、更新(Saas/私有部署)\n6. 集成测试 接口自动化/UI自动化\n7. 周期性压测\n8. 故障演练\n9. 监控和异常追踪\n10. 平滑升级和兼容性规范\n', '2', '0', '2018-02-22 18:58:00'), ('160', '1', '257', '# 智能触达活动组件标准化草案\n\n## 触发器\n\n触发器定义了工作流实例的启动时机和方式。一个工作流定义可以拥有多个触发器以不同的方式启动。\n\n### 事件触发器\n\n事件触发器会监听ETL处理流，当用户的一系列行为满足要求时会启动工作流实例。\n\n#### 1. 简单事件触发器 [已实现]\n\n简单触发器监听ETL中某个特定的事件，一旦匹配就执行工作流。\n\n定义如下：\n\n```\n{\n      \"name\": \"zhuge_event_trigger\",\n      \"type\": \"zhuge_event_trigger\",\n      \"user_range\": [\n        {\n          \"property_name\": \"手机号\",\n          \"operator\": \"=\",\n          \"params\": [\n            \"17600817832\"\n          ]\n        }\n      ],\n      \"event\": {\n        \"event_name\": \"登录-登录成功\",\n        \"event_properties\": [\n          {\n            \"property_name\": \"邮箱\",\n            \"operator\": \"=\",\n            \"params\": [\n              \"chihongze@zhugeio.com\"\n            ]\n          }\n        ]\n    }\n}\n```\n\n* user\\_range: 必须，用户范围，全部用户用\"all\"表示，否则为多个属性的比较条件。\n* event: 匹配的事件\n\n#### 2. 漏斗事件触发器 [已实现]\n\n漏斗事件触发器可以追踪用户在一定时间内，是否按顺序完成了一系列的事件，如果符合条件，则启动活动实例。\n\n定义如下：\n\n```\n{\n      \"name\": \"zhuge_event_matcher_trigger\",\n      \"type\": \"zhuge_event_matcher_trigger\",\n      \"user_range\": \"all\",\n      \"matcher_type\": \"funnel\",\n      \"events\": [\n        {\n          \"event_name\": \"查看商品\",\n          \"times\": 1,\n          \"event_properties\": [\n            {\n              \"property_name\": \"类型\",\n              \"operator\": \"=\",\n              \"params\": [\n                \"门票\"\n              ]\n            }\n          ]\n        },\n        {\n          \"event_name\": \"下单\",\n          \"times\": 1,\n          \"event_properties\": []\n        }\n      ],\n      \"timeout\": \"1 days\"\n}\n```\n\n上面的定义即为，用户在一天之内完成了查看商品并下单后触发活动。\n\n* timeout: 漏斗触发条件必须规定一个超时时间，不会无限期的等待下去。\n* events: 漏斗事件定义，其中times可以定义事件触发次数。\n\n#### 3. 事件收集触发器 [支持但未实现]\n\n与漏斗一样，也是追踪一系列事件，但不同的是，集合事件触发器不关心事件发生的顺序，只要全部发生了就可以。\n\n定义如下：\n\n```\n{\n      \"name\": \"zhuge_event_matcher_trigger\",\n      \"type\": \"zhuge_event_matcher_trigger\",\n      \"user_range\": \"all\",\n      \"matcher_type\": \"events_collect\",\n      \"events\": [\n        [\n            {\n                \"event_name\": \"查看商品\",\n                \"times\": 1,\n                \"event_properties\": [\n                    {\n                        \"property_name\": \"类型\",\n                        \"operator\": \"=\",\n                        \"params\": [\n                            \"门票\"\n                        ]\n                    }\n                ]\n            },\n            {\n                \"event_name\": \"查看优惠\",\n                \"times\": 1,\n                \"event_properties\": []\n            }\n        ],\n        [\n            {\n                \"event_name\": \"收藏商品\",\n                \"times\": 1,\n                \"event_properties\": []\n            },\n            {\n                \"event_name\": \"查看优惠\",\n                \"times\": 1,\n                \"event_properties\": []\n            }\n        ]\n      ],\n      \"timeout\": \"1 days\"\n}\n```\n\n上面的定义即为，如果用户在1天之内，查看商品并查看优惠或收藏商品并查看优惠，则启动活动。\n\n\n### 手动触发器\n\n手动触发器由用户决定什么时候启动活动。\n\n#### 手动活动触发器 [已实现但不完善]\n\n定义如下：\n\n```\n{\n    \"name\": \"manual_activity_trigger\",\n    \"type\": \"manual_activity_trigger\",\n    \"time\": \"2017-06-10 20:00:01\",\n    \"target_user\": \"select ... from xxx where ...\",\n}\n```\n\n* time为预约的发送时间\n* target\\_user 目标用户，用SQL表示\n\n目前手动活动需求比较简单，后续会有更多的选项，比如周期性发送和事件条件筛选等等。\n\n## 动作单元\n\n动作单元用于执行普通的业务逻辑，比如发送消息、导出数据、执行某个外部应用程序或者发送日报等等。\n\n需要注意的是，动作单元往往并不会是真的由自身去完成工作，而是将工作以消息的方式请求外部系统后立即陷入waiting状态(实际上，为了防止活动还没有进入waiting状态外部工作就已经完成了，目前是先waiting再发消息...)，等收到外部系统完成工作后返回结果再决定下一步的执行。这样保证了整个工作流的执行不会陷入到系统阻塞当中。\n\n### 短信 [已实现]\n\n定义如下：\n\n```\n{\n    \"name\": \"send_sms\",\n    \"type\": \"send_sms\"\n    \"args\": {\n        \"channel\": \"ronglianyun\",\n        \"tpl_id\": \"170944\",\n        \"waiting\": \"1 minute\",\n        \"tpl_args\": [\n            {\n                \"property_name\": \"name\",\n                \"property_type\": \"official\"\n            },\n            {\n                \"property_name\": \"name\",\n                \"property_type\": \"official\"\n            },\n            {\n                \"property_name\": \"name\",\n                \"property_type\": \"official\"\n            },\n            \"你大爷！\"\n        ]\n    }\n}\n```\n\n* channel: 使用的渠道\n* tpl\\_id: 使用的发送模板，有些渠道不需要\n* waiting: 延迟发送时间，上面的是指1分钟以后\n* tpl\\_args: 短信参数，可以是字符串和用户属性混合，其中official是指官方内置属性。\n\n### Push [已实现但不完善]\n\n定义如下：\n\n```\n{\n    \"name\": \"send_push\",\n    \"type\": \"send_push\",\n    \"args\": {\n        \"title\": [\n          \"abc\",\n          {\n            \"property_name\": \"name\",\n            \"property_type\": \"official\"\n          }\n        ],\n        \"message\": [\n          \"def\",\n          {\n            \"property_name\": \"name\",\n            \"property_type\": \"official\"\n          }\n        ]\n    }\n}\n```\n\n* title: 推送标题，IOS无效，只作用于安卓\n* message: 推送内容\n\n因为推送渠道是跟用户设备实时绑定的，因此不在工作流里面定义目标渠道，目标渠道在ETL中动态缓存。\n\n目前推送渠道差的属性较多，比如铃声、大小ICON、调试模式等等。另外不同的渠道计费形式多样，需要优化发送方式。\n\n### Webhook [已实现但不完善]\n\n定义如下：\n\n```\n{\n      \"name\": \"web_hook\",\n      \"type\": \"web_hook\",\n      \"args\": {\n        \"url\": \"http://localhost:1219/v1/webhook\",\n        \"waiting\": \"1 seconds\"\n      }\n}\n```\n\n不完善之处主要在响应结果的处理，用户在响应结果中可以描述问题的原因，以便进行更细致的活动衡量。\n\n### 微信公众号 [支持但未实现]\n\n活动定义待设计\n\n### InAppMessage [支持但未实现]\n\n活动定义待设计\n\n## 模式匹配单元\n\n当工作流执行到模式匹配单元会暂停执行，直到遇见了目标事件或者超时。模式匹配单元是一个有限状态机，理论上，工作流即使只有一个触发器和模式匹配单元，也可以完成任何工作，我们目前手动活动就是这么做的。\n\n### 事件转化单元[已实现但不完善]\n\n事件转化单元等待目标用户事件的发生，触发类和转化类最后一步都是使用的该单元。\n\n定义如下：\n\n```\n{\n      \"name\": \"waiting_trans_event\",\n      \"type\": \"waiting_trans_event\",\n      \"args\": {\n        \"timeout\": \"1 days\",\n        \"event\": {\n          \"event_name\": \"看板-进入模块\",\n          \"event_properties\": [\n            {\n              \"property_name\": \"看板数目\",\n              \"operator\": \">\",\n              \"params\": [\n                10\n              ]\n            }\n          ]\n        }\n      }\n}\n```\n\n上面的定义即为，在一天之内如果用户进入了看板，则实现转化。\n\n需要完善的地方：\n\n1. 像事件触发器一样支持更多的匹配模式，比如漏斗和事件集合，这块已经抽象出了单独的事件匹配器，可以直接复用。\n2. 事件转化单元不允许控制工作流执行的走向，而是将匹配结果写入到上下文中，由流程控制单元去决定走向。\n\n### 手动活动单元[已实现]\n\n手动活动有两种实现方式，一种是跟自动活动一样，每个用户有一个工作流实例，其次是所有用户共享一个工作流实例。因为手动活动的规模和触发时间都是不可控的，为避免给自动活动造成压力，因此采用了第二种，所有的发送和转化都在一个单元中实现。\n\n```\n{\n      \"name\": \"manual_batch_send\",\n      \"type\": \"manual_batch_send\",\n      \"args\": {\n        \"send_type\": \"web_hook\",\n        \"url\": \"http://localhost:1219/v1/webhook\",\n        \"event\": {\n          \"event_name\": \"登录\",\n          \"event_properties\": [\n            {\n              \"property_name\": \"邮箱\",\n              \"operator\": \"=\",\n              \"params\": [\n                \"chihongze@gmail.com\"\n              ]\n            }\n          ]\n        },\n        \"trans_timeout\": \"10 days\"\n      }\n}\n```\n\n该单元会立即执行发送操作并同时等待转化事件的产生。\n\n为什么不是运行完发送单元后再进行转化单元？\n\n因为很多手动活动持续的时间比较漫长，发送还在进行的时候，很多发送过的用户可能已经开始转化了，因此这种场景更适合这样一个事件“Reactor”来处理。\n\n## 流程控制单元\n\n### 分支 [支持但未实现]\n\n分支单元可以根据上下文中的变量来决定工作流的走向。\n\n定义如下：\n\n```\n{\n    \"name\": \"is_transed\",\n    \"type\": \"switch\",\n    \"args\": {\n        \"context_var\": \"trans_result\",\n        \"cases\": [\n            {\n                \"value\": \"transed\",\n                \"goto\": \"xxx\",\n            },\n            {\n                \"value\": \"timeout\",\n                \"goto\": \"xxx\",\n            },\n            {\n                \"value\": \"__default__\",\n                \"goto\": {\n                    \"action\": \"failure\",\n                    \"reason\": \"unknown transed result\"\n                }\n            }\n        ]\n    }\n}\n```\n\n* context\\_var: 要判断的上下文变量\n* cases: 条件，value即为匹配的值，goto为满足value要执行的步骤，\"\\_\\_default\\_\\_\"是所有条件都不匹配的时候，标记工作流失败。\n\n\nswitch单元是最简单的分支形式，直接使用上下文变量而无须额外的计算，而真实业务中，我们往往需要结合业务逻辑进行更复杂的判断，这时候就需要单独为业务实现自己的switch了。\n\n### 循环 [支持但未实现]\n\n循环无须特定的单元支持，只要在分支单元goto到上一步即可，直到满足停止循环的条件。\n\n### 并行的子工作流\n\n子工作流目前设计上只保留了相关可能需要的数据结构(比如父流程ID和上下文继承)，但并未思考详细设计方案，目前没考虑到需求场景，因为基于事件的工作流不像传统的批处理式工作流，很多需要并行处理的业务可以通过并行处理不同的事件完成。\n\n## 活动定义监听器\n\n活动定义监听器可以在活动创建、暂停、恢复、删除时执行自定义的逻辑，保留了设计，但目前尚未用到。\n\n## 活动实例监听器\n\n活动实例监听器可以在工作流实例被创建、执行新的步骤、收到事件、失败和出错的时候回调，保留设计，目前尚未用到。\n\n## 绑定关联\n\n绑定关联是一个查找表，用于根据某些业务属性来快速查找对应的活动实例ID，比如通过zg\\_id和活动定义ID可以知道某个用户是否触发了该活动定义，目前处于什么状态。绑定关联的逻辑目前是耦合在触发器里的，下一步可能根据业务场景需要更好的设计。\n\n## 活动配置\n\n每个活动的创建都会有自己单独的配置项，比如执行时间范围，通常位于活动定义的config字段中。这些配置通常是作用于整个工作流的行为。目前需要的配置：\n\n1. 发送时间范围[已实现]\n2. 活动优先级 [未实现]\n3. 执行次数限制 [未实现]\n4. 单个用户是否允许重复触发，以及重复触发的方式。[未实现，可能需要更好的绑定关联逻辑]\n\n## 对外API\n\n### 创建活动 [已实现]\n\n传递JSON格式的工作流定义就可以创建新的活动。通过API而非web端创建的工作流是不会在web上展示出来的，我们后台有很多这种工作流在运行，比如日报、日志分析、监控。\n\n### 发送事件 [已实现]\n\n这里的事件是指工作流事件而非诸葛的用户事件，诸葛用户事件是工作流事件的一个子集。这个适应于不适合诸葛事件的场景，比如微信收到用户回复，想要通知工作流进行语义分析后采取不同的动作，就可以把微信回复包装成工作流事件传递给工作流。\n\n### 查看状态 [已实现但不完善]\n\n目前只是查看活动计数，可以做到获取每个用户在每个活动中的详细状态，看需要。\n', '2', '0', '2018-02-22 18:58:37'), ('161', '1', '258', '### sem定时任务部署文档\n\n1. 项目打包(与定时任务打包一致)\n> 注意点: `applicationContext-cron-normal`文件引用bean只引用 `<ref bean=\"sem*\"/>`\n> 具体打包步骤:\n```\ncd zhugesdkv\nmvn clean install\ncd zhugesdkv-crontab\nmvn clean compile assembly:single\n```\n\n2. 项目部署\n> 1. 新建docker, 新建方式与zhugesdkv定时任务一致\n>> 该docker需修改`/etc/hosts`文件, 可在新建docker时`--add-host realtime-1:ip1`, 也可每次启动手动添加, hosts文件追加内容:\n```\nip1	realtime-1\nip2	realtime-2\nip3	realtime-3\n```\n> 2. 拷贝项目jar包到docker挂载目录\n> 3. 启动docker\n\n3. 完成部署!', '2', '0', '2018-03-05 18:58:41'), ('162', '1', '259', '[TOC]\n\n文档创建于: 2018-03-15\n\n### 序\n- 渠道类型\n\n|渠道类型名称|渠道类型固定值|\n|:-:|:-:|\n|短信|send_sms|\n|推送|send_push|\n|webHook|send_webhook|\n|微信|send_weixin|\n\n- 渠道类型下所属渠道\n> - 短信\n>> 蝶信互联: `diexin`\n>> 容联云: `ronglianyun`\n>\n> - 推送\n>> 极光: `jpush`\n>> 友盟: `umeng`\n>> 信鸽: `xinge`\n\n- 配置模版字段详解\n\n|字段名|值类型|默认值|描述|\n|:-|:-|:-|:-|\n|name|字符串|\"\"|组合配置时, 以此值作为 key|\n|display_name|字符串|同 `name`|显示名|\n|required|布尔|true|是否必填|\n|strip|布尔|true|作`trim()`操作|\n|type|字符串|str|值类型. 枚举: `int` `long` `str` `bool`|\n|form_type|字符串|normal|表单类型. 枚举: `normal` `text` `radio`|\n|default_value|字符串|\"\"|默认值, 当值为空时自动填充(`required=false`也会填充)|\n|min_len|整数|0|最小长度|\n|max_len|整数|0|最大长度|\n|desc|字符串|\"\"|描述|\n|hidden|布尔|false|是否隐藏. 只作用于前端, 当值为`true`时表单不展示|\n|value_items|集合|[]|每个对象包含属性: 名称`name`, 值`value`|\n\n### 渠道类型(全局配置)\n\n#### 添加/更新 全局渠道配置\n- 请求地址: `v1/config/global/upsertConfig`\n- 登录请求: `是`\n- 请求类型: `POST`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用id||\n|channelType|是|字符串|渠道类型||\n|config|是|json字符串|配置|||\n\n- 结果\n> - 成功\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"updated_on\": \"Thu Mar 15 12:09:26 CST 2018\",\n			\"created_on\": \"Thu Mar 15 12:09:26 CST 2018\",\n			\"id\": 1,\n			\"channel_type\": \"send_sms\",\n			\"app_id\": 1000061,\n			\"config\": {\n				\"$enable\": 1,\n				\"phone_number_property\": 13552145052\n			}\n		}\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n> - 失败\n```JSON\n	{\n		\"code\": -10001,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n\n#### 启用/暂停 全局渠道配置\n- 请求地址: `v1/config/global/updateEnable`\n- 登录请求: `是`\n- 请求类型: `POST`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用id||\n|channelType|是|字符串|渠道类型||\n|enable|是|整数||启用: `1` 停用: `0`|\n\n> 更新成功会自动<启用/暂停>对应全局配置下的渠道\n\n- 结果\n> - 成功\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"updated_on\": \"Thu Mar 15 12:09:26 CST 2018\",\n			\"created_on\": \"Thu Mar 15 12:09:26 CST 2018\",\n			\"id\": 1,\n			\"channel_type\": \"send_sms\",\n			\"app_id\": 1000061,\n			\"config\": {\n				\"$enable\": 1,\n				\"phone_number_property\": 13552145052\n			}\n		}\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n\n#### 删除全局渠道配置\n- 请求地址: `v1/config/global/delete`\n- 登录请求: `是`\n- 请求类型: `POST`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用id||\n|channelType|是|字符串|渠道类型||\n\n- 结果\n> - 成功\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": null\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n\n#### 获取全局渠道配置模版\n- 请求地址: `v1/config/global/listOfTemplate`\n- 登录请求: `是`\n- 请求类型: `GET`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|channelType|是|字符串|渠道类型|||\n\n- 结果\n> - 成功\n```JSON\n	{\n	  \"code\": 10001,\n	  \"msg\": \"Request success\",\n	  \"data\": [\n		{\n		  // 配置模板具体字段, 详见 序\n		}\n	  ]\n	}\n```\n\n#### 获取全局渠道配置\n- 请求地址: `v1/config/global/list`\n- 登录请求: `是`\n- 请求类型: `GET`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用ID||\n|channelType|否|字符串|渠道类型|未传则获取对应应用下所有全局配置|\n\n- 结果\n> - 成功 - appId 有值, channelType=null\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"send_sms\": {\n				\"phone_number_property\": 12345678910\n			}\n		}\n	}\n```\n> - 成功 - 参数全传\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"phone_number_property\": 12345678910\n		}\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n\n### 渠道\n\n#### 添加/更新 渠道配置\n- 请求地址: `v1/config/channel/upsertConfig`\n- 登录请求: `是`\n- 请求类型: `POST`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用id||\n|channelType|是|字符串|渠道类型||\n|channel|是|字符串|渠道||\n|config|是|json字符串|配置|||\n\n- 结果\n> - 成功\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"enable\": 1,\n			\"channel\": \"diexin\",\n			\"id\": 1,\n			\"channel_type\": \"send_sms\",\n			\"app_id\": 1000061,\n			\"config\": {\n				\"password\": \"xxx\",\n				\"prefix\": \"xx\",\n				\"url\": \"url\",\n				\"username\": \"xxx\"\n			}\n		}\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n> - 失败\n```JSON\n	{\n		\"code\": -10001,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n\n#### 启用/暂停 渠道配置\n- 请求地址: `v1/config/channel/updateEnable`\n- 登录请求: `是`\n- 请求类型: `POST`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用id||\n|channelType|是|字符串|渠道类型||\n|channel|是|字符串|渠道||\n|enable|是|整数||启用: `1` 停用: `0`|\n\n- 结果\n> - 成功\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"enable\": 1,\n			\"channel\": \"diexin\",\n			\"id\": 2,\n			\"channel_type\": \"send_sms\",\n			\"app_id\": 1000061,\n			\"config\": {\n				\"password\": \"xxx\",\n				\"$enable\": 1,\n				\"prefix\": \"xx\",\n				\"url\": \"url\",\n				\"username\": \"xxx\"\n			}\n		}\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n\n#### 删除渠道配置\n- 请求地址: `v1/config/channel/delete`\n- 登录请求: `是`\n- 请求类型: `POST`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用id||\n|channelType|是|字符串|渠道类型||\n|channel|是|字符串|渠道|||\n\n- 结果\n> - 成功\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": null\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n\n#### 获取渠道配置模版\n- 请求地址: `v1/config/global/listOfTemplate`\n- 登录请求: `是`\n- 请求类型: `GET`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|channelType|是|字符串|渠道类型||\n|channel|否|字符串|渠道|不传返回该渠道类型下所有渠道(json对象), 传值则为属性集合|\n\n- 结果\n> - 成功 - channelType 有值, channel=null - 返回该类型下所有渠道\n```JSON\n	{\n	  \"code\": 10001,\n	  \"msg\": \"Request success\",\n	  \"data\": {\n		\"diexin\": [\n		  {\n			// 配置模板具体字段, 详见 序\n		  }\n		],\n		\"ronglianyun\": [\n		  {\n			// 配置模板具体字段, 详见 序\n		  }\n		]\n	  }\n	}\n```\n> - 成功 - 参数全传 - 该渠道下属性集合\n```JSON\n	{\n	  \"code\": 10001,\n	  \"msg\": \"Request success\",\n	  \"data\": [\n		{\n		  // 配置模板具体字段, 详见 序\n		}\n	  ]\n	}\n```\n\n#### 获取渠道配置\n- 请求地址: `v1/config/channel/list`\n- 登录请求: `是`\n- 请求类型: `GET`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用ID||\n|channelType|否|字符串|渠道类型|当channelType=null时,channel=null. 未传获取应用下所有渠道配置|\n|channel|否|字符串|指定渠道|当channelType=null时, channel传任何值都会被忽略, 未传获取对应channelType下所有渠道|\n\n- 结果\n> 注意: `带 $ 的为内部参数`\n> - 成功 - appId有值, channelType=null, channel=null\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"send_sms\": {\n				\"diexin\": {\n					\"password\": \"xxx\",\n					\"$enable\": 1,\n					\"prefix\": \"xx\",\n					\"url\": \"url\",\n					\"username\": \"xxx\"\n				}\n			}\n		}\n	}\n```\n> - 成功 - appId 与 channelType有值, channel=null\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"diexin\": {\n				\"password\": \"xxx\",\n				\"$enable\": 1,\n				\"prefix\": \"xx\",\n				\"url\": \"url\",\n				\"username\": \"xxx\"\n			}\n		}\n	}\n```\n> - 成功 - 全部参数有值 - 获取指定渠道的配置\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"password\": \"xxx\",\n			\"$enable\": 1,\n			\"prefix\": \"xx\",\n			\"url\": \"url\",\n			\"username\": \"xxx\"\n		}\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n\n#### 获取 渠道/渠道类型下 所有信息\n- 请求地址: `v1/config/channel/listOfAll`\n- 登录请求: `是`\n- 请求类型: `GET`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用ID||\n|channelType|是|字符串|渠道类型||\n|channel|否|字符串|指定渠道|未传获取对应channelType下所有渠道|\n\n- 结果\n> 注意: `带 $ 的为内部参数`\n> - 成功 - appId, channelType 有值; channel=null\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"globalTemplate\": [\n				{\n					// 配置模板具体字段, 详见 序\n				}\n			],\n			\"globalConfig\": {\n				\"phone_number_property\": 12345678910\n			},\n			\"channelTemplate\": {\n				\"diexin\": {\n					\"configMeta\": {\n						\"displayName\": \"蝶信互联\"\n					},\n					\"configFields\": [\n						{\n							// 配置模板具体字段, 详见 序\n						}\n					]\n				},\n				\"ronglianyun\": {\n					\"configMeta\": {\n						\"displayName\": \"容联云\"\n					},\n					\"configFields\": [\n						{\n							// 配置模板具体字段, 详见 序\n						}\n					]\n				}\n			},\n			\"channelConfig\": {\n				\"diexin\": {\n					\"password\": \"xxx\",\n					\"$enable\": 0,\n					\"prefix\": \"xx\",\n					\"url\": \"url\",\n					\"username\": \"xxx\"\n				}\n			}\n		},\n		\"success\": true\n	}\n```\n- 成功 - 参数全传\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"globalTemplate\": [\n				{\n					// 配置模板具体字段, 详见 序\n				}\n			],\n			\"globalConfig\": {\n				\"phone_number_property\": 12345678910\n			},\n			\"channelTemplate\": {\n				\"configMeta\": {\n					\"displayName\": \"蝶信互联\"\n				},\n				\"configFields\": [\n					{\n						// 配置模板具体字段, 详见 序\n					}\n				]\n			},\n			\"channelConfig\": {\n				\"password\": \"xxx\",\n				\"$enable\": 0,\n				\"prefix\": \"xx\",\n				\"url\": \"url\",\n				\"username\": \"xxx\"\n			}\n		},\n		\"success\": true\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```\n\n#### 获取已配置的渠道列表(渠道名)\n- 请求地址: `v1/config/channel/listOfDisplayName`\n- 登录请求: `是`\n- 请求类型: `GET`\n- 参数:\n\n|参数名|是否必填|类型|描述|备注|\n|-\n|appId|是|整数|应用ID||\n|channelType|否|字符串|渠道类型|||\n\n- 结果\n> - 成功 - 未传channelType参数\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": [\n			{\n				\"displanName\": \"蝶信互联\",\n				\"channel\": \"diexin\",\n				\"id\": 3\n			}\n		],\n		\"success\": true\n	}\n```\n> - 成功 - 参数全传\n```JSON\n	{\n		\"code\": 10001,\n		\"msg\": \"Request success\",\n		\"data\": {\n			\"send_sms\": [\n				{\n					\"displanName\": \"蝶信互联\",\n					\"channel\": \"diexin\",\n					\"id\": 3\n				}\n			]\n		},\n		\"success\": true\n	}\n```\n> - 失败 - 参数异常\n```JSON\n	{\n		\"code\": -10008,\n		\"msg\": \"xxx\",\n		\"data\": null\n	}\n```', '2', '0', '2018-03-15 10:40:06'), ('164', '1', '260', '[TOC]\n\n#### 接口标准\n> - 返回格式\n```\n{\n	code: 200,	<!-- 接口以code为标准, msg仅为提示信息, 如错误排查 -->\n	msg: \"响应信息\",\n	data: {\n		list: []\n		obj: {}\n	}\n}\n```\n\n> - `参数 / 返回数据`遵循`小驼峰`, 如: `userId`\n\n> - url前缀带版本, 如: `v1/模块(user/app/activity)`\n\n> - 接口method: `查询 get; 其它  post`\n\n> - 双方传参皆为 `json` 格式\n\n#### 返回code一览表\n##### 公共code\n|code|msg|\n|:-\n|101|未登录|\n|102|失败|\n|200|成功|\n|400|参数或请求异常|\n|403|权限不足|\n|404|资源未找到|\n|500|参数异常|\n\n##### 业务code\n|code|msg|\n|:-\n|1001|不支持的文件类型|', null, '0', '2018-04-02 12:25:35');
COMMIT;

-- ----------------------------
--  Table structure for `picture`
-- ----------------------------
DROP TABLE IF EXISTS `picture`;
CREATE TABLE `picture` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `uuid` varchar(64) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户id',
  `name` varchar(127) DEFAULT NULL COMMENT '图片上传名称',
  `path` varchar(127) DEFAULT NULL COMMENT '图片相对路径',
  `width` int(6) DEFAULT NULL COMMENT '图片宽',
  `height` int(6) DEFAULT NULL COMMENT '图片高',
  `size` bigint(20) DEFAULT NULL COMMENT '图片大小',
  `type` varchar(16) DEFAULT NULL COMMENT '图片类型. 如: jpg gif png jpeg',
  `use_type` int(2) DEFAULT NULL COMMENT '图片用处. 1笔记 2头像',
  `create_datetime` datetime DEFAULT NULL COMMENT '创建时间',
  `is_del` int(2) DEFAULT '0' COMMENT '是否删除. 0否 1是. 默认0',
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `picture`
-- ----------------------------
BEGIN;
INSERT INTO `picture` VALUES ('1', 'a82ecdac460d43e7be64c8b0965aa6a8', '1', 'scala Intellij插件安装', '2017/6/23/a82ecdac460d43e7be64c8b0965aa6a8.png', '1590', '342', '70516', 'png', '1', '2017-06-23 14:40:57', '0'), ('2', '6de12130005a4b4ca6face5d0decfa60', '1', '屏幕快照 2017-06-23 15.07.18', '2017/6/23/6de12130005a4b4ca6face5d0decfa60.png', '957', '250', '107068', 'png', '1', '2017-06-23 15:08:14', '0'), ('3', '4679500999b342b494f643dc264753e9', '1', '屏幕快照 2017-06-23 15.07.18', '2017/6/23/4679500999b342b494f643dc264753e9.png', '957', '250', '107068', 'png', '1', '2017-06-23 15:08:14', '0'), ('4', 'aa11756f07114b05a671afade7bc02a8', '1', '11', '2017/6/23/aa11756f07114b05a671afade7bc02a8.png', '1824', '774', '317637', 'png', '1', '2017-06-23 15:15:45', '0'), ('5', '44e64f764f7d48f3bb1072291b2e757d', '1', '11', '2017/6/23/44e64f764f7d48f3bb1072291b2e757d.png', '1824', '774', '317637', 'png', '1', '2017-06-23 15:15:45', '0'), ('6', '3ec0b0e15bed47928eb5951de3e821a7', '1', '11', '2017/6/23/3ec0b0e15bed47928eb5951de3e821a7.png', '1824', '774', '317637', 'png', '1', '2017-06-23 15:15:45', '0'), ('7', '410c42e0151c46a38329ef3facba62d5', '1', '11', '2017/6/23/410c42e0151c46a38329ef3facba62d5.png', '1824', '774', '317637', 'png', '1', '2017-06-23 15:15:45', '0'), ('8', '99b13787cd9744a8aa7105215af3b76b', '1', '屏幕快照 2017-06-23 16.06.50', '2017/6/23/99b13787cd9744a8aa7105215af3b76b.png', '206', '527', '33149', 'png', '1', '2017-06-23 16:07:22', '0'), ('9', '5965d40a3e314572a82665397f88f04a', '1', '11', '2017/6/23/5965d40a3e314572a82665397f88f04a.png', '800', '339', '90586', 'png', '1', '2017-06-23 16:09:12', '0'), ('10', '7afe2e3872f74d62ba1ae072e47865cf', '1', '粘贴图片(3)', '2017/6/23/7afe2e3872f74d62ba1ae072e47865cf.png', '800', '334', '53055', 'png', '1', '2017-06-23 16:44:09', '0'), ('11', '28956a0ecea24cc481f094c1c3b3c58b', '1005', '1358056331_2790', '2017/6/23/28956a0ecea24cc481f094c1c3b3c58b.png', '800', '379', '106516', 'png', '1', '2017-06-23 19:00:54', '0'), ('12', '1bffd25252144ef687a44a4e46d9bcf1', '1', 'DAG', '2017/6/27/1bffd25252144ef687a44a4e46d9bcf1.png', '800', '558', '268584', 'png', '1', '2017-06-27 12:32:14', '0'), ('13', 'ba720fea195d4c67a07fcbf48009a83e', '1', 'flume1', '2017/6/27/ba720fea195d4c67a07fcbf48009a83e.png', '456', '191', '11849', 'png', '1', '2017-06-27 16:55:30', '0'), ('14', '40a1142b36ed4c83b2723dedb3074b92', '1', 'flume2', '2017/6/27/40a1142b36ed4c83b2723dedb3074b92.png', '800', '509', '135220', 'png', '1', '2017-06-27 17:31:16', '0'), ('15', '440a2ced096242718fa56584dcfac0b0', '1', 'flume2', '2017/6/27/440a2ced096242718fa56584dcfac0b0.png', '800', '513', '138219', 'png', '1', '2017-06-27 18:48:28', '0'), ('16', 'ed4c3e976c9c48aa9609d2af59e5af61', '1', 'flume3', '2017/6/28/ed4c3e976c9c48aa9609d2af59e5af61.png', '620', '419', '37785', 'png', '1', '2017-06-28 14:05:49', '0'), ('17', '2af6c64e28674070b9b591865da1ec88', '1', '屏幕快照 2017-06-28 15.08.05', '2017/6/28/2af6c64e28674070b9b591865da1ec88.png', '357', '139', '17148', 'png', '1', '2017-06-28 15:09:07', '0'), ('18', '63f19e54cdec40c6b51f13081038f637', '1', '屏幕快照 2017-06-28 15.08.46', '2017/6/28/63f19e54cdec40c6b51f13081038f637.png', '703', '66', '19960', 'png', '1', '2017-06-28 15:09:07', '0'), ('19', '2526b188ccb547628c74dcbb008e61f4', '1', '屏幕快照 2017-06-28 15.08.05', '2017/6/28/2526b188ccb547628c74dcbb008e61f4.png', '357', '139', '17316', 'png', '1', '2017-06-28 15:15:41', '0'), ('20', '580c7d5268de4023b2ada0679e3641e6', '1', '屏幕快照 2017-06-28 15.08.46', '2017/6/28/580c7d5268de4023b2ada0679e3641e6.png', '703', '66', '20307', 'png', '1', '2017-06-28 15:15:41', '0'), ('21', 'fc788c0f60d6440abaab58b90a99e76c', '1', 'kafka', '2017/6/29/fc788c0f60d6440abaab58b90a99e76c.jpg', '800', '376', '59669', 'jpg', '1', '2017-06-29 14:45:32', '0'), ('22', 'e85fc812bc354fb0baea3e90e8f12069', '1', '屏幕快照 2017-06-29 15.28.08', '2017/6/29/e85fc812bc354fb0baea3e90e8f12069.png', '800', '170', '172063', 'png', '1', '2017-06-29 15:29:08', '0'), ('23', 'a752613572b847b79313c41eb3b27d50', '1', 'zfq', '2017/7/1/a752613572b847b79313c41eb3b27d50.png', '800', '2760', '756348', 'png', '1', '2017-07-01 10:43:14', '0'), ('24', 'bec7da2632af49c49a88f2d8df510692', '1', '屏幕快照 2017-07-07 11.53.17', '2017/7/7/bec7da2632af49c49a88f2d8df510692.png', '800', '594', '70080', 'png', '1', '2017-07-07 11:54:29', '0'), ('25', 'c4884321d3e143aabfe8655f47d73a2d', '1', '屏幕快照 2017-07-07 17.41.34', '2017/7/7/c4884321d3e143aabfe8655f47d73a2d.png', '800', '378', '78998', 'png', '1', '2017-07-07 17:41:58', '0'), ('26', 'd650316f9a504f2f8d7c304dd2a9a322', '1', '屏幕快照 2017-07-10 10.52.16', '2017/7/10/d650316f9a504f2f8d7c304dd2a9a322.png', '800', '448', '128984', 'png', '1', '2017-07-10 10:56:31', '0'), ('27', '04f2ace3461c42d8b680d96f602466a2', '1', '屏幕快照 2017-07-10 10.52.33', '2017/7/10/04f2ace3461c42d8b680d96f602466a2.png', '800', '452', '137290', 'png', '1', '2017-07-10 10:56:31', '0'), ('28', '81835ac9c2084b318db5eaa13b417f89', '1', '屏幕快照 2017-07-10 10.52.45', '2017/7/10/81835ac9c2084b318db5eaa13b417f89.png', '800', '480', '233828', 'png', '1', '2017-07-10 10:56:31', '0'), ('29', 'aaf769bbd52a40798d837def515559ed', '1', '屏幕快照 2017-07-10 10.53.08', '2017/7/10/aaf769bbd52a40798d837def515559ed.png', '800', '447', '191848', 'png', '1', '2017-07-10 10:56:32', '0'), ('30', '43d40c95c52042c2ab5561e14292a558', '1', '屏幕快照 2017-07-10 10.53.21', '2017/7/10/43d40c95c52042c2ab5561e14292a558.png', '800', '469', '111096', 'png', '1', '2017-07-10 10:56:32', '0'), ('31', '7e91c52d78e7473d9af4420cf6b7144b', '1', 'hadoop1.x与2.x', '2017/7/10/7e91c52d78e7473d9af4420cf6b7144b.png', '800', '415', '151722', 'png', '1', '2017-07-10 10:57:17', '0'), ('32', 'eae07df8d9774416b108640fd3811c48', '1', 'hadoop2.x与1.x解决的问题', '2017/7/10/eae07df8d9774416b108640fd3811c48.png', '800', '514', '272456', 'png', '1', '2017-07-10 10:57:17', '0'), ('33', 'ce925277659c4a8eb62b285977a101c4', '1', 'HDFS2.x HA', '2017/7/10/ce925277659c4a8eb62b285977a101c4.png', '800', '501', '197287', 'png', '1', '2017-07-10 10:57:18', '0'), ('34', '2c24f15f53c54ca7b7cde679a7043aad', '1000', '私信－粉丝', '2017/7/12/2c24f15f53c54ca7b7cde679a7043aad.jpg', '800', '1422', '142754', 'jpg', '1', '2017-07-12 14:34:13', '0'), ('35', '870374f5dac54a889246144f823288ab', '1', '屏幕快照 2017-08-23 16.52.29', '2017/8/23/870374f5dac54a889246144f823288ab.png', '800', '340', '192570', 'png', '1', '2017-08-23 16:55:00', '0'), ('36', 'b97b0432e88949d9abf37744eb0bed5b', '1', '屏幕快照 2017-08-23 16.52.42', '2017/8/23/b97b0432e88949d9abf37744eb0bed5b.png', '800', '503', '283612', 'png', '1', '2017-08-23 16:55:00', '0'), ('37', '6e44742d48fb40e983842b0f2661b180', '1', '屏幕快照 2017-08-23 16.52.53', '2017/8/23/6e44742d48fb40e983842b0f2661b180.png', '800', '834', '489575', 'png', '1', '2017-08-23 16:55:01', '0'), ('38', 'bd9e84d5b9294758a2d3390e914dde8a', '1', '屏幕快照 2017-08-23 16.53.15', '2017/8/23/bd9e84d5b9294758a2d3390e914dde8a.png', '800', '534', '313753', 'png', '1', '2017-08-23 16:55:01', '0'), ('39', '1bcb6487cd5545c4aa40b7d9293c1f7a', '1', '屏幕快照 2017-08-23 16.53.47', '2017/8/23/1bcb6487cd5545c4aa40b7d9293c1f7a.png', '631', '1114', '606489', 'png', '1', '2017-08-23 16:55:01', '0'), ('40', '3cc7ee35ab284523a2f125dd15cccd91', '1', '2983894637-55935a984b537_articlex', '2017/8/25/3cc7ee35ab284523a2f125dd15cccd91.png', '622', '482', '73998', 'png', '1', '2017-08-25 11:19:50', '0'), ('41', 'dfcbfda8e9ec48539284508905571744', '1', '3486491155-54f7c0a9eddd5_articlex', '2017/8/25/dfcbfda8e9ec48539284508905571744.png', '632', '408', '98159', 'png', '1', '2017-08-25 11:19:50', '0'), ('42', '5c4dac6b5f914422a819541018d20acc', '1', '3631975667-54f7c08e5bf91_articlex', '2017/8/25/5c4dac6b5f914422a819541018d20acc.png', '624', '404', '184134', 'png', '1', '2017-08-25 11:19:50', '0'), ('43', 'e6cf46f0851b424b9a68fc40f0338c1a', '1', '3636456045-54fcfb7ab3139_articlex', '2017/8/25/e6cf46f0851b424b9a68fc40f0338c1a.png', '545', '465', '48506', 'png', '1', '2017-08-25 11:19:50', '0'), ('44', '5aa7d9578f644bc9ae8d08b8d448b1b0', '1', '屏幕快照 2017-09-05 13.53.05', '2017/9/5/5aa7d9578f644bc9ae8d08b8d448b1b0.png', '800', '414', '356133', 'png', '1', '2017-09-05 13:54:01', '0'), ('45', '29d41e4235514abf811bbcf81cb17801', '1', '屏幕快照 2017-09-25 11.35.25', '2017/9/25/29d41e4235514abf811bbcf81cb17801.png', '800', '230', '83953', 'png', '1', '2017-09-25 11:44:22', '0'), ('46', 'd5a63678a56c4c7e96efb81b59f7321d', '1', '屏幕快照 2017-09-25 11.35.43', '2017/9/25/d5a63678a56c4c7e96efb81b59f7321d.png', '800', '386', '48993', 'png', '1', '2017-09-25 11:44:22', '0'), ('47', 'ebb7d0f02aeb4976a596c0ce334fdc19', '1', '屏幕快照 2017-09-25 11.36.01', '2017/9/25/ebb7d0f02aeb4976a596c0ce334fdc19.png', '800', '347', '102291', 'png', '1', '2017-09-25 11:44:22', '0'), ('48', '8ef1cff5e9704f5a847f527193fa16ec', '1', '屏幕快照 2017-09-25 11.36.15', '2017/9/25/8ef1cff5e9704f5a847f527193fa16ec.png', '800', '437', '76547', 'png', '1', '2017-09-25 11:44:23', '0'), ('49', 'f7f653e0eae24188a29cac49ac7ef95a', '1', '屏幕快照 2017-09-25 11.36.29', '2017/9/25/f7f653e0eae24188a29cac49ac7ef95a.png', '800', '412', '54779', 'png', '1', '2017-09-25 11:44:23', '0'), ('50', '2e48cec929fb4f11a04a3886f770dad9', '1', '屏幕快照 2017-09-25 11.36.40', '2017/9/25/2e48cec929fb4f11a04a3886f770dad9.png', '800', '239', '100563', 'png', '1', '2017-09-25 11:44:23', '0'), ('51', 'dd3dc1a5fbc343a79d6b58fd1807ed23', '1', '屏幕快照 2017-09-25 11.52.21', '2017/9/25/dd3dc1a5fbc343a79d6b58fd1807ed23.png', '800', '229', '105196', 'png', '1', '2017-09-25 11:53:18', '0'), ('52', '4cb963a4d3064925a8b91d7ead220544', '1', '屏幕快照 2017-09-25 11.52.44', '2017/9/25/4cb963a4d3064925a8b91d7ead220544.png', '800', '385', '57493', 'png', '1', '2017-09-25 11:53:18', '0'), ('53', 'be4d50759ee04ddea7ea0d1f26e76121', '1', '屏幕快照 2017-09-25 11.52.58', '2017/9/25/be4d50759ee04ddea7ea0d1f26e76121.png', '800', '349', '127435', 'png', '1', '2017-09-25 11:53:19', '0'), ('54', '7ce5848786e946d4a0ac389f0c438b86', '1', '屏幕快照 2017-09-25 11.53.09', '2017/9/25/7ce5848786e946d4a0ac389f0c438b86.png', '800', '440', '92798', 'png', '1', '2017-09-25 11:53:19', '0'), ('55', 'ef695605204645a9b43ca56beab725b5', '1', '屏幕快照 2017-09-25 11.53.20', '2017/9/25/ef695605204645a9b43ca56beab725b5.png', '800', '419', '65574', 'png', '1', '2017-09-25 11:53:19', '0'), ('56', 'ee7e29db51e046f998a1741b1404ea83', '1', '屏幕快照 2017-09-25 11.53.33', '2017/9/25/ee7e29db51e046f998a1741b1404ea83.png', '800', '240', '124610', 'png', '1', '2017-09-25 11:53:19', '0'), ('57', '12da68834da9438c94bb7bdb33ce95b3', '1', 'image04', '2017/9/25/12da68834da9438c94bb7bdb33ce95b3.png', '800', '385', '53448', 'png', '1', '2017-09-25 12:03:04', '0'), ('58', 'a92f384a1c4c4bbab013717ad6243ae3', '1', 'image05', '2017/9/25/a92f384a1c4c4bbab013717ad6243ae3.png', '800', '415', '63665', 'png', '1', '2017-09-25 12:03:04', '0'), ('59', '8a008a9a28014c00b4cb17b3df297daa', '1', 'image06', '2017/9/25/8a008a9a28014c00b4cb17b3df297daa.png', '800', '440', '91531', 'png', '1', '2017-09-25 12:03:04', '0'), ('60', 'b22c5bae17e6447b8d474ee1143feb55', '1', '2', '2017/11/3/b22c5bae17e6447b8d474ee1143feb55.png', '800', '471', '146621', 'png', '1', '2017-11-03 15:55:29', '0'), ('61', '4f6e32d397eb4704ae3701a493fc0625', '1', '屏幕快照 2017-11-03 15.44.53', '2017/11/3/4f6e32d397eb4704ae3701a493fc0625.png', '800', '553', '284897', 'png', '1', '2017-11-03 15:55:30', '0'), ('62', '7b826e7901a944a4b437e1672f36fae2', '1', '屏幕快照 2017-11-03 15.48.17', '2017/11/3/7b826e7901a944a4b437e1672f36fae2.png', '800', '581', '257016', 'png', '1', '2017-11-03 15:55:30', '0'), ('63', 'e355e8beadb3405a8d6310ceebb0bacc', '1', '屏幕快照 2017-11-03 18.50.51', '2017/11/3/e355e8beadb3405a8d6310ceebb0bacc.png', '800', '493', '138211', 'png', '1', '2017-11-03 18:51:49', '0'), ('64', 'b84431010773490ead5d3c99c8010697', '1', '屏幕快照 2017-11-30 17.13.44', '2017/11/30/b84431010773490ead5d3c99c8010697.png', '800', '353', '55116', 'png', '1', '2017-11-30 17:14:09', '0');
COMMIT;

-- ----------------------------
--  Table structure for `user`
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar_id` bigint(20) DEFAULT NULL COMMENT '头像关联图片id',
  `name` varchar(64) DEFAULT NULL COMMENT '登录名, 唯一, 可空',
  `alias` varchar(64) DEFAULT NULL COMMENT '别名',
  `password` varchar(127) DEFAULT NULL COMMENT '密码',
  `gender` int(2) DEFAULT '0' COMMENT '性别. 0保密, 1男, 2女. 默认0',
  `status` int(2) DEFAULT '1' COMMENT '状态. 0禁用, 1启用. 默认1',
  `motto` varchar(200) DEFAULT NULL COMMENT '格言',
  `phone` varchar(20) DEFAULT NULL COMMENT '手机号',
  `email` varchar(64) DEFAULT NULL COMMENT '邮箱',
  `qq` varchar(32) DEFAULT NULL COMMENT 'QQ',
  `weixin` varchar(64) DEFAULT NULL COMMENT '微信',
  `weibo` varchar(64) DEFAULT NULL COMMENT '微博',
  `register_origin` int(2) DEFAULT NULL COMMENT '注册来源: 1无, 2手机号, 3微信, 4QQ, 5微博',
  `register_ip` varchar(32) DEFAULT NULL COMMENT '注册IP',
  `description` varchar(200) DEFAULT NULL COMMENT '描述',
  `create_datetime` datetime DEFAULT NULL COMMENT '创建时间',
  `is_del` int(2) DEFAULT '0' COMMENT '是否删除. 0否, 1是. 默认0',
  PRIMARY KEY (`id`),
  KEY `索引` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=1025 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `user`
-- ----------------------------
BEGIN;
INSERT INTO `user` VALUES ('1', null, 'vanki', 'vanki', 'wr9zw7rCkcOGJA==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-05-19 17:06:07', '0'), ('110', null, 'user110', 'yu', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-06-03 16:48:16', '0'), ('520', null, 'user520', 'buer', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '101.204.16.227', null, '2017-05-20 22:10:38', '0'), ('1000', null, 'user1000', 'hello', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-05-24 09:24:45', '0'), ('1004', null, 'user1004', '雪芳', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-05-24 09:37:42', '0'), ('1005', null, 'user1005', '菜鸟之路', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-05-24 10:14:43', '0'), ('1006', null, 'user1006', 'YU', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-05-24 16:12:54', '0'), ('1018', null, 'user1018', 'xinxin', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-05-23 19:20:30', '0'), ('1020', null, 'user1020', '阿新', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '183.3.218.5', null, '2017-06-06 10:54:39', '0'), ('1021', null, 'user1021', 'huwei', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-06-09 09:48:24', '0'), ('1022', null, 'user1022', 'ssl', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-06-16 14:53:22', '0'), ('1023', null, 'user1023', 'huwei', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '124.126.123.214', null, '2017-09-04 17:44:01', '0'), ('1024', null, 'user1024', 'ztt', 'w7ggwqfDjsKaMg==', '0', '1', null, null, null, null, null, null, null, '36.5.132.197', null, '2017-11-28 14:16:46', '0');
COMMIT;

-- ----------------------------
--  Table structure for `user_login_record`
-- ----------------------------
DROP TABLE IF EXISTS `user_login_record`;
CREATE TABLE `user_login_record` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(2) DEFAULT NULL COMMENT '用户id',
  `origin` int(2) DEFAULT '1' COMMENT '登录来源: 0自动登录, 1无, 2手机号, 3微信, 4QQ, 5微博',
  `ip` varchar(32) DEFAULT NULL,
  `protocol` varchar(127) DEFAULT NULL,
  `scheme` varchar(127) DEFAULT NULL,
  `server_name` varchar(127) DEFAULT NULL,
  `remote_addr` varchar(32) DEFAULT NULL,
  `remote_host` varchar(32) DEFAULT NULL,
  `character_encoding` varchar(32) DEFAULT NULL,
  `accept` varchar(255) DEFAULT NULL,
  `accept_encoding` varchar(64) DEFAULT NULL,
  `accept_language` varchar(255) DEFAULT NULL,
  `user_agent` varchar(500) DEFAULT NULL,
  `connection` varchar(32) DEFAULT NULL,
  `create_datetime` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=107 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `user_login_record`
-- ----------------------------
BEGIN;
INSERT INTO `user_login_record` VALUES ('1', '1000', '1', '124.126.123.214', 'HTTP/1.1', 'http', '47.93.255.190', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-05-19 17:06:07'), ('2', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.zoufanqi.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-19 18:38:46'), ('3', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-19 18:50:47'), ('4', '1', '1', '114.253.97.187', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-19 21:16:22'), ('5', '1', '1', '114.253.97.187', 'HTTP/1.1', 'http', 'www.zoufanqi.com', '114.253.97.187', '114.253.97.187', 'UTF-8', '*/*', 'gzip, deflate', 'zh-cn', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.1 Safari/603.1.30', 'keep-alive', '2017-05-19 21:17:19'), ('6', '1', '1', '114.253.97.187', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-19 22:28:58'), ('7', '1', '1', '114.253.97.187', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-20 19:36:23'), ('8', '1001', '1', '101.204.16.227', 'HTTP/1.1', 'http', 'www.zoufanqi.com', '101.204.16.227', '101.204.16.227', 'UTF-8', '*/*', 'gzip,deflate', 'zh-CN,en-US;q=0.8', 'Mozilla/5.0 (Linux; Android 6.0; vivo Y67L Build/MRA58K) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/38.0.0.0 Mobile Safari/537.36 VivoBrowser/5.1.4', 'keep-alive', '2017-05-20 22:16:42'), ('9', '520', '1', '101.204.16.227', 'HTTP/1.1', 'http', 'www.zoufanqi.com', '101.204.16.227', '101.204.16.227', 'UTF-8', '*/*', 'gzip,deflate', 'zh-CN,en-US;q=0.8', 'Mozilla/5.0 (Linux; Android 6.0; vivo Y67L Build/MRA58K) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/38.0.0.0 Mobile Safari/537.36 VivoBrowser/5.1.4', 'keep-alive', '2017-05-20 22:19:52'), ('10', '1', '1', '114.253.97.187', 'HTTP/1.1', 'http', 'www.zoufanqi.com', '114.253.97.187', '114.253.97.187', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-05-20 22:35:26'), ('11', '1', '1', '114.253.97.187', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-21 15:09:56'), ('12', '1', '1', '114.253.97.187', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:48.0) Gecko/20100101 Firefox/48.0', 'close', '2017-05-21 17:14:25'), ('13', '1', '1', '114.253.97.187', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-21 20:39:32'), ('14', '1', '1', '123.113.67.33', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-21 21:22:30'), ('15', '1002', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', null, '2017-05-23 19:20:30'), ('16', '1003', '1', '124.126.123.214', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-24 09:24:45'), ('17', '1000', '1', '124.126.123.214', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-24 09:25:51'), ('18', '1000', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.2669.400 QQBrowser/9.6.10990.400', null, '2017-05-24 09:27:35'), ('19', '1018', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-05-24 09:33:32'), ('20', '1004', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0', 'keep-alive', '2017-05-24 09:37:42'), ('21', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:48.0) Gecko/20100101 Firefox/48.0', 'close', '2017-05-24 09:41:12'), ('22', '1005', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36', 'keep-alive', '2017-05-24 10:14:43'), ('23', '1005', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36', 'keep-alive', '2017-05-24 10:35:34'), ('24', '1018', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-05-24 14:24:14'), ('25', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-24 16:05:37'), ('26', '1006', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36', 'keep-alive', '2017-05-24 16:12:54'), ('27', '1005', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36', 'keep-alive', '2017-05-24 16:16:52'), ('28', '1005', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36', 'keep-alive', '2017-05-24 17:15:20'), ('29', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:48.0) Gecko/20100101 Firefox/48.0', 'close', '2017-05-24 18:03:04'), ('30', '1018', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-05-24 19:25:08'), ('31', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-25 11:26:05'), ('32', '1', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.zoufanqi.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,en-US;q=0.8', 'Mozilla/5.0 (Linux; U; Android 5.1; zh-CN; PRO 5 Build/LMY47D) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/40.0.2214.89 UCBrowser/11.5.2.942 Mobile Safari/537.36', 'keep-alive', '2017-05-25 16:18:09'), ('33', '1005', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36', 'keep-alive', '2017-05-25 16:24:31'), ('34', '1005', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36', 'keep-alive', '2017-05-25 16:29:07'), ('35', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-25 17:39:33'), ('36', '1018', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', null, '2017-05-26 09:58:26'), ('37', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', '47.93.255.190', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-05-26 10:47:15'), ('38', '520', '1', '101.204.21.0', 'HTTP/1.1', 'http', 'www.zoufanqi.com', '101.204.21.0', '101.204.21.0', 'UTF-8', '*/*', 'gzip,deflate', 'zh-CN,en-US;q=0.8', 'Mozilla/5.0 (Linux; Android 6.0; vivo Y67L Build/MRA58K) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/38.0.0.0 Mobile Safari/537.36 VivoBrowser/5.1.4', 'keep-alive', '2017-06-02 23:21:08'), ('39', '1', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-06-03 11:50:46'), ('40', '1019', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', null, '2017-06-03 16:48:16'), ('41', '1018', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-06-05 15:41:21'), ('42', '1020', '1', '183.3.218.5', 'HTTP/1.1', 'http', 'www.qiqinote.com', '183.3.218.5', '183.3.218.5', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36', 'keep-alive', '2017-06-06 10:54:39'), ('43', '1020', '1', '183.14.28.71', 'HTTP/1.1', 'http', 'www.qiqinote.com', '183.14.28.71', '183.14.28.71', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-06-06 21:26:35'), ('44', '1020', '1', '183.3.218.5', 'HTTP/1.1', 'http', 'www.qiqinote.com', '183.3.218.5', '183.3.218.5', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36', 'keep-alive', '2017-06-07 16:28:23'), ('45', '1021', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-06-09 09:48:24'), ('46', '1020', '1', '183.14.133.16', 'HTTP/1.1', 'http', 'www.qiqinote.com', '183.14.133.16', '183.14.133.16', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-06-12 22:54:34'), ('47', '1020', '1', '183.14.133.16', 'HTTP/1.1', 'http', 'www.qiqinote.com', '183.14.133.16', '183.14.133.16', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'keep-alive', '2017-06-12 22:54:34'), ('48', '1020', '1', '183.3.218.5', 'HTTP/1.1', 'http', 'www.qiqinote.com', '183.3.218.5', '183.3.218.5', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36', 'keep-alive', '2017-06-15 11:32:58'), ('49', '1005', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'en-US,en;q=0.5', 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0', 'keep-alive', '2017-06-16 14:45:44'), ('50', '1022', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate', 'zh-cn', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/603.2.4 (KHTML, like Gecko) Version/10.1.1 Safari/603.2.4', 'keep-alive', '2017-06-16 14:53:22'), ('51', '110', '1', '60.247.26.241', 'HTTP/1.1', 'http', 'www.qiqinote.com', '60.247.26.241', '60.247.26.241', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36', 'keep-alive', '2017-06-16 15:30:48'), ('52', '110', '1', '60.247.26.241', 'HTTP/1.1', 'http', 'www.qiqinote.com', '60.247.26.241', '60.247.26.241', 'UTF-8', '*/*', 'gzip, deflate', 'zh-cn', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/603.2.4 (KHTML, like Gecko) Version/10.1.1 Safari/603.2.4', 'keep-alive', '2017-06-16 16:25:30'), ('53', '110', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36', 'keep-alive', '2017-06-16 16:31:40'), ('54', '1000', '1', '124.126.123.214', 'HTTP/1.1', 'http', 'www.qiqinote.com', '124.126.123.214', '124.126.123.214', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36', null, '2017-06-16 17:18:07'), ('55', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.zoufanqi.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-06-19 17:52:06'), ('56', '1018', '1', '123.113.70.177', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-06-19 21:31:48'), ('57', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-06-20 13:50:15'), ('58', '1020', '1', '183.14.132.159', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-06-20 21:55:14'), ('59', '1020', '1', '183.14.132.159', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-06-20 21:56:07'), ('60', '1', '1', '123.113.71.36', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-06-23 23:05:03'), ('61', '110', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36', 'close', '2017-06-26 14:54:22'), ('62', '1018', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-06-26 14:55:19'), ('63', '1020', '1', '14.215.134.131', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36', 'close', '2017-06-29 15:22:12'), ('64', '1020', '1', '183.14.132.104', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-07-01 22:53:41'), ('65', '1020', '1', '14.215.134.131', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36', 'close', '2017-07-03 09:40:09'), ('66', '1018', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-07-05 15:28:09'), ('67', '1018', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-07-06 14:44:00'), ('68', '1018', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-07-06 17:23:27'), ('69', '1000', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.3176.400 QQBrowser/9.6.11520.400', 'close', '2017-07-11 16:38:20'), ('70', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36', 'close', '2017-07-26 19:20:47'), ('71', '1005', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36', 'close', '2017-07-27 16:22:40'), ('72', '1005', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'en-US,en;q=0.5', 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:54.0) Gecko/20100101 Firefox/54.0', 'close', '2017-07-27 17:38:02'), ('73', '1005', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate, sdch', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36', 'close', '2017-07-28 15:16:45'), ('74', '1005', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'en-US,en;q=0.5', 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:54.0) Gecko/20100101 Firefox/54.0', 'close', '2017-07-31 11:32:32'), ('75', '1018', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36', 'close', '2017-08-09 10:28:06'), ('76', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36', 'close', '2017-08-22 14:09:49'), ('77', '1', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36', 'close', '2017-08-22 15:49:20'), ('78', '1023', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.zoufanqi.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36', 'close', '2017-09-04 17:44:01'), ('79', '1', '1', '174.138.71.53', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36', 'close', '2017-09-25 11:37:01'), ('80', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36', 'close', '2017-09-25 14:47:32'), ('81', '1018', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'close', '2017-09-27 10:40:20'), ('82', '1018', '1', '124.126.123.214', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'close', '2017-09-28 14:54:28'), ('83', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36', 'close', '2017-09-28 18:20:22'), ('84', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36', 'close', '2017-10-11 17:18:13'), ('85', '1', '1', '223.104.3.247', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,en-US;q=0.8', 'Mozilla/5.0 (Linux; U; Android 7.0; zh-CN; PRO 5 Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/40.0.2214.89 UCBrowser/11.7.0.953 Mobile Safari/537.36', 'close', '2017-10-19 20:08:24'), ('86', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'close', '2017-10-20 16:43:21'), ('87', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8,en;q=0.6', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'close', '2017-10-25 15:17:57'), ('88', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'close', '2017-10-31 17:53:56'), ('89', '1024', '1', '36.5.132.197', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36', 'close', '2017-11-28 14:16:46'), ('90', '1024', '1', '36.5.132.197', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36', 'close', '2017-11-28 14:40:13'), ('91', '1024', '1', '36.5.144.123', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.8', 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36', 'close', '2017-12-01 14:26:51'), ('92', '1018', '1', '111.207.58.93', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36', 'close', '2018-01-11 16:05:29'), ('93', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36', 'close', '2018-01-11 17:07:04'), ('94', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36', 'close', '2018-02-06 11:58:16'), ('95', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'close', '2018-02-23 19:19:49'), ('96', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'close', '2018-02-24 18:49:05'), ('97', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'close', '2018-03-06 16:17:09'), ('98', '1', '1', '218.241.195.18', 'HTTP/1.0', 'http', 'www.qiqinote.com', '127.0.0.1', '127.0.0.1', 'UTF-8', 'application/json, text/javascript, */*; q=0.01', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'close', '2018-03-15 12:13:21'), ('99', '110', '1', '221.216.54.36', 'HTTP/1.1', 'http', '140.143.225.238', '221.216.54.36', '221.216.54.36', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'keep-alive', '2018-03-31 02:15:41'), ('100', '1', '1', '221.216.54.36', 'HTTP/1.1', 'http', '140.143.225.238', '221.216.54.36', '221.216.54.36', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'keep-alive', '2018-03-31 02:45:26'), ('101', '1', '0', '221.216.54.36', 'HTTP/1.1', 'http', '140.143.225.238', '221.216.54.36', '221.216.54.36', 'UTF-8', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'keep-alive', '2018-04-01 18:34:40'), ('102', '1', '1', '221.216.54.36', 'HTTP/1.1', 'http', '140.143.225.238', '221.216.54.36', '221.216.54.36', 'UTF-8', '*/*', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'keep-alive', '2018-04-01 19:46:28'), ('103', '1', '0', '221.216.54.36', 'HTTP/1.1', 'http', '140.143.225.238', '221.216.54.36', '221.216.54.36', 'UTF-8', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'keep-alive', '2018-04-01 20:21:50'), ('104', '1', '0', '218.241.195.18', 'HTTP/1.1', 'http', '140.143.225.238', '218.241.195.18', '218.241.195.18', 'UTF-8', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'keep-alive', '2018-04-02 10:38:00'), ('105', '1', '0', '218.241.195.18', 'HTTP/1.1', 'http', '140.143.225.238', '218.241.195.18', '218.241.195.18', 'UTF-8', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'keep-alive', '2018-04-02 12:12:23'), ('106', '1', '0', '218.241.195.18', 'HTTP/1.1', 'http', '140.143.225.238', '218.241.195.18', '218.241.195.18', 'UTF-8', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'gzip, deflate', 'zh-CN,zh;q=0.9,en;q=0.8', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36', 'keep-alive', '2018-04-02 14:02:30');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
